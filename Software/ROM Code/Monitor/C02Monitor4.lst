  Thu Mar 16 2023 11:46                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C02 Macro Assembler    **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;**************************************************************************************************
     2                        ;*   C02Monitor 4.02 - Release version for Pocket SBC  (c)2013-2023 by Kevin E. Maier 15/02/2023  *
     3                        ;*                                                                                                *
     4                        ;*  Monitor Functions are divided into groups as follows:                                         *
     5                        ;*   1. Memory Operations:                                                                        *
     6                        ;*      - Fill Memory: Source, Length, Value (prompts for commit)                                 *
     7                        ;*      - Move Memory: Source, Target, Length (prompts for commit)                                *
     8                        ;*      - Compare Memory: Source, Target, Length                                                  *
     9                        ;*      - Examine/Edit: Address, Data (edit) sequential memory                                    *
    10                        ;*      - Input ASCII Text into memory: Address, Data (ESC quits)                                 *
    11                        ;*      - Hex Data Search: Hex data up to 16 bytes                                                *
    12                        ;*      - Text String Search: ASCII data up to 16 characters                                      *
    13                        ;*      - Display Memory as Hex/ASCII: Address start - 256 consecutive bytes displayed            *
    14                        ;*      - Execute from Memory: Start address                                                      *
    15                        ;*                                                                                                *
    16                        ;*   2. Register Operations:                                                                      *
    17                        ;*      - Display All Registers                                                                   *
    18                        ;*      - Display/Edit A, X, Y, (S)tack Pointer, (P)rocessor Status                               *
    19                        ;*                                                                                                *
    20                        ;*   3. Timer/Counter Functions:                                                                  *
    21                        ;*      - Set delay time: 8-bit 10-millisecond count and 16-bit multiplier count                  *
    22                        ;*      - Execute Millisecond Delay 1-256 times 10ms (Jiffy Clock)                                *
    23                        ;*      - Execute Millisecond Delay times 16-bit multiplier count (0-65535)                       *
    24                        ;*      - RTC function based on 10ms Jiffy Clock: Ticks, Seconds, Minutes, Hours, Date            *
    25                        ;*      - Benchmark timing up to 65535.99 seconds with 10ms resolution                            *
    26                        ;*                                                                                                *
    27                        ;*   4. Keyboard Macro Facility:                                                                  *
    28                        ;*      - Provides up to 127 byte keyboard buffer loop capability                                 *
    29                        ;*      - Optional 16-bit Loop Counter (1-65,535)                                                 *
    30                        ;*      - Send Break command (from Terminal program) exits Macro function                         *
    31                        ;*                                                                                                *
    32                        ;*   5. Control-Key Functions:                                                                    *
    33                        ;*      - CTRL-A: Starts Assembler for simple code entry based on Mnemonics (not completed yet)   *
    34                        ;*      - CTRL-B: Starts Rich Leary's DOS/65 ROM Version 3                                        *
    35                        ;*      - CTRL-D: Table-Driven Disassembler - Supports Full WDC Opcodes/Addressing modes          *
    36                        ;*      - CTRL-E: Edit single byte in the EEPROM - uses BurnByte routine to ensure proper write   *
    37                        ;*      - CTRL-L: Xmodem Loader w/CRC-16 Support, auto detect S19 Records from WDC Linker         *
    38                        ;*      - CTRL-P: Program EEPROM - Source, Target, Length (Source must be RAM based)              *
    39                        ;*      - CTRL-Q: Query Commands - Shows all available Monitor functions                          *
    40                        ;*      - CTRL-R: Reset System - Initiates Cold Start of BIOS and Monitor                         *
    41                        ;*      - CTRL-S: Xmodem Save w/CRC-16 Support                                                    *
    42                        ;*      - CTRL-T: Date and Time - values loaded during boot from RTC                              *
    43                        ;*      - CTRL-V: Shows Version for BIOS and Monitor                                              *
    44                        ;*      - CTRL-Z: Zeros out ALL RAM and initiates Cold Start of BIOS and Monitor                  *
    45                        ;*                                                                                                *
    46                        ;*   6. Panic Button (NMI Support Routine in C02BIOS)                                             *
    47                        ;*      - Re-initializes Vector and Configuration Data in Page $03                                *
    48                        ;*      - Clears Console Buffer pointers in Page $00 and restarts Console only                    *
    49                        ;**************************************************************************************************
    50                                PL      66      ;Page Length
    51                                PW      132     ;Page Width (# of char/line)
    52                                CHIP    W65C02S ;Enable WDC 65C02 instructions
    53                                PASS1   OFF     ;Set ON for debugging
    54                                INCLIST ON      ;Set ON for listing Include files
    55                        ;**************************************************************************************************
    56                        ; Page Zero definitions $00 to $9F reserved for user routines
    57                        ; NOTES:- Locations $00 and $01 are used to zero RAM (calls CPU reset)
  Thu Mar 16 2023 11:46                                                                                                    Page 2


    58                        ;       - EEPROM Byte Write routine loaded into Page Zero at $88-$9C
    59                        ;       - Enhanced Basic uses locations $00 - $85
    60                        ;**************************************************************************************************
    61                        ;
    62                        ; This BIOS and Monitor version also use a common source file for constants and variables used by
    63                        ; both. This just simplifies keeping both code pieces in sync.
    64                        ;
    65                                INCLUDE         C02Constants4.asm
     1                        ;**************************************************************************************************
     2                        ;*                                                                                                *
     3                        ;*              C02 Constants used for the 4.0x releases of C02BIOS4 and C02Monitor4              *
     4                        ;*                                                                                                *
     5                        ;*                                                                                                *
     6                        ;*                                  15/02/2023 (Day/Month/Year)                                   *
     7                        ;*                                                                                                *
     8                        ;**************************************************************************************************
     9                        ; C02BIOS / C02Monitor Version is now at 4.02                                                     *
    10                        ; - All Constants and Variables are now defined in a single source file (this one) for assembling *
    11                        ; - both the C02BIOS4 and the C02Monitor4. It is also used for the Template for writing code to   *
    12                        ; - be used for the C02 Pocket SBC and Adapters.                                                  *
    13                        ;                                                                                                 *
    14                        ; - Be sure to include this file at the start of any source file that needs it.                   *
    15                        ;                                                                                                 *
    16                        ;**************************************************************************************************
    17                        ;                                                                                                 *
    18                        ;          - Page Zero locations $00 to $9F (160 bytes) reserved for user applications            * 
    19                        ;                                                                                                 *
    20                        ;**************************************************************************************************
    21                        ;
    22             000000A0   PGZERO_ST       .EQU    $A0                     ;Start of Monitor Page 0 use ($A0-$CF, 48 bytes)
    23                        ;
    24             000000A0   BUFF_PG0        .EQU    PGZERO_ST+00            ;Default Page zero location for Monitor buffers
    25                        ;
    26             000000A0   INBUFF          .EQU    BUFF_PG0+00             ;Input Buffer - 4 bytes ($A0-$A3)
    27             000000A4   DATABUFF        .EQU    BUFF_PG0+04             ;Data Buffer - 6 bytes ($A4-$A9)
    28                        ;
    29                        ;       - 16-bit variables:
    30             000000AA   HEXDATAH        .EQU    PGZERO_ST+10            ;Hexadecimal input
    31             000000AB   HEXDATAL        .EQU    PGZERO_ST+11
    32             000000AC   BINVALL         .EQU    PGZERO_ST+12            ;Binary Value for HEX2ASC
    33             000000AD   BINVALH         .EQU    PGZERO_ST+13
    34             000000AE   COMLO           .EQU    PGZERO_ST+14            ;User command address
    35             000000AF   COMHI           .EQU    PGZERO_ST+15
    36             000000B0   INDEXL          .EQU    PGZERO_ST+16            ;Index for address - multiple routines
    37             000000B1   INDEXH          .EQU    PGZERO_ST+17
    38             000000B2   TEMP1L          .EQU    PGZERO_ST+18            ;Index for word temp value used by Memdump
    39             000000B3   TEMP1H          .EQU    PGZERO_ST+19
    40             000000B4   TEMP2L          .EQU    PGZERO_ST+20            ;Index for Text entry
    41             000000B5   TEMP2H          .EQU    PGZERO_ST+21
    42             000000B6   PROMPTL         .EQU    PGZERO_ST+22            ;Prompt string address
    43             000000B7   PROMPTH         .EQU    PGZERO_ST+23
    44             000000B8   SRCL            .EQU    PGZERO_ST+24            ;Source address for memory operations
    45             000000B9   SRCH            .EQU    PGZERO_ST+25
    46             000000BA   TGTL            .EQU    PGZERO_ST+26            ;Target address for memory operations
    47             000000BB   TGTH            .EQU    PGZERO_ST+27
    48             000000BC   LENL            .EQU    PGZERO_ST+28            ;Length address for memory operations
    49             000000BD   LENH            .EQU    PGZERO_ST+29
    50                        ;
    51                        ;       - 8-bit variables and constants:
    52             000000BE   BUFIDX          .EQU    PGZERO_ST+30            ;Buffer index
    53             000000BF   BUFLEN          .EQU    PGZERO_ST+31            ;Buffer length
    54             000000C0   IDX             .EQU    PGZERO_ST+32            ;Temp Indexing
    55             000000C1   IDY             .EQU    PGZERO_ST+33            ;Temp Indexing
  Thu Mar 16 2023 11:46                                                                                                    Page 3


    56             000000C2   TEMP1           .EQU    PGZERO_ST+34            ;Temp - Code Conversion routines
    57             000000C3   TEMP2           .EQU    PGZERO_ST+35            ;Temp - Memory/EEPROM/SREC routines - Disassembler
    58             000000C4   TEMP3           .EQU    PGZERO_ST+36            ;Temp - EEPROM/SREC routines
    59             000000C5   CMDFLAG         .EQU    PGZERO_ST+37            ;Command Flag, bit specific, used by many routines
    60             000000C6   OPXMDM          .EQU    PGZERO_ST+38            ;Saved Opcode/Xmodem Flag variable
    61                        ;
    62                        ;       - Xmodem transfer variables
    63             000000C7   CRCHI           .EQU    PGZERO_ST+39            ;CRC hi byte  (two byte variable)
    64             000000C8   CRCLO           .EQU    PGZERO_ST+40            ;CRC lo byte - Operand in Disassembler
    65             000000C9   CRCCNT          .EQU    PGZERO_ST+41            ;CRC retry count - Operand in Disassembler
    66             000000CA   PTRL            .EQU    PGZERO_ST+42            ;Data pointer lo byte - Mnemonic in Disassembler
    67             000000CB   PTRH            .EQU    PGZERO_ST+43            ;Data pointer hi byte - Mnemonic in Disassembler
    68             000000CC   BLKNO           .EQU    PGZERO_ST+44            ;Block number
    69                        ;
    70                        ;        - Macro Loop Counter variables
    71             000000CD   LPCNTL          .EQU    PGZERO_ST+45            ;Loop Count low byte
    72             000000CE   LPCNTH          .EQU    PGZERO_ST+46            ;Loop Count high byte
    73                        ;
    74                        ;       - Spare Monitor byte for future use
    75             000000CF   SPARE_M0        .EQU    PGZERO_ST+47            ;Spare Monitor page zero byte
    76                        ;
    77                        ;       - BIOS variables, pointers, flags located at top of Page Zero
    78             000000D0   BIOS_PG0        .EQU    PGZERO_ST+48            ;Start of BIOS page 0 use ($D0-$FF, 48 bytes)
    79                        ;
    80                        ;       - BRK handler routine
    81             000000D0   PCL             .EQU    BIOS_PG0+00             ;Program Counter Low index
    82             000000D1   PCH             .EQU    BIOS_PG0+01             ;Program Counter High index
    83             000000D2   PREG            .EQU    BIOS_PG0+02             ;Temp Status Reg
    84             000000D3   SREG            .EQU    BIOS_PG0+03             ;Temp Stack ptr
    85             000000D4   YREG            .EQU    BIOS_PG0+04             ;Temp Y Reg
    86             000000D5   XREG            .EQU    BIOS_PG0+05             ;Temp X Reg
    87             000000D6   AREG            .EQU    BIOS_PG0+06             ;Temp A Reg
    88                        ;
    89                        ;       - 28L92 IRQ handler pointers and status
    90             000000D7   ICNT_A          .EQU    BIOS_PG0+07             ;Input buffer count
    91             000000D8   IHEAD_A         .EQU    BIOS_PG0+08             ;Input buffer head pointer
    92             000000D9   ITAIL_A         .EQU    BIOS_PG0+09             ;Input buffer tail pointer
    93             000000DA   OCNT_A          .EQU    BIOS_PG0+10             ;Output buffer count
    94             000000DB   OHEAD_A         .EQU    BIOS_PG0+11             ;Output buffer head pointer
    95             000000DC   OTAIL_A         .EQU    BIOS_PG0+12             ;Output buffer tail pointer
    96                        ;
    97             000000DD   ICNT_B          .EQU    BIOS_PG0+13             ;Input buffer count
    98             000000DE   IHEAD_B         .EQU    BIOS_PG0+14             ;Input buffer head pointer
    99             000000DF   ITAIL_B         .EQU    BIOS_PG0+15             ;Input buffer tail pointer
   100             000000E0   OCNT_B          .EQU    BIOS_PG0+16             ;Output buffer count
   101             000000E1   OHEAD_B         .EQU    BIOS_PG0+17             ;Output buffer head pointer
   102             000000E2   OTAIL_B         .EQU    BIOS_PG0+18             ;Output buffer tail pointer
   103             000000E3   UART_IRT        .EQU    BIOS_PG0+19             ;SC28L92 Interrupt Status byte
   104                        ;
   105                        ;       - Real-Time Clock variables
   106                        ; These are repurposed for adding a Realtime clock chip (DS1501/DS1511)
   107                        ; The Ticks, Seconds, Minutes and Hours remain the same in function.
   108                        ; The 16-bit Days variable is replaced however.
   109                        ; - The DAY_DATE is a new variable. To minimize Page Zero usage, it has two functions
   110                        ;       Bits 0-4 represent the days of the Month 1-31
   111                        ;       Bits 5-7 represent the Day of the Week, 1-7 (Saturday=1)
   112                        ; The Months are handled by the upper 4 bits of the MONTH_YEAR variable
   113                        ; The Century is handled by a the Year (0-255) and the lower 4 bits of the MONTH_YEAR variable
   114                        ;
   115             000000E4   TICKS           .EQU    BIOS_PG0+20             ;Number of timer countdowns = 1 second (100)
   116             000000E5   SECS            .EQU    BIOS_PG0+21             ;Seconds: 0-59
   117             000000E6   MINS            .EQU    BIOS_PG0+22             ;Minutes: 0-59
   118             000000E7   HOURS           .EQU    BIOS_PG0+23             ;Hours: 0-23
  Thu Mar 16 2023 11:46                                                                                                    Page 4


   119             000000E8   DAY_DATE        .EQU    BIOS_PG0+24             ;Day: (bits 5-7) Date: (bits 0-4)
   120             000000E9   MONTH_CENTURY   .EQU    BIOS_PG0+25             ;Month: (bits 4-7) Century: (bits 0-3)
   121             000000EA   YEAR            .EQU    BIOS_PG0+26             ;Century 0-255 plus 4 bits as noted above
   122             000000EB   RTC_TEMP        .EQU    BIOS_PG0+27             ;Temp work byte for updating shared variables
   123                        ;
   124                        ;       - Delay Timer variables
   125             000000EC   MSDELAY         .EQU    BIOS_PG0+28             ;Timer delay countdown byte (255 > 0)
   126             000000ED   SETMS           .EQU    BIOS_PG0+29             ;Set timeout for delay routines - BIOS use only
   127             000000EE   DELLO           .EQU    BIOS_PG0+30             ;Delay value BIOS use only
   128             000000EF   DELHI           .EQU    BIOS_PG0+31             ;Delay value BIOS use only
   129                        ;
   130                        ;       - Count variables for 10ms benchmark timing
   131             000000F0   MS10_CNT        .EQU    BIOS_PG0+32             ;10ms Count variable
   132             000000F1   SECL_CNT        .EQU    BIOS_PG0+33             ;Seconds Low byte count
   133             000000F2   SECH_CNT        .EQU    BIOS_PG0+34             ;Seconds High byte count
   134                        ;
   135                        ;       - Address and pointers for IDE Interface
   136             000000F3   LBA_ADDR_LOW    .EQU    BIOS_PG0+35             ;LBA Transfer Address low byte
   137             000000F4   LBA_ADDR_HIGH   .EQU    BIOS_PG0+36             ;LBA Transfer Address high byte
   138                        ;
   139             000000F5   LBA_XFER_CNT    .EQU    BIOS_PG0+37             ;LBA Transfer Count 1-xx (check RAM space!)
   140             000000F6   LBA_LOW_BYTE    .EQU    BIOS_PG0+38             ;LBA Block number bits 0-7
   141             000000F7   LBA_HIGH_BYTE   .EQU    BIOS_PG0+39             ;LBA Block number bits 8-15
   142             000000F8   LBA_EXT_BYTE    .EQU    BIOS_PG0+40             ;LBA Block number bits 16-23
   143                        ;
   144             000000F9   BIOS_XFERL      .EQU    BIOS_PG0+41             ;BIOS Move Routine low byte
   145             000000FA   BIOS_XFERH      .EQU    BIOS_PG0+42             ;BIOS Move Routine high byte
   146             000000FB   BIOS_XFERC      .EQU    BIOS_PG0+43             ;BIOS Block Count moved (needs to be set)
   147                        ;
   148             000000FC   IDE_STATUS_RAM  .EQU    BIOS_PG0+44             ;IDE RAM-Based Status
   149                        ;
   150             000000FD   SPARE_B0        .EQU    BIOS_PG0+45             ;Spare byte 0
   151             000000FE   SPARE_B1        .EQU    BIOS_PG0+46             ;Spare byte 1
   152                        ;
   153                        ;       - Timer/Counter Match flag for Delay/Benchmark
   154             000000FF   MATCH           .EQU    BIOS_PG0+47             ;Bit7 used for Delay, Bit6 used for Benchmark
   155                                                                        ;Bits 3,2,1 used for IDE Interrupt Handler
   156                        ;
   157                        ;       - Default for RTC tick count - number of IRQs for 1 second
   158             00000064   DF_TICKS        .EQU    100                     ;Timer is 10 milliseconds (100 x 10ms = 1 second)
   159                        ;
   160                        ;**************************************************************************************************
   161             00000200   IBUF_A          .EQU    $0200                   ;Console Input Buffer - 128 bytes
   162             00000280   OBUF_A          .EQU    $0280                   ;Console Output Buffer - 128 bytes
   163                        ;
   164             00000400   IBUF_B          .EQU    $0400                   ;Alternate Input Buffer - 128 bytes
   165             00000480   OBUF_B          .EQU    $0480                   ;Alternate Output Buffer - 128 bytes
   166                        ;**************************************************************************************************
   167             00000300   SOFTVEC         .EQU    $0300                   ;Start of soft vectors
   168                        ;The Interrupt structure is vector based. During startup, Page $03 is loaded from ROM.
   169                        ; The soft vectors are structured to allow inserting additional routines either before
   170                        ; or after the ROM based routines. This allows flexibility and changing of routine priority.
   171                        ;
   172                        ;The main set of vectors occupy the first 16 bytes of Page $03. The ROM handler for
   173                        ; NMI, BRK and IRQ jump to the first 3 vectors. The following 3 vectors are loaded with
   174                        ; return addresses to the ROM handler for each. The following 2 vectors are the cold and
   175                        ; warm entry points for the Monitor. After the basic initialization, the monitor is entered.
   176                        ;
   177                        ;The following vector set allows inserts, pre or post for NMI/BRK/IRQ. There a total of 8 inserts
   178                        ; which occupy 16 bytes. They can be used as required.
   179                        ; Currently, VECINSRT0 will be used if an IDE Controller is detected.
   180                        ;
   181             00000300   NMIVEC0         .EQU    SOFTVEC+00              ;NMI Vector Entry 0
  Thu Mar 16 2023 11:46                                                                                                    Page 5


   182             00000302   BRKVEC0         .EQU    SOFTVEC+02              ;BRK Vector Entry 0
   183             00000304   IRQVEC0         .EQU    SOFTVEC+04              ;IRQ Vector Entry 0
   184                        ;
   185             00000306   NMIRTVEC0       .EQU    SOFTVEC+06              ;NMI Vector Return 0
   186             00000308   BRKRTVEC0       .EQU    SOFTVEC+08              ;BRK Vector Return 0
   187             0000030A   IRQRTVEC0       .EQU    SOFTVEC+10              ;IRQ Vector Return 0
   188                        ;
   189             0000030C   CLDMNVEC0       .EQU    SOFTVEC+12              ;Monitor Cold Entry Vector 0
   190             0000030E   WRMMNVEC0       .EQU    SOFTVEC+14              ;Monitor Warm Entry Vector 0
   191                        ;
   192             00000310   VECINSRT0       .EQU    SOFTVEC+16              ;1st Vector Insert
   193             00000312   VECINSRT1       .EQU    SOFTVEC+18              ;2nd Vector Insert
   194             00000314   VECINSRT2       .EQU    SOFTVEC+20              ;3rd Vector Insert
   195             00000316   VECINSRT3       .EQU    SOFTVEC+22              ;4th Vector Insert
   196             00000318   VECINSRT4       .EQU    SOFTVEC+24              ;5th Vector Insert
   197             0000031A   VECINSRT5       .EQU    SOFTVEC+26              ;6th Vector Insert
   198             0000031C   VECINSRT6       .EQU    SOFTVEC+28              ;7th Vector Insert
   199             0000031E   VECINSRT7       .EQU    SOFTVEC+30              ;8th Vector Insert
   200                        ;
   201                        ;**************************************************************************************************
   202                        ;
   203                        ;Soft Config values below are loaded from ROM and are the default I/O setup Configuration data that
   204                        ; the INIT_x routines use. As a result, you can write a routine to change the I/O Configuration
   205                        ; data and use the standard ROM routines to initialize the I/O without restarting or changing ROM
   206                        ; A Reset (HW or coded) will reinitialize the I/O with the ROM default I/O Configuration.
   207                        ;
   208                        ;There are a total of 32 Bytes Configuration data reserved starting at $0320,
   209                        ; - 22 bytes are reserved for the NXP SC28L92 DUART.
   210                        ;
   211             00000320   SOFTCFG         .EQU    SOFTVEC+32              ;Start of hardware Config parameters
   212                        ;
   213             00000320   LOAD_28L92      .EQU    SOFTCFG+00              ;SC28L92 Soft Config Data
   214                        ;
   215                        ; The configuration for the DUART consists of 14 parameters/commands stored in the following
   216                        ; - memory locations. Note that these are sent in reverse, i.e., $32E thru $320.
   217                        ;
   218                        ;       $320    .DB     %00000011       $03     ;Enable OP0/1 for RTS control Port A/B
   219                        ;       $321    .DB     %00001010       $A0     ;Disable Receiver/Disable Transmitter B
   220                        ;       $322    .DB     %00001001       $09     ;Enable Receiver/Disable Transmitter A
   221                        ;       $323    .DB     %00001111       $0F     ;Interrupt Mask Register setup
   222                        ;       $324    .DB     %11100000       $E0     ;Aux Register setup for Counter/Timer
   223                        ;       $325    .DB     %01001000       $48     ;Counter/Timer Upper Preset (18432 decimal)
   224                        ;       $326    .DB     %00000000       $00     ;Counter/Timer Lower Preset
   225                        ;       $327    .DB     %11001100       $CC     ;Baud Rate clock for B Rcv/Xmt - 115.2K
   226                        ;       $328    .DB     %11001100       $CC     ;Baud Rate clock for A Rcv/Xmt - 115.2K
   227                        ;       $329    .DB     %00110000       $30     ;Reset Transmitter B
   228                        ;       $32A    .DB     %00100000       $20     ;Reset Receiver B
   229                        ;       $32B    .DB     %00110000       $30     ;Reset Transmitter A
   230                        ;       $32C    .DB     %00100000       $20     ;Reset Receiver A
   231                        ;       $32D    .DB     %00000000       $00     ;Interrupt Mask Register setup (clear)
   232                        ;       $32E    .DB     %11110000       $F0     ;Command Register A - Disable Power Down
   233                        ;       $32F    .DB     %11111111       $FF     ;Spare Byte
   234                        ;
   235                        ; The MR registers of the DUART also have soft config data loaded here, but is separate from the
   236                        ; - main register config data, as these are all accessed via a single I/O port (auto-indexed).
   237                        ; - These are also sent in reverse order as above.
   238                        ;
   239                        ;       $330    .DB     %00010111       $17     ;Mode Register 2 data
   240                        ;       $331    .DB     %11010011       $D3     ;Mode Register 1 Data
   241                        ;       $332    .DB     %11111001       $F9     ;Mode Register 0 Data
   242                        ;
   243                        ;       $333    .DB     %00010111       $17     ;Mode Register 2 data
   244                        ;       $334    .DB     %11010011       $D3     ;Mode Register 1 Data
  Thu Mar 16 2023 11:46                                                                                                    Page 6


   245                        ;       $335    .DB     %11000001       $C1     ;Mode Register 0 Data
   246                        ;
   247                        ;       10 additional bytes all reserved as $FF fill up the remaining soft configuration data.
   248                        ;
   249                        ; The Microdrive is initialized and the total LBA count is save here during startup.
   250                        ;  It is used by various utilities and allows drive capacity sensing without sending additional
   251                        ;  commands to the Microdrive. A total of 4 bytes are used for a 32-bit LBA count. These are saved
   252                        ;  at addresses $33C - $33F. Order is low-word/high-word. Each word is low-byte/high/byte.
   253                        ;
   254             0000033C   LOAD_IDE        .EQU    SOFTCFG+28              ;IDE/CF-Card Soft Config Data
   255                        ;
   256                        ;       $33C    .DW                             ;Low order LBA count
   257                        ;       $33E    .DW                             ;High order LBA count
   258                        ;
   259                        ;Search Buffer is 16 bytes in length. Used to hold search string for text or hex data
   260             00000340   SRCHBUFF        .EQU    SOFTCFG+32              ;Located in Page $03 following Hardware Config data
   261                        ;       $340                                    ;Start of search buffer (16 bytes)
   262                        ;
   263                        ;Xmodem/CRC Loader also provides Motorola S19 Record sense and load. Designed to handle the S19
   264                        ; records from the WDC Assembler/Linker package. This requires a 44 byte buffer to parse each valid
   265                        ; S1 record, located just before the 132 Byte Xmodem frame buffer. Total Buffer space for the
   266                        ; Xmodem/CRC Loader is 176 bytes
   267                        ;
   268                        ;Valid S-record headers are "S1" and "S9". For S1, the maximum length is "$19" hex. The last S1
   269                        ; record can be less. S9 record is always the last record with no data. WDC Linker also appends
   270                        ; a CR/LF to the end of each record for a total of 44 bytes.
   271                        ;
   272             00000350   SRBUFF          .EQU    SOFTCFG+48              ;S-Record buffer, up to 44 bytes in length
   273                        ;       $350                                    ;Start of S-Record buffer
   274                        ;
   275                        ;Xmodem frame buffer. The entire Xmodem frame is buffered here and then checked for proper header
   276                        ; and frame number, CRC-16 on the data, then moved to user RAM.
   277             0000037C   RBUFF           .EQU    SOFTCFG+92              ;Xmodem temp 132 byte receive buffer
   278                        ;       $37C                                    ;Start of Receive buffer for Xmodem
   279                        ;
   280                        ;Page $03 is completely allocated for Buffers, Config Data and Vector pointers.
   281                        ; Some of the buffer space can be used as needed, provided any required Monitor functions are NOT
   282                        ; being used concurrently.
   283                        ;
   284                        ;**************************************************************************************************
   285                        ;
   286                        ;Page $05 is used for the Realtime Clock NVRAM read and write routines
   287             00000500   NVRAM_DATA      .EQU    $0500                   ;NVRAM Data Buffer address
   288                        ;
   289                        ;**************************************************************************************************
   290                        ;
   291                        ;Pages $06 - $07 are used for the IDE device Block Buffer (512 bytes)
   292             00000600   LBA_BUFFER      .EQU    $0600                   ;Default IDE Block Buffer address
   293             00000800   BOOT_BUFFER     .EQU    $0800                   ;Default IDE Boot Buffer address
   294                        ; 
   295                        ;**************************************************************************************************
   296                        ;XMODEM Control Character Constants
   297             00000001   SOH             .EQU    $01                     ;Start of Block Header
   298             00000004   EOT             .EQU    $04                     ;End of Text marker
   299             00000006   ACK             .EQU    $06                     ;Good Block Acknowledge
   300             00000015   NAK             .EQU    $15                     ;Bad Block Acknowledged
   301             00000018   CAN             .EQU    $18                     ;Cancel character
   302                        ;
   303                        ;**************************************************************************************************
   304                        ;RAM location used for the EEPROM Byte Write routine
   305                        ; EEPROM is the address offset of the AT28BV256 in the hardware memory map and added to the
   306                        ; EEPROM address locations required to unlock the AT28BV256 for insitu programming. For more
   307                        ; information, refer to the AT28BV256 Datasheet.
  Thu Mar 16 2023 11:46                                                                                                    Page 7


   308                        ;
   309             00000070   BURN_BYTE       .EQU    $0070                   ;Page 0 RAM for EEPROM BYTE write routine
   310             00008000   EEPROM          .EQU    $8000                   ;Offset to EEPROM in hardware
   311                        ;**************************************************************************************************
   312                        ;DOS/65 can be called from the Monitor via the Ctrl-B command.
   313                        ;The start location is just added here for convenience, but should be changed if needed.
   314                        ;
   315             0000D630   DOS_65          .EQU    $D630                   ;Default location to Boot DOS/65 (optional)
   316                        ;**************************************************************************************************
   317             0000FE00   IOPAGE          .EQU    $FE00                   ;I/O Page Base Start Address
   318                        ;**************************************************************************************************
   319             0000FE80   SC28L92_BASE    .EQU    IOPAGE+$80              ;Beginning of Console UART address
   320                        ;
   321             0000FE80   UART_MODEREG_A  .EQU    SC28L92_BASE+$00        ;MR0/MR1/MR2 Port A sequential (Read/Write)
   322             0000FE81   UART_STATUS_A   .EQU    SC28L92_BASE+$01        ;UART Status Register Port A (READ)
   323             0000FE81   UART_CLKSEL_A   .EQU    SC28L92_BASE+$01        ;UART Clock Select Port A (WRITE)
   324             0000FE82   UART_RES_A      .EQU    SC28L92_BASE+$02        ;UART Reserved Port A (READ)
   325             0000FE82   UART_COMMAND_A  .EQU    SC28L92_BASE+$02        ;UART Command Register Port A (WRITE)
   326             0000FE83   UART_RECEIVE_A  .EQU    SC28L92_BASE+$03        ;UART Receive Register Port A (READ)
   327             0000FE83   UART_TRANSMIT_A .EQU    SC28L92_BASE+$03        ;UART Transmit Register Port A (WRITE)
   328                        ;
   329             0000FE84   UART_PORT_CHG   .EQU    SC28L92_BASE+$04        ;UART Input Port Change Register (READ)
   330             0000FE84   UART_AUXCR      .EQU    SC28L92_BASE+$04        ;UART Aux Command Register (WRITE)
   331             0000FE85   UART_ISR        .EQU    SC28L92_BASE+$05        ;UART Interrupt Status Register (READ)
   332             0000FE85   UART_IMR        .EQU    SC28L92_BASE+$05        ;UART Interrupt Mask Register (WRITE)
   333                        ;
   334             0000FE86   UART_CNTU       .EQU    SC28L92_BASE+$06        ;Counter/Timer Upper Register (READ)
   335             0000FE86   UART_CNTUP      .EQU    SC28L92_BASE+$06        ;Counter/Timer Upper Preset Register (WRITE)
   336             0000FE87   UART_CNTL       .EQU    SC28L92_BASE+$07        ;Counter/Timer Lower Register (READ)
   337             0000FE87   UART_CNTLP      .EQU    SC28L92_BASE+$07        ;Counter/Timer Lower Preset Register (WRITE)
   338                        ;
   339             0000FE88   UART_MODEREG_B  .EQU    SC28L92_BASE+$08        ;MR0/MR1/MR2 Port B sequential Read/Write
   340             0000FE89   UART_STATUS_B   .EQU    SC28L92_BASE+$09        ;UART Status Register Port B (READ)
   341             0000FE89   UART_CLKSEL_B   .EQU    SC28L92_BASE+$09        ;UART Clock Select Port B (WRITE)
   342             0000FE8A   UART_RES_B      .EQU    SC28L92_BASE+$0A        ;UART Reserved Port B (READ)
   343             0000FE8A   UART_COMMAND_B  .EQU    SC28L92_BASE+$0A        ;UART Command Register Port B (WRITE)
   344             0000FE8B   UART_RECEIVE_B  .EQU    SC28L92_BASE+$0B        ;UART Receive Register Port B (READ)
   345             0000FE8B   UART_TRANSMIT_B .EQU    SC28L92_BASE+$0B        ;UART Transmit Register Port B (WRITE)
   346                        ;
   347             0000FE8C   UART_MISC       .EQU    SC28L92_BASE+$0C        ;UART Miscellaneous Register Intel (Read/Write)
   348             0000FE8D   UART_INPUT_PORT .EQU    SC28L92_BASE+$0D        ;UART Input Port Register (READ)
   349             0000FE8D   UART_OUT_CFG    .EQU    SC28L92_BASE+$0D        ;UART Ouput Port Config Register (WRITE)
   350             0000FE8E   UART_START_CNT  .EQU    SC28L92_BASE+$0E        ;UART Start Counter Command (READ)
   351             0000FE8E   UART_SOPR_CMD   .EQU    SC28L92_BASE+$0E        ;UART Set Output Port Bits Register (WRITE)
   352             0000FE8F   UART_STOP_CNT   .EQU    SC28L92_BASE+$0F        ;UART Stop Counter Command (READ)
   353             0000FE8F   UART_ROPR_CMD   .EQU    SC28L92_BASE+$0F        ;UART Reset Output Port Bits Register (WRITE)
   354                        ;
   355                        ;Additional Hardware
   356                        ; Adding BIOS definitions for Realtime Clock chip - DS1511
   357                        ; uses the first 16 addresses for RTC registers and basic operation
   358                        ; uses two addresses for extended RAM of 256 bytes
   359                        ;
   360                        ; upper addresses are used for a 16-bit IDE interface (below)
   361                        ; NOTE: offset $11 and $12 are unused (reserved per the datasheet).
   362                        ;
   363             0000FE60   RTC_IDE_BASE    .EQU    IOPAGE+$60              ;Beginning of Realtime Clock address
   364                        ;
   365             0000FE60   RTC_SECONDS     .EQU    RTC_IDE_BASE+$00        ;Seconds in BCD 00-59
   366             0000FE61   RTC_MINUTES     .EQU    RTC_IDE_BASE+$01        ;Minutes in BCD 00-59
   367             0000FE62   RTC_HOURS       .EQU    RTC_IDE_BASE+$02        ;Hours in BCD 00-23
   368             0000FE63   RTC_DAY         .EQU    RTC_IDE_BASE+$03        ;Day in BCD 1-7
   369             0000FE64   RTC_DATE        .EQU    RTC_IDE_BASE+$04        ;Date in BCD 1-31
   370             0000FE65   RTC_MONTH       .EQU    RTC_IDE_BASE+$05        ;Month in BCD 1-12
  Thu Mar 16 2023 11:46                                                                                                    Page 8


   371             0000FE66   RTC_YEAR        .EQU    RTC_IDE_BASE+$06        ;Year in BCD 00-99
   372             0000FE67   RTC_CENTURY     .EQU    RTC_IDE_BASE+$07        ;Century in BCD 00-39
   373                        ;
   374             0000FE68   RTC_ALARM_SEC   .EQU    RTC_IDE_BASE+$08        ;Alarm Seconds in BCD 00-59
   375             0000FE69   RTC_ALARM_MIN   .EQU    RTC_IDE_BASE+$09        ;Alarm Minutes in BCD 00-59
   376             0000FE6A   RTC_ALARM_HRS   .EQU    RTC_IDE_BASE+$0A        ;Alarm Hours in BCD 00-23
   377             0000FE6B   RTC_ALARM_DYDT  .EQU    RTC_IDE_BASE+$0B        ;Alarm Day/Date in BCD 0-7 1-31
   378             0000FE6C   RTC_WTCHDOG_01  .EQU    RTC_IDE_BASE+$0C        ;Watchdog 0.1 / 0.01 Seconds in BCD 00-99
   379             0000FE6D   RTC_WTCHDOG_10  .EQU    RTC_IDE_BASE+$0D        ;Watchdog 10 / 1 Seconds in BCD 00-99
   380                        ;
   381             0000FE6E   RTC_CONTROL_A   .EQU    RTC_IDE_BASE+$0E        ;Control A
   382             0000FE6F   RTC_CONTROL_B   .EQU    RTC_IDE_BASE+$0F        ;Control B
   383             0000FE70   RTC_RAM_ADDR    .EQU    RTC_IDE_BASE+$10        ;Extended RAM address
   384             0000FE73   RTC_RAM_DATA    .EQU    RTC_IDE_BASE+$13        ;Extended RAM data
   385                        ;
   386                        ; Adding BIOS definitions for 16-bit IDE interface
   387                        ; uses two addresses for Upper Byte Latch read / write
   388                        ; uses eight addresses for Command Block Registers
   389                        ; uses two addresses for Control Block Registers
   390                        ;
   391             0000FE74   IDE_16_READ     .EQU    RTC_IDE_BASE+$14        ;Upper byte Read address
   392             0000FE75   IDE_16_WRITE    .EQU    RTC_IDE_BASE+$15        ;Upper byte Write address
   393                        ;
   394                        ; Adding BIOS definitions for IDE Controller (HARD DISK, Flash Module, etc.)
   395                        ; Hardware Adapter provides a 16-bit IDE Port per:
   396                        ;  Seagate ATA Interface Reference Manual 36111-001, Rev. C (21st May 1993)
   397                        ;
   398                        ; Control Block Registers
   399             0000FE76   IDE_ALT_STATUS  .EQU    RTC_IDE_BASE+$16        ;Alternate Status Register (READ)
   400             0000FE76   IDE_DEV_CTRL    .EQU    RTC_IDE_BASE+$16        ;Device Control Register (WRITE)
   401             0000FE77   IDE_DRV_ADDR    .EQU    RTC_IDE_BASE+$17        ;Drive Address Register (READ)
   402                        ;
   403                        ; Command Block Registers
   404             0000FE78   IDE_DATA        .EQU    RTC_IDE_BASE+$18        ;Data Register (R/W)
   405             0000FE79   IDE_ERROR       .EQU    RTC_IDE_BASE+$19        ;Error Register (READ)
   406             0000FE79   IDE_FEATURE     .EQU    RTC_IDE_BASE+$19        ;Feature Register (WRITE)
   407             0000FE7A   IDE_SCT_CNT     .EQU    RTC_IDE_BASE+$1A        ;Sector Count Register
   408             0000FE7B   IDE_SCT_NUM     .EQU    RTC_IDE_BASE+$1B        ;Sector Number Register
   409             0000FE7C   IDE_CYL_LOW     .EQU    RTC_IDE_BASE+$1C        ;Cylinder Low Register
   410             0000FE7D   IDE_CYL_HIGH    .EQU    RTC_IDE_BASE+$1D        ;Cylinder High Register
   411             0000FE7E   IDE_DRV_HEAD    .EQU    RTC_IDE_BASE+$1E        ;Drive/Head Register
   412             0000FE7F   IDE_STATUS      .EQU    RTC_IDE_BASE+$1F        ;Status Register (READ)
   413             0000FE7F   IDE_COMMAND     .EQU    RTC_IDE_BASE+$1F        ;Command Register (WRITE)
   414                        ;
   415                        ;**************************************************************************************************
   416                                .END
    66                        ;
    67                        ;**************************************************************************************************
    68                        ;
    69                        ; Note: No code changes, just updated version and date to mimic the recent BIOS changes/updates.
    70                        ;
    71                        ; The Assembler is not yet implemented.... but there is some initial development code included.
    72                        ; - this does some pre-processing and then JUMPs to $0800 to the current development code.
    73                        ; - Needless to say, don't get excited thinking it works... sorry ;-)
    74                        ;
    75                        ; Note: The hardware configuration has been changed to increase the available RAM in the system!
    76                        ;       This change (PLD reconfig) results in 56KB of RAM and reduced EEPROM to 8KB. This is done
    77                        ;       to provide a larger TEA for the bootable RAM version of DOS/65. This change results in the
    78                        ;       code to write to the EEPROM insitu no longer working. This is due to the unlock sequence
    79                        ;       needed, as it requires a minimum of 22KB addressable memory space. For now, any EEPROM
    80                        ;       changes required must be done by using a programmer.
    81                        ;**************************************************************************************************
    82                        ;The following 32 functions are provided by BIOS via the JMP Table below
  Thu Mar 16 2023 11:46                                                                                                    Page 9


    83                        ; $FF48 is Reserved for future expansion (1 available)
    84                        ;
    85                        ; $FF00 IDE_RES_DIAG    ;Reset IDE and Run Diagnostics
    86                        ; $FF03 IDE_GET_STATUS  ;Get IDE Status and Extended Error codes
    87                        ; $FF06 IDE_IDENTIFY    ;Get IDE Identification Block
    88                        ; $FF09 IDE_READ_LBA    ;Read a Block from IDE device
    89                        ; $FF0C IDE_WRITE_LBA   ;Write a Block to IDE device
    90                        ; $FF0F IDE_VERIFY_LBA  ;Verify the last Block from IDE device
    91                        ; $FF12 IDE_SET_LBA     ;Set the LBA Block ID for Read/Write/Verify
    92                        ; $FF15 IDE_SET_ADDRESS ;Set the Memory Address to transfer Block data to/from
    93                        ; $FF18 IDE_EN_CACHE    ;Enable the Write Cache on IDE controller
    94                        ; $FF1B IDE_DIS_CACHE   ;Disable the Write Cache on IDE controller
    95                        ;
    96                        ; $FF1E RTC_NVRD        ;Read the NVRAM from the RTC
    97                        ; $FF21 RTC_NVWR        ;Write the NVRAM to the RTC
    98                        ; $FF24 RTC_INIT        ;Initialize the Software RTC from the hardware RTC
    99                        ;
   100                        ; $FF27 CHRIN2          ;Data input from serial port (Port B)
   101                        ; $FF2A CHROUT2         ;Data output to serial port (Port B)
   102                        ;
   103                        ; $FF2D CNT_INIT        ;Reset counters and Start Benchmark Counter
   104                        ; $FF30 CNT_STRT        ;Start Benchmark Counter
   105                        ; $FF33 CNT_STOP        ;Stop Benchmark Counter
   106                        ;
   107                        ; $FF36 CHRIN_NW        ;Data input from console, no waiting, clear carry if none
   108                        ; $FF39 CHRIN           ;Data input from console, carry set if data
   109                        ; $FF3C CHROUT          ;Data output to console, sent data preserved
   110                        ;
   111                        ; $FF3F SET_DLY         ;Set delay value for milliseconds and 16-bit counter
   112                        ; $FF42 EXE_MSDLY       ;Execute millisecond delay 1-256 * 10 milliseconds
   113                        ; $FF45 EXE_LGDLY       ;Execute long delay; millisecond delay * 16-bit count
   114                        ;
   115                        ; $FF48 Reserved        ;Reserved BIOS call for future expansion
   116                        ;
   117                        ; $FF4B INIT_VEC        ;Initialize soft vectors at $0300 from ROM
   118                        ; $FF4E INIT_CFG        ;Initialize soft config values at $0320 from ROM
   119                        ; $FF51 INIT_28L92      ;Initialize SC28L92 console 115.2K, 8-N-1 RTS/CTS
   120                        ; $FF54 RESET_28L92     ;Reset SC28L92 - called before INIT_28L92
   121                        ;
   122                        ; $FF57 MON_WARM        ;Monitor warm start - jumps to page $03
   123                        ; $FF5A MON_COLD        ;Monitor cold start - jumps to page $03
   124                        ; $FF5D COLDSTRT        ;System cold start - RESET vector for 65C02
   125                        ;
   126                        ;**************************************************************************************************
   127                        ;BIOS JUMP Table starts here:
   128                        ;       - BIOS calls are listed below - total of 32
   129                        ;       - Reserved calls are for future hardware support
   130                        ;
   131             0000FF00   B_IDE_RESET             .EQU    $FF00   ;Call 00
   132             0000FF03   B_IDE_GET_STAT          .EQU    $FF03   ;Call 01
   133             0000FF06   B_IDE_IDENTIFY          .EQU    $FF06   ;Call 02
   134             0000FF09   B_IDE_READ_LBA          .EQU    $FF09   ;Call 03
   135             0000FF0C   B_IDE_WRITE_LBA         .EQU    $FF0C   ;Call 04
   136             0000FF0F   B_IDE_VERFY_LBA         .EQU    $FF0F   ;Call 05
   137             0000FF12   B_IDE_SET_LBA           .EQU    $FF12   ;Call 06
   138             0000FF15   B_IDE_SET_ADDR          .EQU    $FF15   ;Call 07
   139             0000FF18   B_IDE_EN_CACHE          .EQU    $FF18   ;Call 08
   140             0000FF1B   B_IDE_DIS_CACHE         .EQU    $FF1B   ;Call 09
   141                        ;
   142             0000FF1E   B_RTC_NVRD              .EQU    $FF1E   ;Call 10
   143             0000FF21   B_RTC_NVWR              .EQU    $FF21   ;Call 11
   144             0000FF24   B_RTC_INIT              .EQU    $FF24   ;Call 12
   145                        ;
  Thu Mar 16 2023 11:46                                                                                                    Page 10


   146             0000FF27   B_CHRIN2                .EQU    $FF27   ;Call 13
   147             0000FF2A   B_CHROUT2               .EQU    $FF2A   ;Call 14
   148                        ;
   149             0000FF2D   B_CNT_INIT              .EQU    $FF2D   ;Call 15
   150             0000FF30   B_CNT_STRT              .EQU    $FF30   ;Call 16
   151             0000FF33   B_CNT_STOP              .EQU    $FF33   ;Call 17
   152                        ;
   153             0000FF36   B_CHRIN_NW              .EQU    $FF36   ;Call 18
   154             0000FF39   B_CHRIN                 .EQU    $FF39   ;Call 19
   155             0000FF3C   B_CHROUT                .EQU    $FF3C   ;Call 20
   156                        ;
   157             0000FF3F   B_SET_DLY               .EQU    $FF3F   ;Call 21
   158             0000FF42   B_EXE_MSDLY             .EQU    $FF42   ;Call 22
   159             0000FF45   B_EXE_LGDLY             .EQU    $FF45   ;Call 23
   160                        ;
   161             0000FF48   B_RESERVE               .EQU    $FF48   ;Call 24
   162                        ;
   163             0000FF4B   B_INIT_VEC              .EQU    $FF4B   ;Call 25
   164             0000FF4E   B_INIT_CFG              .EQU    $FF4E   ;Call 26
   165             0000FF51   B_INIT_28L92            .EQU    $FF51   ;Call 27
   166             0000FF54   B_RESET_28L92           .EQU    $FF54   ;Call 28
   167                        ;
   168             0000FF57   B_WRMMNVEC0             .EQU    $FF57   ;Call 29
   169             0000FF5A   B_CLDMNVEC0             .EQU    $FF5A   ;Call 30
   170             0000FF5D   B_COLDSTRT              .EQU    $FF5D   ;Call 31
   171                        ;
   172             0000FFD0   BIOS_MSG                .EQU    $FFD0   ;BIOS Startup Message is hard-coded here
   173                        ;**************************************************************************************************
   174                                .ORG $E000                      ;6KB reserved for Monitor ($E000 through $F7FF)
   175                        ;**************************************************************************************************
   176                        ;Monitor JUMP Table starts here:
   177                        ;       - Monitor calls are listed below - total of 32
   178                        ;       - Reserved calls are for future Monitor functions
   179                        ;
   180 00:E000: 4C 60 E0     M_COLD_MON      JMP     COLD_MON        ;Call 00 $E000
   181 00:E003: 4C 6A E0     M_WARM_MON      JMP     WARM_MON        ;Call 01 $E003
   182                        ;
   183 00:E006: 4C A9 E0     M_RESERVE2      JMP     RESERVED        ;Call 02 $E006
   184                        ;
   185 00:E009: 4C 94 E3     M_MOVE_RAM      JMP     MOVER+3         ;Call 03 $E009
   186 00:E00C: 4C EF E2     M_FILL_LP       JMP     FILL_LP         ;Call 04 $E00C
   187 00:E00F: 4C DC E1     M_BSOUT         JMP     BSOUT           ;Call 05 $E00F
   188 00:E012: 4C 1D EB     M_XMDM_SAVE     JMP     XMDM_SAVE       ;Call 06 $E012
   189 00:E015: 4C 4B E9     M_XMDM_LOAD     JMP     XMDM_LOAD       ;Call 07 $E015
   190 00:E018: 4C 76 E2     M_BENCH         JMP     BENCH           ;Call 08 $E018
   191 00:E01B: 4C 81 E2     M_QUITB         JMP     QUITB           ;Call 09 $E01B
   192 00:E01E: 4C CC E8     M_TIME          JMP     TIME            ;Call 10 $E01E
   193 00:E021: 4C 2B E6     M_PRSTAT1       JMP     PRSTAT1         ;Call 11 $E021
   194 00:E024: 4C 09 E7     M_DIS_LINE      JMP     DIS_LINE        ;Call 12 $E024
   195 00:E027: 4C D0 E1     M_INCINDEX      JMP     INCINDEX        ;Call 13 $E027
   196 00:E02A: 4C C7 E1     M_DECINDEX      JMP     DECINDEX        ;Call 14 $E02A
   197 00:E02D: 4C 64 E1     M_RDLINE        JMP     RDLINE          ;Call 15 $E02D
   198 00:E030: 4C A8 E1     M_RDCHAR        JMP     RDCHAR          ;Call 16 $E030
   199 00:E033: 4C 34 E1     M_HEXIN2        JMP     HEXIN2          ;Call 17 $E033
   200 00:E036: 4C 27 E1     M_HEXIN4        JMP     HEXIN4          ;Call 18 $E036
   201 00:E039: 4C D5 E0     M_HEX2ASC       JMP     HEX2ASC         ;Call 19 $E039
   202 00:E03C: 4C AA E0     M_BIN2ASC       JMP     BIN2ASC         ;Call 20 $E03C
   203 00:E03F: 4C 93 E0     M_ASC2BIN       JMP     ASC2BIN         ;Call 21 $E03F
   204 00:E042: 4C D7 E1     M_BEEP          JMP     BEEP            ;Call 22 $E042
   205 00:E045: 4C FA E1     M_DOLLAR        JMP     DOLLAR          ;Call 23 $E045
   206 00:E048: 4C 02 E2     M_CROUT         JMP     CROUT           ;Call 24 $E048
   207 00:E04B: 4C F5 E1     M_SPC           JMP     SPC             ;Call 25 $E04B
   208 00:E04E: 4C 27 E2     M_PRBYTE        JMP     PRBYTE          ;Call 26 $E04E
  Thu Mar 16 2023 11:46                                                                                                    Page 11


   209 00:E051: 4C 3D E2     M_PRWORD        JMP     PRWORD          ;Call 27 $E051
   210 00:E054: 4C 1A E2     M_PRASC         JMP     PRASC           ;Call 28 $E054
   211 00:E057: 4C 01 E1     M_PROMPT        JMP     PROMPT          ;Call 29 $E057
   212 00:E05A: 4C 09 E1     M_PROMPTR       JMP     PROMPTR         ;Call 30 $E05A
   213 00:E05D: 4C 47 E2     M_CONTINUE      JMP     CONTINUE        ;Call 31 $E05D
   214                        ;
   215                        ;START OF MONITOR CODE
   216                        ;**************************************************************************************************
   217                        ;*                      This is the Monitor Cold start vector                                     *
   218                        ;**************************************************************************************************
   219 00:E060: A9 15        COLD_MON        LDA     #$15            ;Get version msg
   220 00:E062: 20 01 E1                     JSR     PROMPT          ;Send to Console
   221 00:E065: A9 14                        LDA     #$14            ;Get intro msg / BEEP
   222 00:E067: 20 01 E1                     JSR     PROMPT          ;Send to Console
   223                        ;
   224                        ;**************************************************************************************************
   225                        ;*                              Command input loop                                                *
   226                        ;**************************************************************************************************
   227                        ;*                      This is the Monitor Warm start vector                                     *
   228                        ;**************************************************************************************************
   229 00:E06A: A2 FF        WARM_MON        LDX     #$FF            ;Initialize Stack pointer
   230 00:E06C: 9A                           TXS                     ;Xfer to stack
   231 00:E06D: 77 C5                        RMB7    CMDFLAG         ;Clear bit7 of command flag
   232 00:E06F: A9 16                        LDA     #$16            ;Get prompt msg
   233 00:E071: 20 01 E1                     JSR     PROMPT          ;Send to terminal
   234                        ;
   235 00:E074: 20 A8 E1     CMON            JSR     RDCHAR          ;Wait for keystroke (converts to upper-case)
   236 00:E077: A2 21                        LDX     #MONTAB-MONCMD-1        ;Get command list count
   237 00:E079: DD 05 EC     CMD_LP          CMP     MONCMD,X        ;Compare to command list
   238 00:E07C: D0 0D                        BNE     CMD_DEC         ;Check for next command and loop
   239 00:E07E: 48                           PHA                     ;Save keystroke
   240 00:E07F: 8A                           TXA                     ;Xfer Command index to A Reg
   241 00:E080: 0A                           ASL     A               ;Multiply keystroke value by 2 (command offset)
   242 00:E081: AA                           TAX                     ;Xfer Command offset address to table MONTAB
   243 00:E082: 68                           PLA                     ;Restore keystroke (some commands send to terminal)
   244 00:E083: 20 88 E0                     JSR     DOCMD           ;Call Monitor command processor as a subroutine
   245 00:E086: 80 E2                        BRA     WARM_MON        ;Command processed, branch / wait for next command
   246 00:E088: 7C 27 EC     DOCMD           JMP     (MONTAB,X)      ;Execute command from Table
   247                        ;
   248 00:E08B: CA           CMD_DEC         DEX                     ;Decrement index count
   249 00:E08C: 10 EB                        BPL     CMD_LP          ;If more to check, loop back
   250 00:E08E: 20 D7 E1                     JSR     BEEP            ;Beep for error, not valid command character
   251 00:E091: 80 E1                        BRA     CMON            ;Branch back and re-enter Monitor
   252                        ;
   253                        ;**************************************************************************************************
   254                        ;*                      Basic Subroutines used by multiple routines                               *
   255                        ;**************************************************************************************************
   256                        ;
   257                        ;ASC2BIN subroutine: Convert 2 ASCII HEX digits to a binary (byte) value
   258                        ; Enter: A Register = high digit, Y Register = low digit
   259                        ; Return: A Register = binary value
   260                        ; Updated routine via Mike Barry... saves 3 bytes, 10 clock cycles
   261 00:E093: 64 C2        ASC2BIN         STZ     TEMP1           ;Clear TEMP1
   262 00:E095: 20 9F E0                     JSR     BINARY          ;Convert high digit to 4-bit nibble
   263 00:E098: 0A                           ASL     A               ;Shift to high nibble
   264 00:E099: 0A                           ASL     A
   265 00:E09A: 0A                           ASL     A
   266 00:E09B: 0A                           ASL     A
   267 00:E09C: 85 C2                        STA     TEMP1           ;Store it in temp area
   268 00:E09E: 98                           TYA                     ;Get Low digit
   269                        ;
   270 00:E09F: 49 30        BINARY          EOR     #$30            ;ASCII -> HEX nibble
   271 00:E0A1: C9 0A                        CMP     #$0A            ;Check for result < 10
  Thu Mar 16 2023 11:46                                                                                                    Page 12


   272 00:E0A3: 90 02                        BCC     BNOK            ;Branch if 0-9
   273 00:E0A5: E9 67                        SBC     #$67            ;Else subtract for A-F
   274 00:E0A7: 05 C2        BNOK            ORA     TEMP1           ;OR into temp value
   275 00:E0A9: 60           RESERVED        RTS                     ;Return to caller
   276                        ;
   277                        ;BIN2ASC subroutine: Convert single byte to two ASCII HEX digits
   278                        ; Enter: A Register contains byte value to convert
   279                        ; Return: A Register = high digit, Y Register = low digit
   280 00:E0AA: 48           BIN2ASC         PHA                     ;Save A Reg on stack
   281 00:E0AB: 29 0F                        AND     #$0F            ;Mask off high nibble
   282 00:E0AD: 20 B6 E0                     JSR     ASCII           ;Convert nibble to ASCII HEX digit
   283 00:E0B0: A8                           TAY                     ;Move to Y Reg
   284 00:E0B1: 68                           PLA                     ;Get character back from stack
   285 00:E0B2: 4A                           LSR     A               ;Shift high nibble to lower 4 bits
   286 00:E0B3: 4A                           LSR     A
   287 00:E0B4: 4A                           LSR     A
   288 00:E0B5: 4A                           LSR     A
   289                        ;
   290 00:E0B6: C9 0A        ASCII           CMP     #$0A            ;Check for 10 or less
   291 00:E0B8: 90 02                        BCC     ASCOK           ;Branch if less than 10
   292 00:E0BA: 69 06                        ADC     #$06            ;Add $06+CF ($07) for A-F
   293 00:E0BC: 69 30        ASCOK           ADC     #$30            ;Add $30 for ASCII
   294 00:E0BE: 60                           RTS                     ;Return to caller
   295                        ;
   296                        ;HEX8ASC - Accepts 8-bit Hexadecimal value (00-99 decimal) and converts to ASCII numeric values.
   297                        ; A Register contains the single byte value on entry and outputs the two ASCII numeric values.
   298                        ; leading zero is output as it is used for showing hundredths of a second after a decimal point.
   299 00:E0BF: A0 FF        HEX8ASC         LDY     #$FF            ;Load Y Reg with "-1"
   300 00:E0C1: 38                           SEC                     ;Set carry for subtraction
   301 00:E0C2: C8           HEX8LP1         INY                     ;Increment 10's count (starts at zero)
   302 00:E0C3: E9 0A                        SBC     #10             ;Subtract 10 decimal
   303 00:E0C5: B0 FB                        BCS     HEX8LP1         ;Branch back if >10
   304 00:E0C7: 69 3A                        ADC     #$3A            ;Add the last 10 back plus $30 (ASCII "0")
   305 00:E0C9: 48                           PHA                     ;Save 1's count to the Stack
   306 00:E0CA: 98                           TYA                     ;Get the 10's count
   307 00:E0CB: 18                           CLC                     ;Clear carry for add
   308 00:E0CC: 69 30                        ADC     #$30            ;Add $30 for ASCII digit
   309 00:E0CE: 20 3C FF                     JSR     B_CHROUT        ;Print the first digit (10's)
   310 00:E0D1: 68                           PLA                     ;Get 1's count from the Stack
   311 00:E0D2: 4C 3C FF                     JMP     B_CHROUT        ;Print the second digit, return
   312                        ;
   313                        ;HEX2ASC - Accepts 16-bit Hexadecimal value and converts to an ASCII decimal string. Input is
   314                        ; via the A and Y Registers and output is up to 5 ASCII digits in DATABUFF. The High Byte is in
   315                        ; the Y Register and Low Byte is in the A Register. Output data is placed in variable DATABUFF
   316                        ; and terminated with a null character.
   317                        ; Note: leading zeros are suppressed. PROMPTR routine is used to print the ASCII decimal value.
   318                        ; Core routine based on Michael Barry's code. Saves many bytes with two updates/changes ;-)
   319 00:E0D5: 85 AC        HEX2ASC         STA     BINVALL         ;Save Low byte
   320 00:E0D7: 84 AD                        STY     BINVALH         ;Save High byte
   321 00:E0D9: A2 05                        LDX     #5              ;Get ASCII buffer offset
   322 00:E0DB: 74 A4                        STZ     DATABUFF,X      ;Zero last buffer byte for null end
   323                        ;
   324 00:E0DD: A9 00        CNVERT          LDA     #$00            ;Clear remainder
   325 00:E0DF: A0 10                        LDY     #16             ;Set loop count for 16-bits
   326                        ;
   327 00:E0E1: C9 05        DVLOOP          CMP     #$05            ;Partial remainder >= 10/2
   328 00:E0E3: 90 02                        BCC     DVLOOP2         ;Branch if less
   329 00:E0E5: E9 05                        SBC     #$05            ;Update partial (carry set)
   330                        ;
   331 00:E0E7: 26 AC        DVLOOP2         ROL     BINVALL         ;Shift carry into dividend
   332 00:E0E9: 26 AD                        ROL     BINVALH         ;Which will be quotient
   333 00:E0EB: 2A                           ROL     A               ;Rotate A Reg
   334 00:E0EC: 88                           DEY                     ;Decrement count
  Thu Mar 16 2023 11:46                                                                                                    Page 13


   335 00:E0ED: D0 F2                        BNE     DVLOOP          ;Branch back until done
   336 00:E0EF: 09 30                        ORA     #$30            ;OR in $30 for ASCII
   337                        ;
   338 00:E0F1: CA                           DEX                     ;Decrement buffer offset
   339 00:E0F2: 95 A4                        STA     DATABUFF,X      ;Store digit into buffer
   340                        ;
   341 00:E0F4: A5 AC                        LDA     BINVALL         ;Get the Low byte
   342 00:E0F6: 05 AD                        ORA     BINVALH         ;OR in the High byte (check for zero)
   343 00:E0F8: D0 E3                        BNE     CNVERT          ;Branch back until done
   344                        ;
   345                        ;Conversion is complete, get the string address, add offset, then call prompt routine and return
   346                        ; note DATABUFF is fixed location in Page 0, carry flag need not be cleared as result can never
   347                        ; set flag after ADC instruction.
   348 00:E0FA: 8A                           TXA                     ;Get buffer offset
   349 00:E0FB: 69 A4                        ADC     #<DATABUFF      ;Add Low byte address
   350 00:E0FD: A0 00                        LDY     #>DATABUFF      ;Get High byte address
   351 00:E0FF: 80 08                        BRA     PROMPTR         ;Branch to PROMPTR to Print numeric string
   352                        ;
   353                        ;PROMPT routine: Send indexed text string to terminal. Index is contained in A Reg.
   354                        ; String buffer address is stored in variable PROMPTL/PROMPTH.
   355 00:E101: 0A           PROMPT          ASL     A               ;Multiply by two for msg table index
   356 00:E102: AA                           TAX                     ;Xfer to X Reg - index
   357 00:E103: BD 0C F2                     LDA     MSG_TABLE,X     ;Get low byte address
   358 00:E106: BC 0D F2                     LDY     MSG_TABLE+1,X   ;Get high byte address
   359                        ;
   360                        ;PROMPTR routine: takes message address in Y/A and prints via PROMPT2 routine
   361 00:E109: 85 B6        PROMPTR         STA     PROMPTL         ;Store low byte
   362 00:E10B: 84 B7                        STY     PROMPTH         ;Store high byte
   363                        ;
   364                        ;PROMPT2 routine: prints message at address (PROMPTL) till null character found
   365 00:E10D: B2 B6        PROMPT2         LDA     (PROMPTL)       ;Get string data (5)
   366 00:E10F: F0 52                        BEQ     HINEXIT         ;If null character, exit (borrowed RTS) (2/3)
   367 00:E111: 20 3C FF                     JSR     B_CHROUT        ;Send character to terminal (6)
   368 00:E114: E6 B6                        INC     PROMPTL         ;Increment low byte index (5)
   369 00:E116: D0 F5                        BNE     PROMPT2         ;Loop back for next character (2/3)
   370 00:E118: E6 B7                        INC     PROMPTH         ;Increment high byte index (5)
   371 00:E11A: 80 F1                        BRA     PROMPT2         ;Loop back and continue printing (3)
   372                        ;
   373                        ;SETUP subroutine: Request HEX address input from terminal
   374 00:E11C: 20 3C FF     SETUP           JSR     B_CHROUT        ;Send command keystroke to terminal
   375 00:E11F: 20 F5 E1                     JSR     SPC             ;Send [SPACE] to terminal
   376 00:E122: 80 03                        BRA     HEXIN4          ;Request a 0-4 digit HEX address input from terminal
   377                        ;
   378                        ;HEX input subroutines: Request 1 to 4 ASCII HEX digits from terminal, then convert digits into
   379                        ; a binary value. For 1 to 4 digits entered, HEXDATAH and HEXDATAL contain the output.
   380                        ; Variable BUFIDX will contain the number of digits entered
   381                        ; HEXIN2 - returns value in A Reg and Y Reg only (Y Reg always $00)
   382                        ; HEXIN4 - returns values in A Reg, Y Reg and INDEXL/INDEXH
   383                        ; HEX2 - Prints MSG# in A Reg then calls HEXIN2, HEX4 - Prints MSG# in A Reg then calls HEXIN4
   384 00:E124: 20 01 E1     HEX4            JSR     PROMPT          ;Print MSG # from A Reg
   385 00:E127: A2 04        HEXIN4          LDX     #$04            ;Set for number of characters allowed
   386 00:E129: 20 36 E1                     JSR     HEXINPUT        ;Convert digits
   387 00:E12C: 84 B1                        STY     INDEXH          ;Store to INDEXH
   388 00:E12E: 85 B0                        STA     INDEXL          ;Store to INDEXL
   389 00:E130: 60                           RTS                     ;Return to caller
   390                        ;
   391 00:E131: 20 01 E1     HEX2            JSR     PROMPT          ;Print MSG # from A Reg
   392 00:E134: A2 02        HEXIN2          LDX     #$02            ;Set for number of characters allowed
   393                        ;
   394                        ;HEXINPUT subroutine: request 1 to 4 HEX digits from terminal, then convert ASCII HEX to HEX
   395                        ; minor update from Mike Barry, saves a byte.
   396                        ; Setup RDLINE subroutine parameters:
   397 00:E136: 20 FA E1     HEXINPUT        JSR     DOLLAR          ;Send "$" to console
  Thu Mar 16 2023 11:46                                                                                                    Page 14


   398 00:E139: 20 64 E1                     JSR     RDLINE          ;Request ASCII HEX input from terminal
   399 00:E13C: F0 25                        BEQ     HINEXIT         ;Exit if none (Z flag already set)
   400 00:E13E: 64 AA                        STZ     HEXDATAH        ;Clear Upper HEX byte, Lower HEX byte will be updated
   401 00:E140: A0 02                        LDY     #$02            ;Set index for 2 bytes
   402 00:E142: 5A           ASCLOOP         PHY                     ;Save it to stack
   403 00:E143: B5 9F                        LDA     INBUFF-1,X      ;Read ASCII digit from buffer
   404 00:E145: A8                           TAY                     ;Xfer to Y Reg (LSD)
   405 00:E146: CA                           DEX                     ;Decrement input count
   406 00:E147: F0 04                        BEQ     NO_UPNB         ;Branch if no upper nibble
   407 00:E149: B5 9F                        LDA     INBUFF-1,X      ;Read ASCII digit from buffer
   408 00:E14B: 80 02                        BRA     DO_UPNB         ;Branch to include upper nibble
   409 00:E14D: A9 30        NO_UPNB         LDA     #$30            ;Load ASCII "0" (MSD)
   410 00:E14F: 20 93 E0     DO_UPNB         JSR     ASC2BIN         ;Convert ASCII digits to binary value
   411 00:E152: 7A                           PLY                     ;Get index from stack
   412 00:E153: 99 A9 00                     STA     HEXDATAH-1,Y    ;Write byte to indexed buffer location
   413 00:E156: 8A                           TXA                     ;Check for zero, (no digits left)
   414 00:E157: F0 04                        BEQ     HINDONE         ;If not, exit
   415 00:E159: 88                           DEY                     ;Else, decrement to next byte set
   416 00:E15A: CA                           DEX                     ;Decrement index count
   417 00:E15B: D0 E5                        BNE     ASCLOOP         ;Loop back for next byte
   418 00:E15D: A4 AA        HINDONE         LDY     HEXDATAH        ;Get High Byte
   419 00:E15F: A5 AB                        LDA     HEXDATAL        ;Get Low Byte
   420 00:E161: A6 BE                        LDX     BUFIDX          ;Get input count (set Z flag)
   421 00:E163: 60           HINEXIT         RTS                     ;And return to caller
   422                        ;
   423                        ;RDLINE subroutine: Store keystrokes into buffer until [RETURN] key is struck
   424                        ; Used for Hex entry, so only (0-9,A-F) are accepted entries. Lower-case alpha characters
   425                        ; are converted to upper-case. On entry, X Reg = buffer length. On exit, X Reg = buffer count
   426                        ; [BACKSPACE] key removes keystrokes from buffer. [ESCAPE] key aborts then re-enters monitor.
   427 00:E164: 86 BF        RDLINE          STX     BUFLEN          ;Store buffer length
   428 00:E166: 64 BE                        STZ     BUFIDX          ;Zero buffer index
   429 00:E168: 20 A8 E1     RDLOOP          JSR     RDCHAR          ;Get character from terminal, convert LC2UC
   430 00:E16B: C9 1B                        CMP     #$1B            ;Check for ESC key
   431 00:E16D: F0 36                        BEQ     RDNULL          ;If yes, exit back to Monitor
   432 00:E16F: C9 0D        NOTESC          CMP     #$0D            ;Check for C/R
   433 00:E171: F0 2B                        BEQ     EXITRD          ;Exit if yes
   434 00:E173: C9 08                        CMP     #$08            ;Check for Backspace
   435 00:E175: F0 1C                        BEQ     RDBKSP          ;If yes handle backspace
   436 00:E177: C9 30                        CMP     #$30            ;Check for '0' or higher
   437 00:E179: 90 0A                        BCC     INPERR          ;Branch to error if less than '0'
   438 00:E17B: C9 47                        CMP     #$47            ;Check for 'G' ('F'+1)
   439 00:E17D: B0 06                        BCS     INPERR          ;Branch to error if 'G' or higher
   440 00:E17F: A6 BE                        LDX     BUFIDX          ;Get the current buffer index
   441 00:E181: E4 BF                        CPX     BUFLEN          ;Compare to length for space
   442 00:E183: 90 05                        BCC     STRCHR          ;Branch to store in buffer
   443 00:E185: 20 D7 E1     INPERR          JSR     BEEP            ;Else, error, send Bell to terminal
   444 00:E188: 80 DE                        BRA     RDLOOP          ;Branch back to RDLOOP
   445 00:E18A: 95 A0        STRCHR          STA     INBUFF,X        ;Store keystroke in buffer
   446 00:E18C: 20 3C FF                     JSR     B_CHROUT        ;Send keystroke to terminal
   447 00:E18F: E6 BE                        INC     BUFIDX          ;Increment buffer index
   448 00:E191: 80 D5                        BRA     RDLOOP          ;Branch back to RDLOOP
   449 00:E193: A5 BE        RDBKSP          LDA     BUFIDX          ;Check if buffer is empty
   450 00:E195: F0 EE                        BEQ     INPERR          ;Branch if yes
   451 00:E197: C6 BE                        DEC     BUFIDX          ;Else, decrement buffer index
   452 00:E199: 20 DC E1                     JSR     BSOUT           ;Send Backspace to terminal
   453 00:E19C: 80 CA                        BRA     RDLOOP          ;Loop back and continue
   454 00:E19E: A6 BE        EXITRD          LDX     BUFIDX          ;Get keystroke count (Z flag)
   455 00:E1A0: D0 0F                        BNE     UCOK            ;If data entered, normal exit
   456 00:E1A2: FF C5 0C                     BBS7    CMDFLAG,UCOK    ;Branch if bit7 of command flag active
   457 00:E1A5: 6C 0E 03     RDNULL          JMP     (WRMMNVEC0)     ;Quit to Monitor warm start
   458                        ;
   459                        ;RDCHAR subroutine: Waits for a keystroke to be entered.
   460                        ; if keystroke is a lower-case alphabetical, convert it to upper-case
  Thu Mar 16 2023 11:46                                                                                                    Page 15


   461 00:E1A8: 20 39 FF     RDCHAR          JSR     B_CHRIN         ;Request keystroke input from terminal
   462 00:E1AB: C9 61                        CMP     #$61            ;Check for lower case value range
   463 00:E1AD: 90 02                        BCC     UCOK            ;Branch if < $61, control code/upper-case/numeric
   464 00:E1AF: E9 20                        SBC     #$20            ;Subtract $20 to convert to upper case
   465 00:E1B1: 60           UCOK            RTS                     ;Character received, return to caller
   466                        ;
   467                        ;Routines to update pointers for memory operations. UPD_STL subroutine: Increments Source
   468                        ; and Target pointers. UPD_TL subroutine: Increments Target pointers only, then drops into
   469                        ; decrement Length pointer. Used by multiple Memory operation commands.
   470 00:E1B2: E6 B8        UPD_STL         INC     SRCL            ;Increment source low byte
   471 00:E1B4: D0 02                        BNE     UPD_TL          ;Check for rollover
   472 00:E1B6: E6 B9                        INC     SRCH            ;Increment source high byte
   473 00:E1B8: E6 BA        UPD_TL          INC     TGTL            ;Increment target low byte
   474 00:E1BA: D0 02                        BNE     DECLEN          ;Check for rollover
   475 00:E1BC: E6 BB                        INC     TGTH            ;Increment target high byte
   476                        ;
   477                        ;DECLEN subroutine: decrement 16-bit variable LENL/LENH
   478 00:E1BE: A5 BC        DECLEN          LDA     LENL            ;Get length low byte
   479 00:E1C0: D0 02                        BNE     SKP_LENH        ;Test for LENL = zero
   480 00:E1C2: C6 BD                        DEC     LENH            ;Else decrement length high byte
   481 00:E1C4: C6 BC        SKP_LENH        DEC     LENL            ;Decrement length low byte
   482 00:E1C6: 60                           RTS                     ;Return to caller
   483                        ;
   484                        ;DECINDEX subroutine: decrement 16 bit variable INDEXL/INDEXH
   485 00:E1C7: A5 B0        DECINDEX        LDA     INDEXL          ;Get index low byte
   486 00:E1C9: D0 02                        BNE     SKP_IDXH        ;Test for INDEXL = zero
   487 00:E1CB: C6 B1                        DEC     INDEXH          ;Decrement index high byte
   488 00:E1CD: C6 B0        SKP_IDXH        DEC     INDEXL          ;Decrement index low byte
   489 00:E1CF: 60                           RTS                     ;Return to caller
   490                        ;
   491                        ;INCINDEX subroutine: increment 16 bit variable INDEXL/INDEXH
   492 00:E1D0: E6 B0        INCINDEX        INC     INDEXL          ;Increment index low byte
   493 00:E1D2: D0 02                        BNE     SKP_IDX         ;If not zero, skip high byte
   494 00:E1D4: E6 B1                        INC     INDEXH          ;Increment index high byte
   495 00:E1D6: 60           SKP_IDX         RTS                     ;Return to caller
   496                        ;
   497                        ;Output routines for formatting, backspace, CR/LF, BEEP, etc.
   498                        ; all routines preserve the A Reg on exit.
   499                        ;
   500                        ;BEEP subroutine: Send ASCII [BELL] to terminal
   501 00:E1D7: 48           BEEP            PHA                     ;Save A Reg on Stack
   502 00:E1D8: A9 07                        LDA     #$07            ;Get ASCII [BELL] to terminal
   503 00:E1DA: 80 2E                        BRA     SENDIT          ;Branch to send
   504                        ;
   505                        ;BSOUT subroutine: send a Backspace to terminal
   506 00:E1DC: 20 E2 E1     BSOUT           JSR     BSOUT2          ;Send an ASCII backspace
   507 00:E1DF: 20 F5 E1                     JSR     SPC             ;Send space to clear out character
   508 00:E1E2: 48           BSOUT2          PHA                     ;Save character in A Reg
   509 00:E1E3: A9 08                        LDA     #$08            ;Send another Backspace to return
   510 00:E1E5: 80 23        BRCHOUT         BRA     SENDIT          ;Branch to send
   511                        ;
   512 00:E1E7: 20 E2 E1     BSOUT3T         JSR     BSOUT2          ;Send a Backspace 3 times
   513 00:E1EA: 20 E2 E1     BSOUT2T         JSR     BSOUT2          ;Send a Backspace 2 times
   514 00:E1ED: 80 F3                        BRA     BSOUT2          ;Send a Backspace and return
   515                        ;
   516                        ;SPC subroutines: Send a Space to terminal 1,2 or 4 times
   517 00:E1EF: 20 F2 E1     SPC4            JSR     SPC2            ;Send 4 Spaces to terminal
   518 00:E1F2: 20 F5 E1     SPC2            JSR     SPC             ;Send 2 Spaces to terminal
   519 00:E1F5: 48           SPC             PHA                     ;Save character in A Reg
   520 00:E1F6: A9 20                        LDA     #$20            ;Get ASCII Space
   521 00:E1F8: 80 10                        BRA     SENDIT          ;Branch to send
   522                        ;
   523                        ;DOLLAR subroutine: Send "$" to terminal
  Thu Mar 16 2023 11:46                                                                                                    Page 16


   524 00:E1FA: 48           DOLLAR          PHA                     ;Save A Reg on STACK
   525 00:E1FB: A9 24                        LDA     #$24            ;Get ASCII "$"
   526 00:E1FD: 80 0B                        BRA     SENDIT          ;Branch to send
   527                        ;
   528                        ;Send 2 CR/LFs to terminal
   529 00:E1FF: 20 02 E2     CR2             JSR     CROUT           ;Send CR/LF to terminal
   530                        ;Send CR/LF to terminal
   531 00:E202: 48           CROUT           PHA                     ;Save A Reg
   532 00:E203: A9 0D                        LDA     #$0D            ;Get ASCII Return
   533 00:E205: 20 3C FF                     JSR     B_CHROUT        ;Send to terminal
   534 00:E208: A9 0A                        LDA     #$0A            ;Get ASCII Linefeed
   535 00:E20A: 20 3C FF     SENDIT          JSR     B_CHROUT        ;Send to terminal
   536 00:E20D: 68                           PLA                     ;Restore A Reg
   537 00:E20E: 60                           RTS                     ;Return to caller
   538                        ;
   539                        ;GLINE subroutine: Send a horizontal line to console used by memory display only.
   540 00:E20F: A2 4F        GLINE           LDX     #$4F            ;Load index for 79 decimal
   541 00:E211: A9 7E                        LDA     #$7E            ;Get "~" character
   542 00:E213: 20 3C FF     GLINEL          JSR     B_CHROUT        ;Send to terminal (draw a line)
   543 00:E216: CA                           DEX                     ;Decrement count
   544 00:E217: D0 FA                        BNE     GLINEL          ;Branch back until done
   545 00:E219: 60                           RTS                     ;Return to caller
   546                        ;
   547                        ;Routines to output 8/16-bit Binary Data and ASCII characters
   548                        ; PRASC subroutine: Print A-Reg as ASCII (Printable ASCII values = $20 - $7E), else print "."
   549 00:E21A: C9 7F        PRASC           CMP     #$7F            ;Check for first 128
   550 00:E21C: B0 04                        BCS     PERIOD          ;If = or higher, branch
   551 00:E21E: C9 20                        CMP     #$20            ;Check for control characters
   552 00:E220: B0 02                        BCS     ASCOUT          ;If space or higher, branch and print
   553 00:E222: A9 2E        PERIOD          LDA     #$2E            ;Else, print a "."
   554 00:E224: 4C 3C FF     ASCOUT          JMP     B_CHROUT        ;Send byte in A-Reg, then return
   555                        ;
   556                        ;PRBYTE subroutine: Converts a single Byte to 2 HEX ASCII characters and sends to console on
   557                        ; entry, A Reg contains the Byte to convert/send. Register contents are preserved on entry/exit.
   558 00:E227: 48           PRBYTE          PHA                     ;Save A Register
   559 00:E228: 5A                           PHY                     ;Save Y Register
   560 00:E229: 20 AA E0     PRBYT2          JSR     BIN2ASC         ;Convert A Reg to 2 ASCII Hex characters
   561 00:E22C: 20 3C FF                     JSR     B_CHROUT        ;Print high nibble from A Reg
   562 00:E22F: 98                           TYA                     ;Transfer low nibble to A Reg
   563 00:E230: 20 3C FF                     JSR     B_CHROUT        ;Print low nibble from A Reg
   564 00:E233: 7A                           PLY                     ;Restore Y Register
   565 00:E234: 68                           PLA                     ;Restore A Register
   566 00:E235: 60                           RTS                     ;Return to caller
   567                        ;
   568                        ;PRINDEX subroutine: Prints a $ sign followed by INDEXH/L
   569 00:E236: 20 FA E1     PRINDEX         JSR     DOLLAR          ;Print a $ sign
   570 00:E239: A5 B0                        LDA     INDEXL          ;Get Index Low byte
   571 00:E23B: A4 B1                        LDY     INDEXH          ;Get Index High byte
   572                        ;
   573                        ;PRWORD subroutine: Converts a 16-bit word to 4 HEX ASCII characters and sends to console. On
   574                        ; entry, A Reg contains Low Byte, Y Reg contains High Byte. Registers are preserved on entry/exit.
   575                        ; NOTE: Routine changed for consistency; A Reg = Low byte, Y Reg = High byte on 2nd May 2020
   576 00:E23D: 48           PRWORD          PHA                     ;Save A Register (Low)
   577 00:E23E: 5A                           PHY                     ;Save Y Register (High)
   578 00:E23F: 48                           PHA                     ;Save Low byte again
   579 00:E240: 98                           TYA                     ;Xfer High byte to A Reg
   580 00:E241: 20 27 E2                     JSR     PRBYTE          ;Convert and print one HEX character (00-FF)
   581 00:E244: 68                           PLA                     ;Get Low byte value
   582 00:E245: 80 E2                        BRA     PRBYT2          ;Finish up Low Byte and exit
   583                        ;
   584                        ;Continue routine: called by commands to confirm execution, when No is confirmed, return address
   585                        ;is removed from stack and the exit goes back to the Monitor input loop.
   586                        ;Short version prompts for (Y/N) only.
  Thu Mar 16 2023 11:46                                                                                                    Page 17


   587 00:E247: A9 00        CONTINUE        LDA     #$00            ;Get msg "cont? (Y/N)" to terminal
   588 00:E249: 80 02                        BRA     SH_CONT         ;Branch down
   589 00:E24B: A9 01        CONTINUE2       LDA     #$01            ;Get short msg "(Y/N)" only
   590 00:E24D: 20 01 E1     SH_CONT         JSR     PROMPT          ;Send to terminal
   591 00:E250: 20 A8 E1     TRY_AGN         JSR     RDCHAR          ;Get keystroke from terminal
   592 00:E253: C9 59                        CMP     #$59            ;"Y" key?
   593 00:E255: F0 0D                        BEQ     DOCONT          ;If yes, continue/exit
   594 00:E257: C9 4E                        CMP     #$4E            ;If "N", quit/exit
   595 00:E259: F0 05                        BEQ     DONTCNT         ;Return if not ESC
   596 00:E25B: 20 D7 E1                     JSR     BEEP            ;Send Beep to console
   597 00:E25E: 80 F0                        BRA     TRY_AGN         ;Loop back, try again
   598 00:E260: 68           DONTCNT         PLA                     ;Else remove return address
   599 00:E261: 68                           PLA                     ;and discard it
   600 00:E262: 64 C5                        STZ     CMDFLAG         ;Clear all bits in command flag
   601 00:E264: 60           DOCONT          RTS                     ;Return
   602                        ;
   603                        ;**************************************************************************************************
   604                        ;*                              Monitor Command Processors                                        *
   605                        ;**************************************************************************************************
   606                        ;
   607                        ;**************************************************************************************************
   608                        ;*                              Timer/Counter based Monitor functions                             *
   609                        ;**************************************************************************************************
   610                        ;
   611                        ;[,] Delay Setup Routine: This routine gets hex input via the console
   612                        ;  - first is a hex byte ($00-$FF) for the 10-millisecond count
   613                        ;  - second is a hex word ($0000-$FFFF) for the delay multiplier
   614                        ;  - these are stored in variables SETMS, DELLO/DELHI
   615 00:E265: A9 17        SET_DELAY       LDA     #$17            ;Get millisecond delay message
   616 00:E267: 20 31 E1                     JSR     HEX2            ;Use short cut version for print and input
   617 00:E26A: 85 ED                        STA     SETMS           ;Else store millisecond count in variable
   618 00:E26C: A9 18        GETMULT         LDA     #$18            ;Get Multiplier message
   619 00:E26E: 20 24 E1                     JSR     HEX4            ;Use short cut version for print and input
   620 00:E271: 85 EE                        STA     DELLO           ;Store Low byte
   621 00:E273: 84 EF                        STY     DELHI           ;Store High byte
   622 00:E275: 60                           RTS                     ;Return to caller
   623                        ;
   624                        ;[B] Benchmark Timer: Starts the benchmark timer.
   625                        ; This routine displays a message to the console. A (y/n) prompt
   626                        ; allows exit if required. Else it calls the BIOS routine at $FF30. This routine will
   627                        ; clear the counters in page zero and enable the benchmark count routine.
   628                        ; NOTE: The Benchmark counter is handled in BIOS and provides a 16-bit count of seconds
   629                        ; along with a jiffy count with 10ms accuracy.
   630                        ;
   631                        ; The companion Q command quits the Benchmark count and displays the elapsed time as
   632                        ; xxxxx.xx seconds.
   633 00:E276: A9 29        BENCH           LDA     #$29            ;Get message for Bench startup
   634 00:E278: 20 01 E1                     JSR     PROMPT          ;Send message to console
   635 00:E27B: 20 4B E2                     JSR     CONTINUE2       ;Prompt user (y/n)
   636 00:E27E: 4C 2D FF                     JMP     B_CNT_INIT      ;Call BIOS routine to Init and start count, return
   637                        ;
   638                        ;[Q] Quit Benchmark timer: Quits the Benchmark timer.
   639                        ; Benchmark timer is stopped by calling the BIOS routine. Once the Benchmark counter is
   640                        ; is stopped, the HEX2ASC routine to print the 16-bit seconds count, followed by a period
   641                        ; and then the HEX8ASC routine prints the hundreds count followed by the "Seconds" message.
   642 00:E281: 20 33 FF     QUITB           JSR     B_CNT_STOP      ;Stop Benchmark counter
   643 00:E284: A5 F1                        LDA     SECL_CNT        ;Get seconds low count
   644 00:E286: A4 F2                        LDY     SECH_CNT        ;Get seconds high count
   645 00:E288: 20 D5 E0                     JSR     HEX2ASC         ;Print ASCII number
   646 00:E28B: 20 22 E2                     JSR     PERIOD          ;Send "." to console
   647 00:E28E: A5 F0                        LDA     MS10_CNT        ;Get hundreds of seconds
   648 00:E290: 20 BF E0                     JSR     HEX8ASC         ;Print hundreds of seconds
   649 00:E293: A9 48                        LDA     #$48            ;Get message for " Seconds"
  Thu Mar 16 2023 11:46                                                                                                    Page 18


   650 00:E295: 20 01 E1                     JSR     PROMPT          ;Send to console
   651 00:E298: 4C 02 E2                     JMP     CROUT           ;Send CR/LF and return
   652                        ;
   653                        ;**************************************************************************************************
   654                        ;*                              Macro functions for testing/looping                               *
   655                        ;**************************************************************************************************
   656                        ;
   657                        ;[(] INIMACRO command: Initialize keystroke input buffer
   658                        ; initializes buffer head/tail pointers and resets buffer count to zero
   659                        ; input buffer appears empty so command macro starts at the head of the buffer
   660 00:E29B: 64 CD        INIMACRO        STZ     LPCNTL          ;Zero Loop count low byte
   661 00:E29D: 64 CE                        STZ     LPCNTH          ;Zero Loop count high byte
   662 00:E29F: 67 C5                        RMB6    CMDFLAG         ;Clear Loop Count flag Bit6
   663                        ;
   664 00:E2A1: A9 20        LP_CNT_FL       LDA     #$20            ;Get Loop Count msg
   665 00:E2A3: 20 01 E1                     JSR     PROMPT          ;Send to console
   666 00:E2A6: A9 01                        LDA     #$01            ;Get short msg "(Y/N)" only
   667 00:E2A8: 20 01 E1                     JSR     PROMPT          ;Send to terminal
   668 00:E2AB: 20 A8 E1                     JSR     RDCHAR          ;Get keystroke from terminal
   669 00:E2AE: C9 59                        CMP     #$59            ;"Y" key?
   670 00:E2B0: F0 09                        BEQ     DOLOOPS         ;If yes, set loop flag
   671 00:E2B2: C9 4E                        CMP     #$4E            ;"N" key?
   672 00:E2B4: F0 07                        BEQ     NOLOOPS         ;If yes, don't set loop flag
   673 00:E2B6: 20 D7 E1                     JSR     BEEP            ;Neither (Y/N) selected, sound bell
   674 00:E2B9: 80 E6                        BRA     LP_CNT_FL       ;Branch back, try again
   675                        ;
   676 00:E2BB: E7 C5        DOLOOPS         SMB6    CMDFLAG         ;Set Loop Count flag Bit6
   677 00:E2BD: 64 D7        NOLOOPS         STZ     ICNT_A          ;Zero Input buffer count
   678 00:E2BF: 64 D9                        STZ     ITAIL_A         ;Zero Input buffer tail pointer
   679 00:E2C1: 64 D8        MACINI          STZ     IHEAD_A         ;Zero Input buffer head pointer
   680 00:E2C3: 60           DONEFILL        RTS                     ;Return to caller
   681                        ;
   682                        ;[)] RUNMACRO command: Run Monitor command macro. This will indicate that there are 128 keystrokes
   683                        ; in the keystroke input buffer. The Monitor will process these as if they were received from the
   684                        ; terminal (typed-in by the user). Because the last keystroke stored in the keystroke buffer was
   685                        ; ")", this will loop continuously. Use [SEND BREAK] to exit Macro
   686 00:E2C4: A9 7F        RUNMACRO        LDA     #$7F            ;Get keystroke buffer max length-1
   687 00:E2C6: 85 D9                        STA     ITAIL_A         ;Push tail pointer to end
   688 00:E2C8: 1A                           INC     A               ;Increment to $80 for buffer count (full)
   689 00:E2C9: 85 D7                        STA     ICNT_A          ;Make count show as full ($80)
   690 00:E2CB: 6F C5 15                     BBR6    CMDFLAG,NOLP_CNT        ;If Loop flag clear, branch around it
   691 00:E2CE: E6 CD                        INC     LPCNTL          ;Increment loops low byte
   692 00:E2D0: D0 02                        BNE     SKP_LPC         ;If not zero, skip high byte
   693 00:E2D2: E6 CE                        INC     LPCNTH          ;Increment loops high byte
   694 00:E2D4: A9 21        SKP_LPC         LDA     #$21            ;Get Loops msg
   695 00:E2D6: 20 01 E1                     JSR     PROMPT          ;Send to console
   696 00:E2D9: A5 CD                        LDA     LPCNTL          ;Get Loop count low
   697 00:E2DB: A4 CE                        LDY     LPCNTH          ;Get Loop count high
   698 00:E2DD: 20 D5 E0                     JSR     HEX2ASC         ;Print Loop count
   699 00:E2E0: 20 02 E2                     JSR     CROUT           ;Send C/R to console
   700 00:E2E3: 80 DC        NOLP_CNT        BRA     MACINI          ;Zero Head pointer and exit
   701                        ;
   702                        ;**************************************************************************************************
   703                        ;*                      Basic Memory Operations (includes Ctrl-P)                                 *
   704                        ;**************************************************************************************************
   705                        ;
   706                        ;[C] Compare routine: one memory range to another and display any addresses which do not match
   707                        ;[M] Move routine: uses this section for parameter input, then branches to MOVER below
   708                        ;[F] Fill routine: uses this section for parameter input but requires a fill byte value
   709                        ;[CTRL-P] Program EEPROM: uses this section for parameter input and to write the EEPROM
   710                        ;Uses source, target and length input parameters. Errors in compare are shown in target space.
   711                        ;
   712                        ; NOTE: If the PLD memory configuration is changed to increase RAM and decrease EEPROM,
  Thu Mar 16 2023 11:46                                                                                                    Page 19


   713                        ;       the unlock code will not work correctly, as the minimum addressable EEPROM is
   714                        ;       22KB. This is the case with the current configuration used here... 56KB of RAM
   715                        ;       and 8KB of EEPROM.
   716                        ;
   717 00:E2E5: A9 05        FM_INPUT        LDA     #$05            ;Send "val: " to terminal
   718 00:E2E7: 20 31 E1                     JSR     HEX2            ;Use short cut version for print and input
   719 00:E2EA: 85 C3                        STA     TEMP2           ;Save fill byte to temp
   720 00:E2EC: 20 47 E2                     JSR     CONTINUE        ;Handle continue prompt
   721                        ;
   722                        ;Memory fill routine: parameter gathered below with Move/Fill,
   723                        ; then a jump to here TEMP2 contains fill byte value
   724 00:E2EF: A5 BC        FILL_LP         LDA     LENL            ;Get length low byte
   725 00:E2F1: 05 BD                        ORA     LENH            ;OR in length high byte
   726 00:E2F3: F0 CE                        BEQ     DONEFILL        ;Exit if zero
   727 00:E2F5: A5 C3                        LDA     TEMP2           ;Get fill byte from TEMP2
   728 00:E2F7: 92 BA                        STA     (TGTL)          ;Store in target location
   729 00:E2F9: 20 B8 E1                     JSR     UPD_TL          ;Update Target/Length pointers
   730 00:E2FC: 80 F1                        BRA     FILL_LP         ;Loop back until done
   731                        ;
   732                        ; Compare/Move/Fill Memory operations ENTER HERE!!
   733                        ;
   734                        ;Compare/Move/Fill memory operations
   735 00:E2FE: 85 C3        CPMVFL          STA     TEMP2           ;Save command character
   736 00:E300: 20 3C FF                     JSR     B_CHROUT        ;Print command character (C/M/F)
   737 00:E303: C9 46                        CMP     #$46            ;Check for F - fill memory
   738 00:E305: D0 0B                        BNE     PRGE_E          ;If not, continue normal parameter input
   739 00:E307: A9 03                        LDA     #$03            ;Get msg " addr:"
   740 00:E309: 80 12                        BRA     F_INPUT         ;Branch to handle parameter input
   741                        ;
   742                        ;EEPROM write operation ENTERS HERE!!
   743 00:E30B: A9 1B        PROGEE          LDA     #$1B            ;Get PRG_EE msg
   744 00:E30D: 20 01 E1                     JSR     PROMPT          ;Send to terminal
   745 00:E310: 64 C3                        STZ     TEMP2           ;Clear (Compare/Fill/Move)/error flag
   746                        ;
   747 00:E312: A9 06        PRGE_E          LDA     #$06            ;Get " src:" msg
   748 00:E314: 20 24 E1                     JSR     HEX4            ;Use short cut version for print and get input
   749 00:E317: 85 B8                        STA     SRCL            ;Else, store source address in variable SRCL,SRCH
   750 00:E319: 84 B9                        STY     SRCH            ;Store high address
   751 00:E31B: A9 07                        LDA     #$07            ;Get " tgt:" msg
   752 00:E31D: 20 24 E1     F_INPUT         JSR     HEX4            ;Use short cut version for print and get input
   753 00:E320: 85 BA                        STA     TGTL            ;Else, store target address in variable TGTL,TGTH
   754 00:E322: 84 BB                        STY     TGTH            ;Store high address
   755 00:E324: A9 04                        LDA     #$04            ;Get " len:" msg
   756 00:E326: 20 24 E1                     JSR     HEX4            ;Use short cut version for print and get input
   757 00:E329: 85 BC                        STA     LENL            ;ELSE, store length address in variable LENL,LENH
   758 00:E32B: 84 BD                        STY     LENH            ;Store high address
   759                        ;
   760                        ; All input parameters for Source, Target and Length entered
   761 00:E32D: A5 C3                        LDA     TEMP2           ;Get Command character
   762 00:E32F: C9 46                        CMP     #$46            ;Check for fill memory
   763 00:E331: F0 B2                        BEQ     FM_INPUT        ;Handle the remaining input
   764 00:E333: C9 43                        CMP     #$43            ;Test for Compare
   765 00:E335: F0 31                        BEQ     COMPLP          ;Branch if yes
   766 00:E337: C9 4D                        CMP     #$4D            ;Check for Move
   767 00:E339: F0 56                        BEQ     MOVER           ;Branch if yes
   768                        ;
   769                        ; Command is to Program EEPROM
   770 00:E33B: A9 1C        PROG_EE         LDA     #$1C            ;Get warning msg
   771 00:E33D: 20 01 E1                     JSR     PROMPT          ;Send to console
   772 00:E340: 20 4B E2                     JSR     CONTINUE2       ;Prompt for (Y/N)
   773                        ;
   774                        ;Programming of the EEPROM is now confirmed by user. This routine will copy the core move and test
   775                        ; routine from ROM to RAM, then call COMPLP to write and compare. As I/O can generate interrupts
  Thu Mar 16 2023 11:46                                                                                                    Page 20


   776                        ; which point to ROM routines, all interrupts must be disabled during the program sequence.
   777                        ;
   778                        ;Send message to console for writing EEPROM
   779 00:E343: A9 1D                        LDA     #$1D            ;Get write message
   780 00:E345: 20 01 E1                     JSR     PROMPT          ;Send to console
   781 00:E348: A5 DA        OC_LOOP         LDA     OCNT_A          ;Check output buffer count
   782 00:E34A: D0 FC                        BNE     OC_LOOP         ;Loop back until buffer sent
   783                        ;
   784                        ;Xfer byte write code to RAM for execution
   785 00:E34C: 20 E0 E3                     JSR     XFER_BYTE_WRT   ;Xfer byte write code to Page Zero
   786                        ;
   787                        ;Wait for 1/2 second for RAM/ROM access to settle
   788 00:E34F: A9 32                        LDA     #$32            ;Set milliseconds to 50(*10 ms)
   789 00:E351: 20 3F FF                     JSR     B_SET_DLY       ;Set Delay parameters
   790 00:E354: 20 42 FF                     JSR     B_EXE_MSDLY     ;Call delay for 1/2 second
   791                        ;
   792 00:E357: F7 C3        PROG_EEP        SMB7    TEMP2           ;Set EEPROM write active mask
   793 00:E359: 20 68 E3                     JSR     COMPLP          ;Call routine to write/compare
   794 00:E35C: 6F C3 04                     BBR6    TEMP2,PRG_GOOD  ;Skip down if no error
   795 00:E35F: A9 1F                        LDA     #$1F            ;Get Prog failed message
   796 00:E361: 80 02                        BRA     BRA_PRMPT       ;Branch to Prompt routine
   797                        ;
   798 00:E363: A9 1E        PRG_GOOD        LDA     #$1E            ;Get completed message
   799 00:E365: 4C 01 E1     BRA_PRMPT       JMP     PROMPT          ;Send to console and exit
   800                        ;
   801 00:E368: A5 BC        COMPLP          LDA     LENL            ;Get low byte of length
   802 00:E36A: 05 BD                        ORA     LENH            ;OR in High byte of length
   803 00:E36C: F0 71                        BEQ     QUITMV          ;If zero, nothing to compare/write
   804 00:E36E: 7F C3 03                     BBR7    TEMP2,SKP_BURN  ;Skip burn if bit 7 clear
   805 00:E371: 20 70 00                     JSR     BURN_BYTE       ;Else Burn a byte to EEPROM
   806 00:E374: B2 B8        SKP_BURN        LDA     (SRCL)          ;Load source byte
   807 00:E376: D2 BA                        CMP     (TGTL)          ;Compare to target byte
   808 00:E378: F0 12                        BEQ     CMP_OK          ;If compare is good, continue
   809                        ;
   810 00:E37A: E7 C3                        SMB6    TEMP2           ;Set bit 6 of TEMP2 flag (compare error)
   811 00:E37C: 20 F2 E1                     JSR     SPC2            ;Send 2 spaces
   812 00:E37F: 20 FA E1                     JSR     DOLLAR          ;Print $ sign
   813 00:E382: A5 BA                        LDA     TGTL            ;Get Low byte of address
   814 00:E384: A4 BB                        LDY     TGTH            ;Get High byte of address
   815 00:E386: 20 3D E2                     JSR     PRWORD          ;Print word
   816 00:E389: 20 F5 E1                     JSR     SPC             ;Add 1 space for formatting
   817                        ;
   818 00:E38C: 20 B2 E1     CMP_OK          JSR     UPD_STL         ;Update pointers
   819 00:E38F: 80 D7                        BRA     COMPLP          ;Loop back until done
   820                        ;
   821                        ;Parameters for move memory entered and validated, now make decision on which direction
   822                        ; to do the actual move, if overlapping, move from end to start, else from start to end.
   823 00:E391: 20 47 E2     MOVER           JSR     CONTINUE        ;Prompt to continue move
   824 00:E394: 38                           SEC                     ;Set carry flag for subtract
   825 00:E395: A5 BA                        LDA     TGTL            ;Get target lo byte
   826 00:E397: E5 B8                        SBC     SRCL            ;Subtract source lo byte
   827 00:E399: AA                           TAX                     ;Move to X Reg temporarily
   828 00:E39A: A5 BB                        LDA     TGTH            ;Get target hi byte
   829 00:E39C: E5 B9                        SBC     SRCH            ;Subtract source hi byte
   830 00:E39E: A8                           TAY                     ;Move to Y Reg temporarily
   831 00:E39F: 8A                           TXA                     ;Xfer lo byte difference to A Reg
   832 00:E3A0: C5 BC                        CMP     LENL            ;Compare to lo byte length
   833 00:E3A2: 98                           TYA                     ;Xfer hi byte difference to A Reg
   834 00:E3A3: E5 BD                        SBC     LENH            ;Subtract length lo byte
   835 00:E3A5: 90 0F                        BCC     RIGHT           ;If carry is clear, overwrite condition exists
   836                        ;
   837                        ;Move memory block first byte to last byte, no overlap condition
   838 00:E3A7: A5 BC        MVNO_LP         LDA     LENL            ;Get length low byte
  Thu Mar 16 2023 11:46                                                                                                    Page 21


   839 00:E3A9: 05 BD                        ORA     LENH            ;OR in length high byte
   840 00:E3AB: F0 32                        BEQ     QUITMV          ;Exit if zero bytes to move
   841 00:E3AD: B2 B8                        LDA     (SRCL)          ;Load source data
   842 00:E3AF: 92 BA                        STA     (TGTL)          ;Store as target data
   843 00:E3B1: 20 B2 E1                     JSR     UPD_STL         ;Update Source/Target/Length variables
   844 00:E3B4: 80 F1                        BRA     MVNO_LP         ;Branch back until length is zero
   845                        ;
   846                        ;Move memory block last byte to first byte avoids overwrite in source/target overlap
   847 00:E3B6: A6 BD        RIGHT           LDX     LENH            ;Get the length hi byte count
   848 00:E3B8: 18                           CLC                     ;Clear carry flag for add
   849 00:E3B9: 8A                           TXA                     ;Xfer High page to A Reg
   850 00:E3BA: 65 B9                        ADC     SRCH            ;Add in source hi byte
   851 00:E3BC: 85 B9                        STA     SRCH            ;Store in source hi byte
   852 00:E3BE: 18                           CLC                     ;Clear carry for add
   853 00:E3BF: 8A                           TXA                     ;Xfer High page to A Reg
   854 00:E3C0: 65 BB                        ADC     TGTH            ;Add to target hi byte
   855 00:E3C2: 85 BB                        STA     TGTH            ;Store to target hi byte
   856 00:E3C4: E8                           INX                     ;Increment high page value for use below in loop
   857 00:E3C5: A4 BC                        LDY     LENL            ;Get length lo byte
   858 00:E3C7: F0 0E                        BEQ     MVPG            ;If zero no partial page to move
   859 00:E3C9: 88                           DEY                     ;Else, decrement page byte index
   860 00:E3CA: F0 07                        BEQ     MVPAG           ;If zero, no pages to move
   861 00:E3CC: B1 B8        MVPRT           LDA     (SRCL),Y        ;Load source data
   862 00:E3CE: 91 BA                        STA     (TGTL),Y        ;Store to target data
   863 00:E3D0: 88                           DEY                     ;Decrement index
   864 00:E3D1: D0 F9                        BNE      MVPRT          ;Branch back until partial page moved
   865 00:E3D3: B1 B8        MVPAG           LDA     (SRCL),Y        ;Load source data
   866 00:E3D5: 91 BA                        STA     (TGTL),Y        ;Store to target data
   867 00:E3D7: 88           MVPG            DEY                     ;Decrement page count
   868 00:E3D8: C6 B9                        DEC     SRCH            ;Decrement source hi page
   869 00:E3DA: C6 BB                        DEC     TGTH            ;Decrement target hi page
   870 00:E3DC: CA                           DEX                     ;Decrement page count
   871 00:E3DD: D0 ED                        BNE     MVPRT           ;Loop back until all pages moved
   872 00:E3DF: 60           QUITMV          RTS                     ;Return to caller
   873                        ;
   874                        ;Xfer byte write code to RAM for execution
   875 00:E3E0: A2 24        XFER_BYTE_WRT   LDX     #BYTE_WRE-BYTE_WRS+1 ;Get length of byte write code
   876 00:E3E2: BD EA E3     BYTE_XFER       LDA     BYTE_WRS-1,X    ;Get code
   877 00:E3E5: 95 6F                        STA     BURN_BYTE-1,X   ;Write code to RAM
   878 00:E3E7: CA                           DEX                     ;Decrement index
   879 00:E3E8: D0 F8                        BNE     BYTE_XFER       ;Loop back until done
   880 00:E3EA: 60                           RTS                     ;Return to caller
   881                        ;
   882                        ;Byte write code for EEPROM.
   883                        ; Note: AT28BV256 requires an unlock sequence for all write operations.
   884                        ;  This is different from earlier Atmel EEPROMs (i.e., AT28C256). The
   885                        ;  sequence must be sent first to unlock the device, then data can be
   886                        ;  sent for programming. Note that byte writes can be 1 to 64 bytes.
   887                        ;  The EEPROM is defined in constants for the Offset of the EEPROM in
   888                        ;  the hardware memory map.
   889                        ;
   890                        ; NOTE: If the PLD memory configuration is changed to increase RAM and decrease EEPROM,
   891                        ;       the unlock code will not work correctly, as the minimum addressable EEPROM is
   892                        ;       22KB. This is the case with the current configuration used here... 56KB of RAM
   893                        ;       and 8KB of EEPROM.
   894                        ;
   895 00:E3EB: 78           BYTE_WRS        SEI                     ;Disable interrupts
   896                        ;
   897 00:E3EC: A9 AA                        LDA     #$AA            ;Get code $AA
   898 00:E3EE: 8D 55 D5                     STA     EEPROM+$5555    ;Send to EEPROM
   899 00:E3F1: A9 55                        LDA     #$55            ;Get code $55
   900 00:E3F3: 8D AA AA                     STA     EEPROM+$2AAA    ;Send to EEPROM
   901 00:E3F6: A9 A0                        LDA     #$A0            ;Get code $A0
  Thu Mar 16 2023 11:46                                                                                                    Page 22


   902 00:E3F8: 8D 55 D5                     STA     EEPROM+$5555    ;Send to EEPROM
   903                        ;
   904 00:E3FB: B2 B8                        LDA     (SRCL)          ;Get source byte
   905 00:E3FD: 92 BA                        STA     (TGTL)          ;Write to target byte
   906 00:E3FF: B2 BA                        LDA     (TGTL)          ;Read target byte (EEPROM)
   907 00:E401: 29 40                        AND     #%01000000      ;Mask off bit 6 - toggle bit
   908 00:E403: 85 C4        BYTE_WLP        STA     TEMP3           ;Store in Temp location
   909 00:E405: B2 BA                        LDA     (TGTL)          ;Read target byte again (EEPROM)
   910 00:E407: 29 40                        AND     #%01000000      ;Mask off bit 6 - toggle bit
   911 00:E409: C5 C4                        CMP     TEMP3           ;Compare to last read (toggles if write mode)
   912 00:E40B: D0 F6                        BNE     BYTE_WLP        ;Branch back if not done
   913 00:E40D: 58                           CLI                     ;Re-enable interrupts
   914 00:E40E: 60           BYTE_WRE        RTS                     ;Return to caller
   915                        ;
   916                        ;[D] HEX/TEXT DUMP command:
   917                        ; Display in HEX followed by TEXT, the contents of 256 consecutive memory addresses
   918 00:E40F: F7 C5        MDUMP           SMB7    CMDFLAG         ;Set bit7 of command flag
   919 00:E411: 20 1C E1                     JSR     SETUP           ;Request HEX address input from terminal
   920 00:E414: D0 08                        BNE     LINED           ;Branch if new address entered (Z flag updated)
   921 00:E416: A5 B2                        LDA     TEMP1L          ;Else, point to next consecutive memory page
   922 00:E418: 85 B0                        STA     INDEXL          ;address saved during last memory dump
   923 00:E41A: A5 B3                        LDA     TEMP1H          ;Xfer high byte of address
   924 00:E41C: 85 B1                        STA     INDEXH          ;Save in pointer
   925 00:E41E: 20 69 E4     LINED           JSR     DMPGR           ;Send address offsets to terminal
   926 00:E421: 20 0F E2                     JSR     GLINE           ;Send horizontal line to terminal
   927 00:E424: 20 02 E2                     JSR     CROUT           ;Send CR,LF to terminal
   928 00:E427: A2 10                        LDX     #$10            ;Set line count for 16 rows
   929 00:E429: 20 EF E1     DLINE           JSR     SPC4            ;Send 4 Spaces to terminal
   930 00:E42C: 20 36 E2                     JSR     PRINDEX         ;Print INDEX value
   931 00:E42F: 20 F2 E1                     JSR     SPC2            ;Send 2 Spaces to terminal
   932 00:E432: A0 00                        LDY     #$00            ;Initialize line byte counter
   933 00:E434: 20 8E E5     GETBYT          JSR     SENGBYT         ;Use Search Engine Get Byte (excludes I/O)
   934 00:E437: 99 40 03                     STA     SRCHBUFF,Y      ;Save in Search buffer (16 bytes)
   935 00:E43A: 20 27 E2                     JSR     PRBYTE          ;Display byte as a HEX value
   936 00:E43D: 20 F5 E1                     JSR     SPC             ;Send Space to terminal
   937 00:E440: 20 D0 E1                     JSR     INCINDEX        ;Increment Index to next byte location
   938 00:E443: C8                           INY                     ;Increment index
   939 00:E444: C0 10                        CPY     #$10            ;Check for all 16
   940 00:E446: D0 EC                        BNE     GETBYT          ;Loop back until 16 bytes have been displayed
   941 00:E448: 20 F5 E1                     JSR     SPC             ;Send a space
   942 00:E44B: A0 00                        LDY     #$00            ;Reset index for SRCHBUFF
   943 00:E44D: B9 40 03     GETBYT2         LDA     SRCHBUFF,Y      ;Get buffered line (16 bytes)
   944 00:E450: 20 1A E2                     JSR     PRASC           ;Print ASCII character
   945 00:E453: C8                           INY                     ;Increment index to next byte
   946 00:E454: C0 10                        CPY     #$10            ;Check for 16 bytes
   947 00:E456: D0 F5                        BNE     GETBYT2         ;Loop back until 16 bytes have been displayed
   948 00:E458: 20 02 E2                     JSR     CROUT           ;Else, send CR,LF to terminal
   949 00:E45B: A5 B0                        LDA     INDEXL          ;Get current index low
   950 00:E45D: 85 B2                        STA     TEMP1L          ;Save to temp1 low
   951 00:E45F: A5 B1                        LDA     INDEXH          ;Get current index high
   952 00:E461: 85 B3                        STA     TEMP1H          ;Save to temp1 high
   953 00:E463: CA                           DEX                     ;Decrement line count
   954 00:E464: D0 C3                        BNE     DLINE           ;Branch back until all 16 done
   955 00:E466: 20 0F E2                     JSR     GLINE           ;Send horizontal line to terminal
   956                        ;
   957                        ;DMPGR subroutine: Send address offsets to terminal
   958 00:E469: A9 02        DMPGR           LDA     #$02            ;Get msg for "addr:" to terminal
   959 00:E46B: 20 01 E1                     JSR     PROMPT          ;Send to terminal
   960 00:E46E: 20 F2 E1                     JSR     SPC2            ;Add two additional spaces
   961 00:E471: A2 00                        LDX     #$00            ;Zero index count
   962 00:E473: 8A           MDLOOP          TXA                     ;Send "00" thru "0F", separated by 1 Space, to terminal
   963 00:E474: 20 27 E2                     JSR     PRBYTE          ;Print byte value
   964 00:E477: 20 F5 E1                     JSR     SPC             ;Add a space
  Thu Mar 16 2023 11:46                                                                                                    Page 23


   965 00:E47A: E8                           INX                     ;Increment the count
   966 00:E47B: E0 10                        CPX     #$10            ;Check for 16
   967 00:E47D: D0 F4                        BNE     MDLOOP          ;Loop back until done
   968                        ;
   969                        ;Print the ASCII text header "0123456789ABCDEF"
   970 00:E47F: 20 F5 E1                     JSR     SPC             ;Send a space
   971 00:E482: A2 00                        LDX     #$00            ;Zero X Reg for "0"
   972 00:E484: 8A           MTLOOP          TXA                     ;Xfer to A Reg
   973 00:E485: 20 AA E0                     JSR     BIN2ASC         ;Convert Byte to two ASCII digits
   974 00:E488: 98                           TYA                     ;Xfer the low nibble character to A Reg
   975 00:E489: 20 3C FF                     JSR     B_CHROUT        ;Send least significant HEX to terminal
   976 00:E48C: E8                           INX                     ;Increment to next HEX character
   977 00:E48D: E0 10                        CPX     #$10            ;Check for 16
   978 00:E48F: D0 F3                        BNE     MTLOOP          ;Branch back till done
   979 00:E491: 4C 02 E2                     JMP     CROUT           ;Do a CR/LF and return
   980                        ;
   981                        ;[E] Examine/Edit command: Display in HEX then change the contents of a specified memory address
   982 00:E494: 20 1C E1     CHANGE          JSR     SETUP           ;Request HEX address input from terminal
   983 00:E497: A5 B1        CHNG_LP         LDA     INDEXH          ;Test high byte address for RAM (less than $80)
   984 00:E499: C9 E0                        CMP     #$E0            ;Check for Start of ROM at $E000
   985 00:E49B: B0 1E                        BCS     NO_RAM          ;Address is in ROM, can not edit.
   986                        ;                BMI     NO_RAM          ;Address not in RAM
   987 00:E49D: 20 F2 E1                     JSR     SPC2            ;Send 2 spaces
   988 00:E4A0: B2 B0                        LDA     (INDEXL)        ;Read specified address
   989 00:E4A2: 20 27 E2                     JSR     PRBYTE          ;Display HEX value read
   990 00:E4A5: 20 E7 E1                     JSR     BSOUT3T         ;Send 3 Backspaces
   991 00:E4A8: 20 34 E1                     JSR     HEXIN2          ;Get input, result in A Reg
   992 00:E4AB: 92 B0                        STA     (INDEXL)        ;Save entered value at Index pointer
   993 00:E4AD: D2 B0                        CMP     (INDEXL)        ;Compare to ensure a match
   994 00:E4AF: F0 05                        BEQ     CHOK            ;Branch if compare is good
   995 00:E4B1: A9 3F                        LDA     #$3F            ;Get "?" for bad compare
   996 00:E4B3: 20 3C FF                     JSR     B_CHROUT        ;Send to terminal
   997 00:E4B6: 20 D0 E1     CHOK            JSR     INCINDEX        ;Increment Index
   998 00:E4B9: 80 DC                        BRA     CHNG_LP         ;Loop to continue command
   999 00:E4BB: A9 2B        NO_RAM          LDA     #$2B            ;Get address range message
  1000 00:E4BD: 20 01 E1                     JSR     PROMPT          ;Send to console
  1001 00:E4C0: A9 2D                        LDA     #$2D            ;Get RAM message
  1002 00:E4C2: 20 01 E1                     JSR     PROMPT          ;Send to console
  1003 00:E4C5: 80 CD                        BRA     CHANGE          ;Branch back and try again
  1004                        ;
  1005                        ;[G] GO command: Begin executing program code at a specified address.
  1006                        ; Prompts the user for a start address, places it in COMLO/COMHI. If no address entered,
  1007                        ; uses default address at COMLO/COMHI. Loads the A,X,Y,P Registers from presets and does
  1008                        ; a JSR to the routine. Upon return, Registers are saved back to presets for display later.
  1009                        ; Also saves the stack pointer and status Register upon return.
  1010                        ; Note: Stack pointer is not changed due to IRQ service routines.
  1011 00:E4C7: F7 C5        GO              SMB7    CMDFLAG         ;Set bit7 of command flag
  1012 00:E4C9: 20 1C E1                     JSR     SETUP           ;Get HEX address (A/Y Regs hold 16-bit value)
  1013 00:E4CC: F0 04                        BEQ     EXEC_GO         ;If not, setup Regs and execute (Z flag updated)
  1014 00:E4CE: 85 AE                        STA     COMLO           ;Save entered address to pointer low byte
  1015 00:E4D0: 84 AF                        STY     COMHI           ;Save entered address to pointer hi byte
  1016                        ;
  1017                        ;Preload all 65C02 MPU Registers from Monitor's preset/result variables
  1018 00:E4D2: A5 D2        EXEC_GO         LDA     PREG            ;Load processor status Register preset
  1019 00:E4D4: 48                           PHA                     ;Push it to the stack
  1020 00:E4D5: A5 D6                        LDA     AREG            ;Load A-Reg preset
  1021 00:E4D7: A6 D5                        LDX     XREG            ;Load X-Reg preset
  1022 00:E4D9: A4 D4                        LDY     YREG            ;Load Y-Reg preset
  1023 00:E4DB: 28                           PLP                     ;Pull the processor status Register
  1024                        ;
  1025                        ;Call user program code as a subroutine
  1026 00:E4DC: 20 EE E4                     JSR     DOCOM           ;Execute code at specified address
  1027                        ;
  Thu Mar 16 2023 11:46                                                                                                    Page 24


  1028                        ;Store all 65C02 MPU Registers to Monitor's preset/result variables: store results
  1029 00:E4DF: 08                           PHP                     ;Save the processor status Register to the stack
  1030 00:E4E0: 85 D6                        STA     AREG            ;Store A-Reg result
  1031 00:E4E2: 86 D5                        STX     XREG            ;Store X-Reg result
  1032 00:E4E4: 84 D4                        STY     YREG            ;Store Y-Reg result
  1033 00:E4E6: 68                           PLA                     ;Get the processor status Register
  1034 00:E4E7: 85 D2                        STA     PREG            ;Store the result
  1035 00:E4E9: BA                           TSX                     ;Xfer stack pointer to X-Reg
  1036 00:E4EA: 86 D3                        STX     SREG            ;Store the result
  1037 00:E4EC: D8                           CLD                     ;Clear BCD mode in case of sloppy user code ;-)
  1038 00:E4ED: 60           TXT_EXT         RTS                     ;Return to caller
  1039 00:E4EE: 6C AE 00     DOCOM           JMP     (COMLO)         ;Execute the command
  1040                        ;
  1041                        ;[T] LOCATE TEXT STRING command: search memory for an entered text string
  1042                        ;Memory range scanned is $0800 through $FFFF (setup before SENGINE subroutine is invoked)
  1043                        ;SRCHTXT subroutine: request 1 - 16 character text string from terminal, followed by Return
  1044                        ;[ESCAPE] aborts, [BACKSPACE] erases last keystroke. String will be stored in SRCHBUFF
  1045 00:E4F1: A9 08        SRCHTXT         LDA     #$08            ;Get msg " find text:"
  1046 00:E4F3: 20 01 E1                     JSR     PROMPT          ;Send to terminal
  1047 00:E4F6: A2 00                        LDX     #$00            ;Initialize index/byte counter
  1048 00:E4F8: 20 39 FF     STLOOP          JSR     B_CHRIN         ;Get input from terminal
  1049 00:E4FB: C9 0D                        CMP     #$0D            ;Check for C/R
  1050 00:E4FD: F0 3F                        BEQ     SRCHRDY1        ;Branch to search engine
  1051 00:E4FF: C9 1B                        CMP     #$1B            ;Check for ESC
  1052 00:E501: F0 EA                        BEQ     TXT_EXT         ;Exit to borrowed RTS
  1053 00:E503: C9 08                        CMP     #$08            ;Check for B/S
  1054 00:E505: D0 09                        BNE     STBRA           ;If not, store character into buffer
  1055 00:E507: 8A                           TXA                     ;Xfer count to A Reg
  1056 00:E508: F0 EE                        BEQ     STLOOP          ;Branch to input if zero
  1057 00:E50A: 20 DC E1                     JSR     BSOUT           ;Else, send B/S to terminal
  1058 00:E50D: CA                           DEX                     ;Decrement index/byte counter
  1059 00:E50E: 80 E8                        BRA     STLOOP          ;Branch back and continue
  1060 00:E510: 9D 40 03     STBRA           STA     SRCHBUFF,X      ;Store character in buffer location
  1061 00:E513: 20 3C FF                     JSR     B_CHROUT        ;Send character to terminal
  1062 00:E516: E8                           INX                     ;Increment counter
  1063 00:E517: E0 10                        CPX     #$10            ;Check count for 16
  1064 00:E519: D0 DD                        BNE     STLOOP          ;Loop back for another character
  1065 00:E51B: A9 08                        LDA     #$08            ;Get start address for $0800
  1066 00:E51D: 80 1F                        BRA     SRCHRDY1        ;Branch to search engine
  1067                        ;
  1068                        ;[H] LOCATE BYTE STRING command: Search memory for an entered byte string. Memory range
  1069                        ; scanned is $0400 through $FFFF. SRCHBYT subroutine: request 0 - 16 byte string from
  1070                        ; terminal, byte followed by [RETURN]. [ESCAPE] aborts. HEX data will be stored in SRCHBUFF.
  1071                        ; minor update from Mike Barry, saves a byte.
  1072 00:E51F: F7 C5        SRCHBYT         SMB7    CMDFLAG         ;Set bit7 of command flag
  1073 00:E521: A9 09                        LDA     #$09            ;Get msg " find bin:"
  1074 00:E523: 20 01 E1                     JSR     PROMPT          ;Send to terminal
  1075 00:E526: A2 00                        LDX     #$00            ;Initialize index
  1076 00:E528: DA           SBLOOP          PHX                     ;Save index on stack
  1077 00:E529: 20 34 E1                     JSR     HEXIN2          ;Request HEX byte
  1078 00:E52C: 20 F5 E1                     JSR     SPC             ;Send space to terminal
  1079 00:E52F: FA                           PLX                     ;Restore index from stack
  1080 00:E530: A4 BE                        LDY     BUFIDX          ;Get # of characters entered
  1081 00:E532: F0 08                        BEQ     SRCHRDY         ;Branch if no characters
  1082 00:E534: 9D 40 03                     STA     SRCHBUFF,X      ;Else, store in buffer
  1083 00:E537: E8                           INX                     ;Increment index
  1084 00:E538: E0 10                        CPX     #$10            ;Check for 16 (max)
  1085 00:E53A: D0 EC                        BNE     SBLOOP          ;Loop back until done/full
  1086 00:E53C: A9 04        SRCHRDY         LDA     #$04            ;Get start address for $0400
  1087 00:E53E: 85 B1        SRCHRDY1        STA     INDEXH          ;Store to Index high byte
  1088 00:E540: 64 B0                        STZ     INDEXL          ;Zero Index low byte ($XX00)
  1089 00:E542: 86 C0                        STX     IDX             ;Save input character count
  1090 00:E544: 8A                           TXA                     ;Check buffer count (for zero)
  Thu Mar 16 2023 11:46                                                                                                    Page 25


  1091 00:E545: F0 58                        BEQ     NOWRAP          ;Exit if no bytes in buffer
  1092                        ;
  1093                        ;SENGINE subroutine: Scan memory range $XX00 through $FFFF for exact match to string contained
  1094                        ; in buffer SRCHBUFF (1 to 16 bytes/characters). Display address of first byte/character of
  1095                        ; each match found until the end of memory is reached.
  1096 00:E547: A9 0C        SENGINE         LDA     #$0C            ;Else, get msg "Searching.."
  1097 00:E549: 20 01 E1                     JSR     PROMPT          ;Send to terminal
  1098 00:E54C: A2 00        SENGBR2         LDX     #$00            ;Initialize buffer index
  1099 00:E54E: 20 8E E5     SENGBR3         JSR     SENGBYT         ;Get the next byte from Index pointer
  1100 00:E551: DD 40 03                     CMP     SRCHBUFF,X      ;Compare to search buffer
  1101 00:E554: F0 05                        BEQ     SENGBR1         ;Branch for a match
  1102 00:E556: 20 A0 E5                     JSR     SINCPTR         ;Increment pointer, test for end of memory
  1103 00:E559: 80 F1                        BRA     SENGBR2         ;Loop back to continue
  1104 00:E55B: 20 A0 E5     SENGBR1         JSR     SINCPTR         ;Increment pointer, test for end of memory
  1105 00:E55E: E8                           INX                     ;Increment buffer index
  1106 00:E55F: E4 C0                        CPX     IDX             ;Compare buffer index to address index
  1107 00:E561: D0 EB                        BNE     SENGBR3         ;Loop back until done
  1108 00:E563: 38                           SEC                     ;Subtract buffer index from memory pointer; Set carry
  1109 00:E564: A5 B0                        LDA     INDEXL          ;Get current address for match lo byte
  1110 00:E566: E5 C0                        SBC     IDX             ;Subtract from buffer index
  1111 00:E568: 85 B0                        STA     INDEXL          ;Save it back to lo address pointer
  1112 00:E56A: A5 B1                        LDA     INDEXH          ;Get current address for match hi byte
  1113 00:E56C: E9 00                        SBC     #$00            ;Subtract carry flag
  1114 00:E56E: 85 B1                        STA     INDEXH          ;Save it back to hi address pointer
  1115 00:E570: A9 0B                        LDA     #$0B            ;Get msg "found"
  1116 00:E572: 20 01 E1                     JSR     PROMPT          ;Send to terminal
  1117 00:E575: A9 3A                        LDA     #':'            ;Get Ascii colon
  1118 00:E577: 20 3C FF                     JSR     B_CHROUT        ;Send to console
  1119 00:E57A: 20 36 E2                     JSR     PRINDEX         ;Print Index address
  1120 00:E57D: A9 0D                        LDA     #$0D            ;Get msg "(n)ext? "
  1121 00:E57F: 20 01 E1                     JSR     PROMPT          ;Send to terminal
  1122 00:E582: 20 A8 E1                     JSR     RDCHAR          ;Get input from terminal
  1123 00:E585: C9 4E                        CMP     #$4E            ;Check for "(n)ext"
  1124 00:E587: D0 16                        BNE     NOWRAP          ;Exit if not requesting next
  1125 00:E589: 20 A0 E5                     JSR     SINCPTR         ;Increment address pointer, test for end of memory
  1126 00:E58C: 80 BE                        BRA     SENGBR2         ;Branch back and continue till done
  1127                        ;
  1128                        ;Search Engine GetByte routine: This routine gets the byte value from the current Index pointer
  1129                        ; location. It also checks the Index location FIRST. The I/O page is excluded from the actual data
  1130                        ; search to prevent corrupting any I/O devices which are sensitive to any READ operations outside
  1131                        ; the BIOS which supports it. An example is the NXP UART family, of which the SCC2691 is used here.
  1132                        ; Current I/O Page Range is $FE00 - $FE9F
  1133                        ; NOTE: $FEA0 - $FEFF used for vector/config data - allows searching here
  1134 00:E58E: A5 B1        SENGBYT         LDA     INDEXH          ;Get High byte address for current Index
  1135 00:E590: C9 FE                        CMP     #$FE            ;Check for Base I/O page
  1136 00:E592: F0 03                        BEQ     CHK_UPR         ;If yes, check for I/O range
  1137 00:E594: B2 B0        SENRTBYT        LDA     (INDEXL)        ;Else Get byte from current pointer
  1138 00:E596: 60                           RTS                     ;Return to caller
  1139 00:E597: A5 B0        CHK_UPR         LDA     INDEXL          ;Get Low byte address for current Index
  1140 00:E599: C9 A0                        CMP     #$A0            ;Check for end of I/O addresses
  1141 00:E59B: B0 F7                        BCS     SENRTBYT        ;Return ROM data if range is $FEA0 or higher
  1142 00:E59D: A9 FE                        LDA     #$FE            ;Get $FE as seed byte instead of I/O device read
  1143 00:E59F: 60           NOWRAP          RTS                     ;Return to caller
  1144                        ;
  1145                        ;Increment memory address pointer. If pointer high byte = 00 (end of searchable ROM memory),
  1146                        ; send "not found" to terminal then return to Monitor
  1147 00:E5A0: 20 D0 E1     SINCPTR         JSR     INCINDEX        ;Increment Index pointer
  1148 00:E5A3: A5 B1                        LDA     INDEXH          ;Check for wrap to $0000
  1149 00:E5A5: D0 F8                        BNE     NOWRAP          ;If not, return
  1150 00:E5A7: 68                           PLA                     ;Else, Pull return address from stack
  1151 00:E5A8: 68                           PLA                     ;and exit with msg
  1152 00:E5A9: A9 0A                        LDA     #$0A            ;Get msg "not found"
  1153 00:E5AB: 4C 01 E1                     JMP     PROMPT          ;Send msg to terminal and return
  Thu Mar 16 2023 11:46                                                                                                    Page 26


  1154                        ;
  1155                        ;[I] command: TEXT ENTRY enter ASCII text beginning at a specified address
  1156 00:E5AE: 20 1C E1     TEXT            JSR     SETUP           ;Send "I" command, handle setup
  1157 00:E5B1: 20 02 E2     EDJMP1          JSR     CROUT           ;Send CR,LF to terminal
  1158 00:E5B4: 85 B4                        STA     TEMP2L          ;Save current edit address
  1159 00:E5B6: 84 B5                        STY     TEMP2H          ;Save high byte
  1160 00:E5B8: 20 39 FF     EDJMP2          JSR     B_CHRIN         ;Request a keystroke from terminal
  1161 00:E5BB: C9 1B                        CMP     #$1B            ;Check for end text entry
  1162 00:E5BD: F0 3C                        BEQ     EDITDUN         ;Branch and close out if yes
  1163 00:E5BF: C9 0D                        CMP     #$0D            ;Else, check for Return key
  1164 00:E5C1: D0 12                        BNE     ENOTRET         ;Branch if not
  1165 00:E5C3: 92 B0                        STA     (INDEXL)        ;Save CR to current Index pointer
  1166 00:E5C5: 20 D0 E1                     JSR     INCINDEX        ;Increment edit memory address pointer
  1167 00:E5C8: A9 0A                        LDA     #$0A            ;Get a LF character
  1168 00:E5CA: 92 B0                        STA     (INDEXL)        ;Store it in memory
  1169 00:E5CC: 20 D0 E1                     JSR     INCINDEX        ;Increment edit memory address pointer
  1170 00:E5CF: A5 B0                        LDA     INDEXL          ;Get Start of next line
  1171 00:E5D1: A4 B1                        LDY     INDEXH          ;and the high byte
  1172 00:E5D3: 80 DC                        BRA     EDJMP1          ;Loop back to continue
  1173 00:E5D5: C9 08        ENOTRET         CMP     #$08            ;Check for backspace character
  1174 00:E5D7: F0 0A                        BEQ     EDBKSPC         ;Branch if yes
  1175 00:E5D9: 92 B0                        STA     (INDEXL)        ;Else, save to current Index pointer
  1176 00:E5DB: 20 3C FF                     JSR     B_CHROUT        ;Send keystroke to terminal
  1177 00:E5DE: 20 D0 E1                     JSR     INCINDEX        ;Increment edit memory address pointer
  1178 00:E5E1: 80 D5                        BRA     EDJMP2          ;Loop back to EDJMP2
  1179                        ;
  1180                        ;Handle Backspace, don't allow past starting address
  1181 00:E5E3: A5 B0        EDBKSPC         LDA     INDEXL          ;Get current index low byte
  1182 00:E5E5: C5 B4                        CMP     TEMP2L          ;Compare to initial start address
  1183 00:E5E7: D0 06                        BNE     EDDOBKS         ;If not equal, perform backspace
  1184 00:E5E9: A5 B1                        LDA     INDEXH          ;Get current index high byte
  1185 00:E5EB: C5 B5                        CMP     TEMP2H          ;Compare to initial start address
  1186 00:E5ED: F0 C9                        BEQ     EDJMP2          ;If same, branch to input loop
  1187 00:E5EF: 20 DC E1     EDDOBKS         JSR     BSOUT           ;Send backspace to terminal
  1188 00:E5F2: 20 C7 E1                     JSR     DECINDEX        ;Decrement edit memory address pointer
  1189 00:E5F5: A9 00                        LDA     #$00            ;Get a null character
  1190 00:E5F7: 92 B0                        STA     (INDEXL)        ;Store in place of character
  1191 00:E5F9: 80 BD                        BRA     EDJMP2          ;LOOP back to EDJMP2
  1192 00:E5FB: 20 FF E1     EDITDUN         JSR     CR2             ;Send 2 CR,LF to terminal
  1193 00:E5FE: 4C 36 E2                     JMP     PRINDEX         ;Print INDEX value and return
  1194                        ;
  1195                        ;**************************************************************************************************
  1196                        ;*                              Processor Register Operations                                     *
  1197                        ;**************************************************************************************************
  1198                        ;
  1199                        ;[P] Processor Status command: Display then change PS preset/result
  1200 00:E601: A9 0E        PRG             LDA     #$0E            ;Get MSG # for Processor Status Register
  1201 00:E603: 80 0E                        BRA     REG_UPT         ;Finish Register update
  1202                        ;
  1203                        ;[S] Stack Pointer command: Display then change SP preset/result
  1204 00:E605: A9 0F        SRG             LDA     #$0F            ;Get MSG # for Stack Register
  1205 00:E607: 80 0A                        BRA     REG_UPT         ;Finish Register update
  1206                        ;
  1207                        ;[Y] Y-Register command: Display then change Y-Reg preset/result
  1208 00:E609: A9 10        YRG             LDA     #$10            ;Get MSG # for Y Reg
  1209 00:E60B: 80 06                        BRA     REG_UPT         ;Finish Register update
  1210                        ;
  1211                        ;[X] X-Register command: Display then change X-Reg preset/result
  1212 00:E60D: A9 11        XRG             LDA     #$11            ;Get MSG # for X Reg
  1213 00:E60F: 80 02                        BRA     REG_UPT         ;Finish Register update
  1214                        ;
  1215                        ;[A] A-Register command: Display then change A-Reg preset/result
  1216 00:E611: A9 12        ARG             LDA     #$12            ;Get MSG # for A Reg
  Thu Mar 16 2023 11:46                                                                                                    Page 27


  1217                        ;
  1218 00:E613: 48           REG_UPT         PHA                     ;Save MSG # to stack
  1219 00:E614: 48                           PHA                     ;Save MSG # to stack again
  1220 00:E615: 20 01 E1                     JSR     PROMPT          ;Print Register message
  1221 00:E618: FA                           PLX                     ;Get Index to Registers
  1222 00:E619: B5 C4                        LDA     PREG-$0E,X      ;Read Register (A,X,Y,S,P) preset/result
  1223 00:E61B: 20 27 E2                     JSR     PRBYTE          ;Display HEX value of Register
  1224 00:E61E: 20 F5 E1                     JSR     SPC             ;Send [SPACE] to terminal
  1225 00:E621: 20 34 E1                     JSR     HEXIN2          ;Get up to 2 HEX characters
  1226 00:E624: FA                           PLX                     ;Get MSG # from stack
  1227 00:E625: 95 C4                        STA     PREG-$0E,X      ;Write Register (A,X,Y,S,P) preset/result
  1228 00:E627: 60           MNE_QUIT        RTS                     ;Return to caller
  1229                        ;
  1230                        ;[R] REGISTERS command: Display contents of all preset/result memory locations
  1231 00:E628: 20 3C FF     PRSTAT          JSR     B_CHROUT        ;Send "R" to terminal
  1232 00:E62B: A9 13        PRSTAT1         LDA     #$13            ;Get Header msg
  1233 00:E62D: 20 01 E1                     JSR     PROMPT          ;Send to terminal
  1234 00:E630: A5 D0                        LDA     PCL             ;Get PC Low byte
  1235 00:E632: A4 D1                        LDY     PCH             ;Get PC High byte
  1236 00:E634: 20 3D E2                     JSR     PRWORD          ;Print 16-bit word
  1237 00:E637: 20 F5 E1                     JSR     SPC             ;Send 1 space
  1238                        ;
  1239 00:E63A: A2 04                        LDX     #$04            ;Set for count of 4
  1240 00:E63C: B5 D2        REGPLOOP        LDA     PREG,X          ;Start with A Reg variable
  1241 00:E63E: 20 27 E2                     JSR     PRBYTE          ;Print it
  1242 00:E641: 20 F5 E1                     JSR     SPC             ;Send 1 space
  1243 00:E644: CA                           DEX                     ;Decrement count
  1244 00:E645: D0 F5                        BNE     REGPLOOP        ;Loop back till all 4 are sent
  1245                        ;
  1246 00:E647: A5 D2                        LDA     PREG            ;Get Status Register preset
  1247 00:E649: A2 08                        LDX     #$08            ;Get the index count for 8 bits
  1248 00:E64B: 0A           SREG_LP         ASL     A               ;Shift bit into Carry
  1249 00:E64C: 48                           PHA                     ;Save current (shifted) SR value
  1250 00:E64D: A9 30                        LDA     #$30            ;Load an Ascii zero
  1251 00:E64F: 69 00                        ADC     #$00            ;Add zero (with Carry)
  1252 00:E651: 20 3C FF                     JSR     B_CHROUT        ;Print bit value (0 or 1)
  1253 00:E654: 68                           PLA                     ;Get current (shifted) SR value
  1254 00:E655: CA                           DEX                     ;Decrement bit count
  1255 00:E656: D0 F3                        BNE     SREG_LP         ;Loop back until all 8 printed
  1256 00:E658: 4C 02 E2                     JMP     CROUT           ;Send CR/LF and return to caller
  1257                        ;
  1258                        ;**************************************************************************************************
  1259                        ;*                              Control Key Operations (Ctrl-?)                                   *
  1260                        ;**************************************************************************************************
  1261                        ;
  1262                        ;[CTRL-A] Start Assembler:
  1263 00:E65B: A9 2E        ASSEMBLER       LDA     #$2E            ;Get Intro message
  1264 00:E65D: 20 01 E1                     JSR     PROMPT          ;Send to console
  1265 00:E660: A9 03                        LDA     #$03            ;Get Msg 03 -" addr:"
  1266 00:E662: 20 24 E1                     JSR     HEX4            ;Print msg and get address
  1267                        MNE_RETRY
  1268 00:E665: 20 02 E2                     JSR     CROUT           ;Send CR,LF to Console
  1269 00:E668: 20 36 E2                     JSR     PRINDEX         ;Send starting address to Console
  1270 00:E66B: 20 EF E1                     JSR     SPC4            ;Send 4 spaces
  1271                        ;
  1272                        ; Now get an Instruction entry and put into SRCHBUFF.
  1273                        ; This allows for a full instruction line entry which is buffered. This routine also allows
  1274                        ; editing of the entry input and uses a C/R to exit to the next routine to start instruction
  1275                        ; decode.
  1276                        ; NOTE: SRCHBUFF is used by multiple routines, so it won't show the entered data if you leave
  1277                        ; the assembler and use the "D" (display memory) command. 
  1278                        ;
  1279 00:E66E: A2 00                        LDX     #$00            ;Set input count to zero
  Thu Mar 16 2023 11:46                                                                                                    Page 28


  1280 00:E670: 20 A8 E1     MNE_LOOP        JSR     RDCHAR          ;Get input from terminal
  1281 00:E673: C9 0D                        CMP     #$0D            ;Check for CR
  1282 00:E675: F0 21                        BEQ     MNE_CRUNCH      ;Branch to parse routine
  1283 00:E677: C9 1B                        CMP     #$1B            ;Check for ESC
  1284 00:E679: F0 AC                        BEQ     MNE_QUIT        ;Exit to borrowed RTS
  1285 00:E67B: C9 08                        CMP     #$08            ;Check for Backspace
  1286 00:E67D: D0 09                        BNE     MNE_BRA         ;If not, store character into buffer
  1287 00:E67F: 8A                           TXA                     ;Xfer count to A Reg
  1288 00:E680: F0 EE                        BEQ     MNE_LOOP        ;Branch to input if zero
  1289 00:E682: 20 DC E1                     JSR     BSOUT           ;Else, send Backspace to terminal
  1290 00:E685: CA                           DEX                     ;Decrement index/byte counter
  1291 00:E686: 80 E8                        BRA     MNE_LOOP        ;Branch back and continue
  1292 00:E688: 9D 40 03     MNE_BRA         STA     SRCHBUFF,X      ;Store character in buffer location
  1293 00:E68B: 20 3C FF                     JSR     B_CHROUT        ;Send character to terminal
  1294 00:E68E: E8                           INX                     ;Increment counter
  1295 00:E68F: E0 0F                        CPX     #$0F            ;Check count for 15
  1296 00:E691: D0 DD                        BNE     MNE_LOOP        ;Loop back for another character
  1297 00:E693: 20 D7 E1                     JSR     BEEP            ;Send Beep to Console (buffer overflow)
  1298 00:E696: 80 CD                        BRA     MNE_RETRY       ;Branch back and try again
  1299                        ;
  1300                        MNE_CRUNCH
  1301 00:E698: 8E 4F 03                     STX     SRCHBUFF+15     ;Save Input count at end of buffer
  1302                        ;
  1303                        ; Just for test purposes, we're storing the entered line at $0700
  1304                        ;
  1305 00:E69B: 8E 0F 07                     STX     $070F           ;Save Input buffer count
  1306 00:E69E: A2 0E                        LDX     #$0E            ;Set count of 14
  1307 00:E6A0: BD 40 03     MNE_XFER        LDA     SRCHBUFF,X      ;Load input buffer
  1308 00:E6A3: 9D 00 07                     STA     $0700,x         ;Save it to a temp area
  1309 00:E6A6: CA                           DEX                     ;Decrement count
  1310 00:E6A7: 10 F7                        BPL     MNE_XFER        ;Branch back until done
  1311                        ;
  1312 00:E6A9: 4C 00 08                     JMP     $0800           ;Jump to RAM development code
  1313                        ;
  1314                        ;[CTRL-B] Boot from the Microdrive:
  1315                        ; - A Partition Record format has been decided to allow an OS to be booted from the Microdrive.
  1316                        ; - The Partition Record is located at LBA 0 on the Microdrive. This routine will set the block
  1317                        ; - parameters to load the first LBA from the drive and store it at the default buffer location.
  1318                        ; - The Partition Record has a 2-byte signature at an offset of 252 bytes. It's been decided that
  1319                        ; - the 2-byte signature will be $6502 as a hex word, i.e., stored $02, $65. If this is found.
  1320                        ; - the Monitor will jump to the beginning of the partition block loaded and it will be up to the
  1321                        ; - the Parition Record code to either continue a boot from disk or return to the Monitor via a
  1322                        ; - warm boot. The only two reasons to return are:
  1323                        ;       - An invalid 2-byte signature was found at the end of the Partition Record ($AA55).
  1324                        ;       - No Boot Record was found to be marked as Active, so there's no bootable partition.
  1325                        ;
  1326                        ; A quick cheat: just load 20 blocks from the offset into high memory and cold start SIM
  1327                        ;
  1328                        BOOT_MICRODRIVE
  1329                        ;                LDA     #$00            ;Load low byte LBA address
  1330                        ;                TAY                     ;Same for high LBA address
  1331                        ;                TAX                     ;Same for extended LBA address
  1332                        ;
  1333 00:E6AC: AD A4 F2                     LDA     part_offset+0
  1334 00:E6AF: AC A5 F2                     LDY     part_offset+1
  1335 00:E6B2: AE A6 F2                     LDX     part_offset+2
  1336                        ;
  1337 00:E6B5: 20 12 FF                     JSR     B_IDE_SET_LBA   ;Call BIOS to setup LBA number
  1338                        ;
  1339 00:E6B8: A9 00                        LDA     #$00            ;Set Address low byte
  1340 00:E6BA: A0 B8                        LDY     #$B8            ;Set Address high byte
  1341 00:E6BC: A2 14                        LDX     #20             ;Set Block count to 20 (10KB)
  1342 00:E6BE: 20 15 FF                     JSR     B_IDE_SET_ADDR  ;Set Xfer address and block count
  Thu Mar 16 2023 11:46                                                                                                    Page 29


  1343                        ;
  1344 00:E6C1: 20 09 FF                     JSR     B_IDE_READ_LBA  ;Read Block Zero to Buffer
  1345 00:E6C4: A5 FC                        LDA     IDE_STATUS_RAM  ;Get Status from BIOS call
  1346 00:E6C6: 4A                           LSR     A               ;Shift error bit to carry
  1347 00:E6C7: B0 06                        BCS     IDE_RD_ERR      ;Branch if error
  1348                        ;
  1349 00:E6C9: 4C 00 CC                     JMP     $CC00           ;Jump to SIM
  1350                        ;
  1351                        ;                LDX     #252            ;Get offset to signature
  1352                        ;                LDA     LBA_BUFFER,X    ;Get signature byte
  1353                        ;                CMP     #$02            ;Compare to $02
  1354                        ;                BNE     BAD_PART_BLK    ;Branch if incorrect
  1355                        ;                INX                     ;Increment index to next signature byte
  1356                        ;                LDA     LBA_BUFFER,X    ;Get signature byte
  1357                        ;                CMP     #$65            ;Compare to $65
  1358                        ;                BNE     BAD_PART_BLK    ;Branch if incorrect
  1359                        ;
  1360                        ;Signature is good! Now just jump to the Partition Record in LBA_BUFFER
  1361 00:E6CC: 4C 00 06                     JMP     LBA_BUFFER
  1362                        ;
  1363                        IDE_RD_ERR
  1364 00:E6CF: A9 4A                        LDA     #$4A            ;Microdrive Error message
  1365 00:E6D1: 4C 01 E1                     JMP     PROMPT          ;Send message and exit
  1366                        ;
  1367                        BAD_PART_BLK
  1368 00:E6D4: A9 4B                        LDA     #$4B            ;Partition Error message
  1369 00:E6D6: 4C 01 E1                     JMP     PROMPT          ;Send message and exit
  1370                        ;
  1371                        ;[CTRL-D] Disassembler: Table-Driven Disassembler. Supports ALL W65C02 Opcodes and Address modes.
  1372 00:E6D9: A9 28        DISASSEMBLER    LDA     #$28            ;Intro Message
  1373 00:E6DB: 20 01 E1                     JSR     PROMPT          ;Send to terminal
  1374 00:E6DE: A9 03                        LDA     #$03            ;Msg 03 -" addr:"
  1375 00:E6E0: 20 24 E1                     JSR     HEX4            ;Print msg and get address
  1376 00:E6E3: 20 02 E2                     JSR     CROUT           ;Send CR,LF to terminal
  1377 00:E6E6: A2 16        RPT_LIST        LDX     #$16            ;Set list count to 22
  1378 00:E6E8: DA           DIS_LOOP        PHX                     ;Push count to stack
  1379 00:E6E9: 20 09 E7                     JSR     DIS_LINE        ;Disassemble 1 instruction
  1380 00:E6EC: FA                           PLX                     ;Pull count from stack
  1381 00:E6ED: CA                           DEX                     ;Decrement count
  1382 00:E6EE: D0 F8                        BNE     DIS_LOOP        ;Loop back till list count is zero
  1383 00:E6F0: 20 39 FF     LST_LOOP        JSR     B_CHRIN         ;Get input from terminal
  1384 00:E6F3: C9 0D                        CMP     #$0D            ;Check for Return key
  1385 00:E6F5: F0 EF                        BEQ     RPT_LIST        ;If yes, repeat list
  1386 00:E6F7: C9 1B                        CMP     #$1B            ;Check for Escape
  1387 00:E6F9: F0 37                        BEQ     EXT_LIST        ;If yes, exit
  1388 00:E6FB: C9 20                        CMP     #$20            ;Check for space
  1389 00:E6FD: F0 05                        BEQ     LIST_ONE        ;If yes, disassemble 1 line
  1390 00:E6FF: 20 D7 E1                     JSR     BEEP            ;Else, beep for error
  1391 00:E702: 80 EC                        BRA     LST_LOOP        ;Loop back again
  1392 00:E704: 20 09 E7     LIST_ONE        JSR     DIS_LINE        ;Else, Disassemble one line
  1393 00:E707: 80 E7                        BRA     LST_LOOP        ;Branch back and continue
  1394                        ;
  1395                        ;DISASSEMBLE LINE: disassemble 1 instruction from working address
  1396 00:E709: 64 C3        DIS_LINE        STZ     TEMP2           ;Clear all flag bits
  1397 00:E70B: 20 36 E2                     JSR     PRINDEX         ;Print working address
  1398 00:E70E: 20 F2 E1                     JSR     SPC2            ;Send 2 spaces to terminal
  1399 00:E711: B2 B0                        LDA     (INDEXL)        ;Read opcode from working memory pointer
  1400 00:E713: 85 C6                        STA     OPXMDM          ;Save opcode
  1401 00:E715: 20 7A E7                     JSR     PRB_SPC2        ;Print byte, 2 spaces
  1402 00:E718: 4A                           LSR     A               ;Divide by 2 / shift low order bit into carry flag
  1403 00:E719: AA                           TAX                     ;Xfer Opcode /2 to X Reg
  1404 00:E71A: BD A8 F2                     LDA     HDLR_IDX,X      ;Get Pointer to handler table
  1405 00:E71D: B0 04                        BCS     USE_RGHT        ;If carry set use low nibble (odd)
  Thu Mar 16 2023 11:46                                                                                                    Page 30


  1406 00:E71F: 4A                           LSR     A               ;Else shift upper nibble to lower nibble (even)
  1407 00:E720: 4A                           LSR     A
  1408 00:E721: 4A                           LSR     A
  1409 00:E722: 4A                           LSR     A
  1410 00:E723: 29 0F        USE_RGHT        AND     #$0F            ;Mask off high nibble
  1411 00:E725: 0A                           ASL     A               ;Multiply by 2 for index
  1412 00:E726: AA                           TAX                     ;Use handler pointer to index handler table
  1413 00:E727: 20 33 E7                     JSR     DODISL          ;Call disassembler handler
  1414 00:E72A: 20 02 E2                     JSR     CROUT           ;Send CR,LF to terminal
  1415                        ;
  1416                        ;INCNDX routine: increment working address pointer then read it
  1417 00:E72D: 20 D0 E1     INCNDX          JSR     INCINDEX        ;Increment working address pointer
  1418 00:E730: B2 B0                        LDA     (INDEXL)        ;Read from working memory address
  1419 00:E732: 60           EXT_LIST        RTS                     ;Done, return to caller/exit
  1420                        ;
  1421 00:E733: 7C 28 F3     DODISL          JMP     (HDLR_TAB,X)    ;Execute address mode handler
  1422                        ;
  1423                        ;THREE BYTE routine: display operand bytes then mnemonic for three-byte instruction
  1424                        ; TWO BYTE routine: display operand byte then mnemonic for two-byte instruction
  1425 00:E736: F7 C3        TRI_BYTE        SMB7    TEMP2           ;Set Flag bit for 3-byte instruction
  1426 00:E738: 20 77 E7     TWO_BYTE        JSR     GET_NEXT        ;Read, display operand byte
  1427 00:E73B: 85 C8                        STA     CRCLO           ;Save operand byte in CRCLO
  1428 00:E73D: 7F C3 0A                     BBR7    TEMP2,2BYTSPC   ;Branch for 2-byte is clear
  1429 00:E740: 20 77 E7                     JSR     GET_NEXT        ;Read, display operand high byte
  1430 00:E743: 85 C7                        STA     CRCHI           ;Save operand high byte in CRCHI
  1431 00:E745: 80 06                        BRA     3BYTSPC         ;Send 2 spaces, send Mnemonic, return
  1432                        ;
  1433                        ;IMPLIED disassembler handler: single byte instructions: implied mode
  1434                        ; (note: ACC_MODE handler calls this)
  1435 00:E747: 20 EF E1     IMPLIED         JSR     SPC4            ;Send 4 spaces
  1436 00:E74A: 20 EF E1     2BYTSPC         JSR     SPC4            ;Send 4 spaces
  1437 00:E74D: 20 F2 E1     3BYTSPC         JSR     SPC2            ;Send 2 spaces
  1438                        ;
  1439                        ;PRT_MNEM subroutine: send 3 character mnemonic to terminal
  1440                        ; Mnemonic indexed by opcode byte. Sends "???" if byte is not a valid opcode
  1441 00:E750: A4 C6        PRT_MNEM        LDY     OPXMDM          ;Get current Opcode as index
  1442 00:E752: BE 48 F3                     LDX     MNE_PTAB,Y      ;Get opcode pointer from table
  1443 00:E755: BD 48 F4                     LDA     DIS_NMEM,X      ;Get left byte
  1444 00:E758: 85 CA                        STA     PTRL            ;Store it to pointer
  1445 00:E75A: BD 49 F4                     LDA     DIS_NMEM+1,X    ;Get right byte
  1446 00:E75D: 85 CB                        STA     PTRH            ;Store it to pointer
  1447 00:E75F: A2 03                        LDX     #$03            ;Set count for 3 characters
  1448 00:E761: A9 00        NEXT_NME        LDA     #$00            ;Zero A Reg
  1449 00:E763: A0 05                        LDY     #$05            ;Set count for 5 bits per character
  1450 00:E765: 06 CB        LOOP_NME        ASL     PTRH            ;Shift right byte into carry
  1451 00:E767: 26 CA                        ROL     PTRL            ;Rotate left byte into A Reg
  1452 00:E769: 2A                           ROL     A               ;Rotate into A Reg
  1453 00:E76A: 88                           DEY                     ;Decrement bit count
  1454 00:E76B: D0 F8                        BNE     LOOP_NME        ;Loop back till 5 bits in A Reg
  1455 00:E76D: 69 3F                        ADC     #$3F            ;Add $3F to convert to Ascii
  1456 00:E76F: 20 3C FF                     JSR     B_CHROUT        ;Send the character to terminal
  1457 00:E772: CA                           DEX                     ;Decrement character count
  1458 00:E773: D0 EC                        BNE     NEXT_NME        ;Loop back till 3 characters sent
  1459 00:E775: 80 06                        BRA     BR_SPC2         ;Send 2 spaces to terminal, return
  1460                        ;
  1461                        ;GET_NEXT subroutine: increment/read working address
  1462                        ; Display byte, send 2 spaces to terminal (displays operand byte(s))
  1463 00:E777: 20 2D E7     GET_NEXT        JSR     INCNDX          ;Increment working index
  1464 00:E77A: 20 27 E2     PRB_SPC2        JSR     PRBYTE          ;Display Byte from working index
  1465 00:E77D: 4C F2 E1     BR_SPC2         JMP     SPC2            ;Send 2 spaces to terminal and return
  1466                        ;
  1467                        ;Disassembler handlers:
  1468                        ;
  Thu Mar 16 2023 11:46                                                                                                    Page 31


  1469                        ;LF_BRKT subroutine: send "(" to terminal
  1470 00:E780: A9 28        LF_BRKT         LDA     #$28            ;Get "("
  1471 00:E782: 80 0F                        BRA     BR_COUT         ;Send to terminal and return
  1472                        ;
  1473                        ;ZP_IMMEDIATE: two byte instructions: zero-page immediate mode
  1474 00:E784: 20 38 E7     ZP_IMED         JSR     TWO_BYTE        ;Display operand byte, then mnemonic
  1475 00:E787: A9 23                        LDA     #$23            ;Get "#" character
  1476 00:E789: 20 3C FF                     JSR     B_CHROUT        ;Send to terminal
  1477 00:E78C: 80 1B                        BRA     PRT1_OP         ;Display operand byte again, return
  1478                        ;
  1479                        ;ACC_MODE: single byte A Reg mode instructions: implied mode
  1480 00:E78E: 20 47 E7     ACC_MODE        JSR     IMPLIED         ;Send 10 spaces to terminal then display mnemonic
  1481 00:E791: A9 41                        LDA     #$41            ;Get "A" character
  1482 00:E793: 4C 3C FF     BR_COUT         JMP     B_CHROUT        ;Send it and return
  1483                        ;
  1484                        ;ABSOLUTE: three byte instructions: absolute mode
  1485 00:E796: 20 36 E7     ABSOLUTE        JSR     TRI_BYTE        ;Display operand bytes, then mnemonic
  1486                        ;
  1487                        ;Print 2 Operands: display operand bytes of a three-byte instruction
  1488 00:E799: 20 FA E1     PRT2_OP         JSR     DOLLAR          ;Send "$" to terminal
  1489 00:E79C: A5 C7                        LDA     CRCHI           ;Load operand high byte
  1490 00:E79E: 20 27 E2                     JSR     PRBYTE          ;Send to terminal
  1491 00:E7A1: A5 C8        BR_PRBTE        LDA     CRCLO           ;Load operand low byte
  1492 00:E7A3: 4C 27 E2                     JMP     PRBYTE          ;Send to terminal and return
  1493                        ;
  1494                        ;ZP_ABS: two byte instructions: zero-page absolute
  1495 00:E7A6: 20 38 E7     ZP_ABS          JSR     TWO_BYTE        ;Display operand byte, then mnemonic
  1496                        ;
  1497                        ;Print 1 Operand byte: display operand byte of a two-byte instruction
  1498 00:E7A9: 20 FA E1     PRT1_OP         JSR     DOLLAR          ;Send "$" to terminal
  1499 00:E7AC: 80 F3                        BRA     BR_PRBTE        ;Branch to complete
  1500                        ;
  1501                        ;INDIRECT: two or three byte instructions: indirect modes
  1502 00:E7AE: A5 C6        INDIRECT        LDA     OPXMDM          ;Read saved opcode byte
  1503 00:E7B0: C9 6C                        CMP     #$6C            ;Check for JMP(INDIRECT)
  1504 00:E7B2: D0 13                        BNE     ZP_IND          ;Branch if not
  1505                        ;
  1506 00:E7B4: 20 36 E7                     JSR     TRI_BYTE        ;Display operand bytes, then mnemonic
  1507 00:E7B7: 20 80 E7                     JSR     LF_BRKT         ;Send "(" to terminal
  1508 00:E7BA: 20 99 E7                     JSR     PRT2_OP         ;Display operand bytes again
  1509 00:E7BD: 80 0B                        BRA     RT_BRKT         ;Send ")" to terminal, return
  1510                        ;
  1511                        ;Following group is used multiple times, space savings
  1512 00:E7BF: 20 38 E7     DSPLY3          JSR     TWO_BYTE        ;Display operand byte, then mnemonic
  1513 00:E7C2: 20 80 E7                     JSR     LF_BRKT         ;Send "(" to terminal
  1514 00:E7C5: 80 E2                        BRA     PRT1_OP         ;Display operand byte again, return
  1515                        ;
  1516                        ;this is for a two byte instruction: zero page indirect mode
  1517 00:E7C7: 20 BF E7     ZP_IND          JSR     DSPLY3          ;Do the 3 routines
  1518                        ;
  1519                        ;RT_BRKT subroutine: send ")" to terminal
  1520 00:E7CA: A9 29        RT_BRKT         LDA     #$29            ;Get ")"
  1521 00:E7CC: 80 C5                        BRA     BR_COUT         ;Send to terminal and return
  1522                        ;
  1523                        ;ZP_ABS_X: two byte instructions: zero-page absolute indexed by X mode
  1524 00:E7CE: 20 A6 E7     ZP_ABS_X        JSR     ZP_ABS          ;Display operand byte, mnemonic, operand byte
  1525                        ;
  1526                        ;Print Comma,X: send ",X" to terminal
  1527 00:E7D1: A9 2C        COM_X           LDA     #$2C            ;Get ","
  1528 00:E7D3: 20 3C FF                     JSR     B_CHROUT        ;Send to terminal
  1529 00:E7D6: A9 58                        LDA     #$58            ;Get "X"
  1530 00:E7D8: 80 B9                        BRA     BR_COUT         ;Send to terminal, return
  1531                        ;
  Thu Mar 16 2023 11:46                                                                                                    Page 32


  1532                        ;ZP_ABS_Y: two byte instructions: zero-page absolute indexed by Y mode
  1533 00:E7DA: 20 A6 E7     ZP_ABS_Y        JSR     ZP_ABS          ;Display operand byte, mnemonic, operand byte
  1534                        ;
  1535                        ;Print Comma,Y: send ",Y" to terminal
  1536 00:E7DD: A9 2C        COM_Y           LDA     #$2C            ;Get ","
  1537 00:E7DF: 20 3C FF                     JSR     B_CHROUT        ;Send to terminal
  1538 00:E7E2: A9 59                        LDA     #$59            ;Get "Y"
  1539 00:E7E4: 80 AD                        BRA     BR_COUT         ;Send to terminal, return
  1540                        ;
  1541                        ;ABS_Y: three byte instructions: absolute indexed by Y mode
  1542                        ;ABS_X: three byte instructions: absolute indexed by X mode
  1543 00:E7E6: E7 C3        ABS_Y           SMB6    TEMP2
  1544 00:E7E8: 20 36 E7     ABS_X           JSR     TRI_BYTE        ;Display operand bytes, then mnemonic
  1545 00:E7EB: 20 99 E7                     JSR     PRT2_OP         ;Display operand bytes again
  1546 00:E7EE: EF C3 EC                     BBS6    TEMP2,COM_Y
  1547 00:E7F1: 80 DE                        BRA     COM_X           ;Send ",X" to terminal, return
  1548                        ;
  1549                        ;ZP_IND_X: two byte instructions: zero-page indirect pre-indexed by X mode
  1550 00:E7F3: 20 BF E7     ZP_IND_X        JSR     DSPLY3          ;Do the 3 routines
  1551 00:E7F6: 20 D1 E7                     JSR     COM_X           ;Send ",X" to terminal
  1552 00:E7F9: 80 CF                        BRA     RT_BRKT         ;Send ")" to terminal, return
  1553                        ;
  1554                        ;ZP_IND_Y: two byte instructions: zero-page indirect post-indexed by Y mode
  1555 00:E7FB: 20 BF E7     ZP_IND_Y        JSR     DSPLY3          ;Do the 3 routines
  1556 00:E7FE: 20 CA E7                     JSR     RT_BRKT         ;Send ")" to terminal
  1557 00:E801: 80 DA                        BRA     COM_Y           ;Send ",Y" to terminal, return
  1558                        ;
  1559                        ;IND_ABS_X: three byte instruction: JMP (INDIRECT,X) 16 bit indirect
  1560 00:E803: 20 36 E7     IND_ABS_X       JSR     TRI_BYTE        ;Display operand bytes, then mnemonic
  1561 00:E806: 20 80 E7                     JSR     LF_BRKT         ;Send "(" to terminal
  1562 00:E809: 20 99 E7                     JSR     PRT2_OP         ;Display operand bytes again
  1563 00:E80C: 20 D1 E7                     JSR     COM_X           ;Send ",X" to terminal
  1564 00:E80F: 80 B9                        BRA     RT_BRKT         ;Send ")" to terminal,done w/INDABSX handler, return
  1565                        ;
  1566                        ;ZP_XMB: two byte instructions: zero page set/clear memory bit
  1567 00:E811: 20 72 E8     ZP_XMB          JSR     SRMB            ;Display operand/mnemonic, isolate bit selector from opcode
  1568 00:E814: C9 08                        CMP     #$08            ;Check if 0-7 or 8-F
  1569 00:E816: 90 02                        BCC     SRBIT           ;Just add $30 (0-7)
  1570 00:E818: E9 08                        SBC     #$08            ;Subtract $08 - convert $8-$F to $0-$7
  1571 00:E81A: 18           SRBIT           CLC                     ;Convert bit selector value to an ASCII decimal digit
  1572 00:E81B: 69 30                        ADC     #$30            ;Add "0" to bit selector value
  1573 00:E81D: 20 3C FF                     JSR     B_CHROUT        ;Send digit to terminal
  1574 00:E820: 20 F5 E1                     JSR     SPC             ;Send a space to terminal
  1575 00:E823: 80 84                        BRA     PRT1_OP         ;Display operand byte again then return
  1576                        ;
  1577                        ;ZP_BBX: three byte instruction: branch on zero-page bit set/clear
  1578 00:E825: 20 6A E8     ZP_BBX          JSR     SRMB2           ;Display operand/mnemonic, isolate bit selector from opcode
  1579 00:E828: C9 08                        CMP     #$08            ;Check if $0-$7 or $8-$F
  1580 00:E82A: 90 02                        BCC     SRBIT2          ;Just add $30 ($0-$7)
  1581 00:E82C: E9 08                        SBC     #$08            ;Subtract $08 - convert $8-$F to $0-$7
  1582 00:E82E: 20 1A E8     SRBIT2          JSR     SRBIT           ;Convert and display bit selector digit
  1583 00:E831: A5 C7                        LDA     CRCHI           ;Move second operand to first operand position:
  1584 00:E833: 85 C8                        STA     CRCLO           ;CRCLO = branch offset
  1585 00:E835: 20 F5 E1                     JSR     SPC             ;Send a space to terminal
  1586 00:E838: 80 03                        BRA     BBX_REL         ;Display branch target address then return
  1587                        ;
  1588                        ;RELATIVE BRANCH: two byte relative branch mode BBX_REL: three byte relative branch mode
  1589                        ; Both calculate then display relative branch target address
  1590                        ;
  1591                        ; Update 12th February 2021: Fix offset page for Branch. High byte address would not
  1592                        ; update properly and could show the wrong page.
  1593 00:E83A: 20 38 E7     REL_BRA         JSR     TWO_BYTE        ;Display operand byte, then mnemonic
  1594 00:E83D: 20 FA E1     BBX_REL         JSR     DOLLAR          ;Send "$" to terminal
  Thu Mar 16 2023 11:46                                                                                                    Page 33


  1595 00:E840: 20 D0 E1                     JSR     INCINDEX        ;Increment address, ref for branch offset
  1596 00:E843: A5 C8                        LDA     CRCLO           ;Get branch operand value
  1597 00:E845: 30 0C                        BMI     BRA_MINUS       ;Check for $80 or higher (branch is + / -)
  1598 00:E847: 18                           CLC                     ;Clear carry for add
  1599 00:E848: 65 B0                        ADC     INDEXL          ;Add to Index lo
  1600 00:E84A: 48                           PHA                     ;Save result to Stack
  1601 00:E84B: A5 B1                        LDA     INDEXH          ;Get Index Hi
  1602 00:E84D: 69 00                        ADC     #$00            ;Add result from Carry flag to A Reg
  1603 00:E84F: A8                           TAY                     ;Xfer Hi address to Y Reg
  1604 00:E850: 68                           PLA                     ;Get Lo Address from Stack
  1605 00:E851: 80 11                        BRA     REL_EXT         ;Print offset, cleanup, return
  1606 00:E853: 49 FF        BRA_MINUS       EOR     #$FF            ;Get 1's complement of offset
  1607 00:E855: 1A                           INC     A               ;Increment by 1
  1608 00:E856: 85 C4                        STA     TEMP3           ;Save result
  1609 00:E858: 38                           SEC                     ;Set carry for subtract
  1610 00:E859: A5 B0                        LDA     INDEXL          ;Get address Low byte
  1611 00:E85B: E5 C4                        SBC     TEMP3           ;Subtract branch offset
  1612 00:E85D: 48                           PHA                     ;Save result to Stack
  1613 00:E85E: A5 B1                        LDA     INDEXH          ;Get address High byte
  1614 00:E860: E9 00                        SBC     #$00            ;Subtract carry flag
  1615 00:E862: A8                           TAY                     ;Xfer Hi address to Y Reg
  1616 00:E863: 68                           PLA                     ;Get Lo address from Stack
  1617 00:E864: 20 3D E2     REL_EXT         JSR     PRWORD          ;Send address to terminal
  1618 00:E867: 4C C7 E1                     JMP     DECINDEX        ;Decrement working address, return
  1619                        ;
  1620                        ;SRMB2 subroutine: display 2 operand bytes, mnemonic, isolate bit selector from opcode
  1621                        ; SRMB subroutine: display 1 operand byte, mnemonic, isolate bit selector from opcode
  1622 00:E86A: B2 B0        SRMB2           LDA     (INDEXL)        ;Read from working index
  1623 00:E86C: 48                           PHA                     ;Save byte to stack
  1624 00:E86D: 20 36 E7                     JSR     TRI_BYTE        ;Display operand bytes and mnemonic
  1625 00:E870: 80 06                        BRA     SRM             ;Skip down
  1626 00:E872: B2 B0        SRMB            LDA     (INDEXL)        ;Read from working index
  1627 00:E874: 48                           PHA                     ;Save byte on STACK
  1628 00:E875: 20 38 E7                     JSR     TWO_BYTE        ;Display operand byte and mnemonic
  1629 00:E878: 20 EA E1     SRM             JSR     BSOUT2T         ;Send 2 Backspaces
  1630 00:E87B: 68                           PLA                     ;Restore byte from stack
  1631 00:E87C: 4A                           LSR     A               ;Shift high nibble to low nibble
  1632 00:E87D: 4A                           LSR     A
  1633 00:E87E: 4A                           LSR     A
  1634 00:E87F: 4A                           LSR     A
  1635 00:E880: 60                           RTS                     ;Done SRMB2/SRMB, return
  1636                        ;
  1637                        ;[CNTRL-E] EEPROM Edit
  1638                        ; Allows editing of a single byte location within the EEPROM starting at $8000.
  1639                        ; Note that this routines tests for target addresses at $8000 or above, but does NOT
  1640                        ; test for I/O address ranges. One should be cautious about editing the EEPROM directly
  1641                        ; to ensure it doesn't become unusable by changing things wrongly.
  1642                        ;
  1643                        ; NOTE: If the PLD memory configuration is changed to increase RAM and decrease EEPROM,
  1644                        ;       the unlock code will not work correctly, as the minimum addressable EEPROM is
  1645                        ;       22KB. This is the case with the current configuration used here... 56KB of RAM
  1646                        ;       and 8KB of EEPROM.
  1647                        ;
  1648 00:E881: A9 C3        EEDIT           LDA     #<TEMP2         ;Get address offset for TEMP2
  1649 00:E883: 85 B8                        STA     SRCL            ;Store in Source address Low
  1650 00:E885: 64 B9                        STZ     SRCH            ;Zero Source address High (Page Zero)
  1651                        ;
  1652                        ;Xfer byte write code to RAM for execution
  1653 00:E887: 20 E0 E3                     JSR     XFER_BYTE_WRT   ;Xfer byte write code to Page Zero
  1654                        ;
  1655 00:E88A: A9 2A                        LDA     #$2A            ;Get EEPROM edit msg
  1656 00:E88C: 20 01 E1     TRY_AGAIN       JSR     PROMPT          ;Send to console
  1657                        ;
  Thu Mar 16 2023 11:46                                                                                                    Page 34


  1658 00:E88F: 20 47 E2     CMP_OK2         JSR     CONTINUE        ;Prompt User for Y/N
  1659 00:E892: 20 02 E2                     JSR     CROUT           ;Send CR/LF to console
  1660                        ;
  1661 00:E895: A9 03                        LDA     #$03            ;Get " addr:" msg
  1662 00:E897: 20 24 E1                     JSR     HEX4            ;Display msg and get address
  1663                        ;
  1664                        ; Note: address in INDEXL/INDEXH and A/Y Regs
  1665 00:E89A: 85 BA                        STA     TGTL            ;Store in Target location Low
  1666 00:E89C: 84 BB                        STY     TGTH            ;Store in Target location High
  1667 00:E89E: C0 80                        CPY     #$80            ;Check for ROM start or higher
  1668 00:E8A0: 90 1D                        BCC     NOT_ROM         ;Address is not in EEPROM
  1669                        ;
  1670 00:E8A2: 20 F2 E1                     JSR     SPC2            ;Send 2 spaces
  1671 00:E8A5: B2 B0                        LDA     (INDEXL)        ;Get memory data
  1672 00:E8A7: 20 27 E2                     JSR     PRBYTE          ;Send to console
  1673 00:E8AA: 20 E7 E1                     JSR     BSOUT3T         ;Backspace 3 times
  1674 00:E8AD: 20 34 E1                     JSR     HEXIN2          ;Get new data
  1675                        ;
  1676                        ; Note: new data is in A Reg
  1677 00:E8B0: 85 C3                        STA     TEMP2           ;Store in Temp location
  1678                        ;
  1679 00:E8B2: 20 70 00                     JSR     BURN_BYTE       ;Update EEPROM Data
  1680 00:E8B5: B2 B8                        LDA     (SRCL)          ;Get Source byte
  1681 00:E8B7: D2 BA                        CMP     (TGTL)          ;Compare to Target in EEPROM
  1682 00:E8B9: F0 D4                        BEQ     CMP_OK2         ;Branch if okay
  1683 00:E8BB: A9 1F                        LDA     #$1F            ;Else, get error msg for failed write
  1684 00:E8BD: 80 73                        BRA     PRMPTSC         ;Send to console and exit
  1685                        ;
  1686 00:E8BF: A9 2B        NOT_ROM         LDA     #$2B            ;Get address range msg
  1687 00:E8C1: 20 01 E1                     JSR     PROMPT          ;Send to console
  1688 00:E8C4: A9 2C                        LDA     #$2C            ;Get EEPROM msg
  1689 00:E8C6: 80 C4                        BRA     TRY_AGAIN       ;Branch back and try again
  1690                        ;
  1691                        ;[CNTRL-Q] Query command:
  1692 00:E8C8: A9 49        QUERY           LDA     #$49            ;Get Query Commands Message
  1693 00:E8CA: 80 66                        BRA     PRMPTSC         ;Send to console and return
  1694                        ;
  1695                        ;[CNTL-T] DATE/TIME command: Sends a string to the console showing the current Date and Time
  1696                        ; Displays software RTC values for Date and Time as:
  1697                        ;  Date: SUN Sep 15, 2020 Time: 12:34:56
  1698                        ;
  1699 00:E8CC: A9 30        TIME            LDA     #$30            ;Get "Date: " message
  1700 00:E8CE: 20 01 E1                     JSR     PROMPT          ;Send to console
  1701                        ;
  1702 00:E8D1: A5 E8                        LDA     DAY_DATE        ;Get Day and Date data
  1703 00:E8D3: 4A                           LSR     A               ;Move Day to lower 3 bits
  1704 00:E8D4: 4A                           LSR     A
  1705 00:E8D5: 4A                           LSR     A
  1706 00:E8D6: 4A                           LSR     A
  1707 00:E8D7: 4A                           LSR     A
  1708 00:E8D8: 18                           CLC                     ;Clear carry
  1709 00:E8D9: 69 30                        ADC     #$30            ;Add offset to MSG #
  1710 00:E8DB: 20 01 E1                     JSR     PROMPT          ;Send to console
  1711 00:E8DE: 20 F5 E1                     JSR     SPC             ;Send an ASCII space
  1712                        ;
  1713 00:E8E1: A5 E9                        LDA     MONTH_CENTURY   ;Get Month and Century
  1714 00:E8E3: 4A                           LSR     A               ;Move Month to lower 4 bits
  1715 00:E8E4: 4A                           LSR     A
  1716 00:E8E5: 4A                           LSR     A
  1717 00:E8E6: 4A                           LSR     A
  1718 00:E8E7: 18                           CLC                     ;Clear Carry
  1719 00:E8E8: 69 37                        ADC     #$37            ;Add offset to MSG #
  1720 00:E8EA: 20 01 E1                     JSR     PROMPT          ;Send to console
  Thu Mar 16 2023 11:46                                                                                                    Page 35


  1721 00:E8ED: 20 F5 E1                     JSR     SPC             ;Send an ASCII space
  1722                        ;
  1723 00:E8F0: A5 E8                        LDA     DAY_DATE        ;Get Day and Date data
  1724 00:E8F2: 29 1F                        AND     #%00011111      ;Mask off Day of week
  1725 00:E8F4: A2 45                        LDX     #$45            ;Get MSG for ", "
  1726 00:E8F6: 20 19 E9                     JSR     DO8TIME         ;Convert and send to console
  1727                        ;
  1728 00:E8F9: A5 E9                        LDA     MONTH_CENTURY   ;Get Month and Year data
  1729 00:E8FB: 29 0F                        AND     #%00001111      ;Mask off Month
  1730 00:E8FD: A8                           TAY                     ;Xfer to Y Reg
  1731 00:E8FE: A5 EA                        LDA     YEAR            ;Get Year low byte
  1732 00:E900: A2 46                        LDX     #$46            ;Get MSG for " Time: "
  1733 00:E902: 20 1B E9                     JSR     DO16TIME        ;Convert and send to console
  1734                        ;
  1735 00:E905: A2 44                        LDX     #$44            ;Get ":" message
  1736 00:E907: A5 E7                        LDA     HOURS           ;Get Current Hours (low byte)
  1737 00:E909: 20 22 E9                     JSR     DO8LZ           ;Convert and send to console
  1738                        ;
  1739 00:E90C: A2 44                        LDX     #$44            ;Get ":" message
  1740 00:E90E: A5 E6                        LDA     MINS            ;Get Current Minutes (low byte)
  1741 00:E910: 20 22 E9                     JSR     DO8LZ           ;Convert and send to console
  1742                        ;
  1743 00:E913: A2 47                        LDX     #$47            ;Get " " message
  1744 00:E915: A5 E5                        LDA     SECS            ;Get Current Seconds (low byte)
  1745 00:E917: 80 09                        BRA     DO8LZ           ;Convert to console and return
  1746                        ;
  1747 00:E919: A0 00        DO8TIME         LDY     #$00            ;Zero high byte
  1748 00:E91B: DA           DO16TIME        PHX                     ;Push message number to stack
  1749 00:E91C: 20 D5 E0                     JSR     HEX2ASC         ;Convert and print ASCII string
  1750 00:E91F: 68                           PLA                     ;Pull message number from stack
  1751 00:E920: 80 10                        BRA     PRMPTSC         ;Send to console and return
  1752                        ;
  1753 00:E922: DA           DO8LZ           PHX                     ;Push message number to stack
  1754 00:E923: 20 BF E0                     JSR     HEX8ASC         ;Convert and print ASCII string with leading zero
  1755 00:E926: 68                           PLA                     ;Pull message number from stack
  1756 00:E927: 80 09                        BRA     PRMPTSC         ;Send to console and return
  1757                        ;
  1758                        ;[CNTRL-V] Version command:
  1759 00:E929: A0 FF        VER             LDY     #>BIOS_MSG      ;Get high offset
  1760 00:E92B: A9 D0                        LDA     #<BIOS_MSG      ;Get low offset
  1761 00:E92D: 20 09 E1                     JSR     PROMPTR         ;Show BIOS version
  1762 00:E930: A9 15                        LDA     #$15            ;Get Intro substring (version)
  1763 00:E932: 4C 01 E1     PRMPTSC         JMP     PROMPT          ;Send to console and return
  1764                        ;
  1765                        ;[CNTRL-L] Xmodem/CRC Load command: receives a file from console via Xmodem protocol. No cable
  1766                        ; swapping needed, uses Console port and buffer via the terminal program. Not a full Xmodem/CRC
  1767                        ; implementation, only does CRC-16 checking, no fallback. Designed for direct attach to host
  1768                        ; machine via com port. Can handle full 8-bit binary transfers without errors.
  1769                        ; Tested with: ExtraPutty (Windows 7 Pro) and Serial (OSX).
  1770                        ;
  1771                        ;Added support for Motorola S-Record formatted files automatically. Default load address is $0800.
  1772                        ; An input parameter is used as a Load Address (for non-S-Record files) or as a positive offset for
  1773                        ; any S-Record formatted file. The supported S-Record format is S19 as created by WDC Tools Linker.
  1774                        ; Note: this code supports the execution address in the final S9 record, but WDC Tools does not
  1775                        ; provide any ability to put this into their code build. WDC are aware of this.
  1776 00:E935: F7 C5        XMODEML         SMB7    CMDFLAG         ;Set bit7 of command flag
  1777 00:E937: 64 C6                        STZ     OPXMDM          ;Clear Xmodem flag
  1778 00:E939: A9 01                        LDA     #$01            ;Set block count to one
  1779 00:E93B: 85 CC                        STA     BLKNO           ;Save it for starting block #
  1780                        ;
  1781 00:E93D: A9 22                        LDA     #$22            ;Get Xmodem intro msg
  1782 00:E93F: 20 24 E1                     JSR     HEX4            ;Print Msg, get Hex load address/S-record Offset
  1783 00:E942: D0 03                        BNE     XLINE           ;Branch if data entered (Z flag set from HEX4/HEXINPUT)
  Thu Mar 16 2023 11:46                                                                                                    Page 36


  1784 00:E944: 8A                           TXA                     ;Xfer X Reg to A Reg (LDA #$00)
  1785 00:E945: A0 08                        LDY     #$08            ;Set High byte ($0800)
  1786 00:E947: 85 CA        XLINE           STA     PTRL            ;Store to Lo pointer
  1787 00:E949: 84 CB                        STY     PTRH            ;Store to Hi pointer
  1788                        ;
  1789                        XMDM_LOAD ;Entry point for an external program to load data via Xmodem CRC
  1790                        ; To use this routine, the external program must setup the variables above which include
  1791                        ; the starting address (PTRL/H), clear the OPXMDM flag and set the Block count to one.
  1792                        ; Once completed, the message to setup the terminal program is displayed and the user
  1793                        ; needs to setup the terminal to send data via a filename.
  1794                        ;
  1795                        ; A 5 seconds delay is started to allow the user time to navigate to the file to be sent.
  1796 00:E94B: A9 24                        LDA     #$24            ;Get Terminal Setup msg
  1797 00:E94D: 20 01 E1                     JSR     PROMPT          ;Send to console
  1798                        ;
  1799                        ;Wait for 5 seconds for user to setup xfer from terminal
  1800 00:E950: A9 01                        LDA     #$01            ;Set milliseconds to 1(*10 ms)
  1801 00:E952: A2 01                        LDX     #$01            ;Set 16-bit multiplier
  1802 00:E954: A0 F4                        LDY     #$F4            ;to 500 decimal ($1F4)
  1803 00:E956: 20 3F FF                     JSR     B_SET_DLY       ;Set Delay parameters
  1804 00:E959: 20 45 FF                     JSR     B_EXE_LGDLY     ;Call long delay for 5 seconds
  1805                        ;
  1806 00:E95C: A9 43        STRT_XFER       LDA     #"C"            ;Send "C" character for CRC mode
  1807 00:E95E: 20 3C FF                     JSR     B_CHROUT        ;Send to terminal
  1808 00:E961: A0 32                        LDY     #50             ;Set loop count to 50
  1809 00:E963: 20 42 FF     CHR_DLY         JSR     B_EXE_MSDLY     ;Delay 1*(10ms)
  1810 00:E966: A5 D7                        LDA     ICNT_A          ;Check input buffer count
  1811 00:E968: D0 35                        BNE     STRT_BLK        ;If a character is in, branch
  1812 00:E96A: 88                           DEY                     ;Decrement loop count
  1813 00:E96B: D0 F6                        BNE     CHR_DLY         ;Branch and check again
  1814 00:E96D: 80 ED                        BRA     STRT_XFER       ;Else, branch and send another "C"
  1815                        ;
  1816 00:E96F: A9 06        XDONE           LDA     #ACK            ;Last block, get ACK character
  1817 00:E971: 20 3C FF                     JSR     B_CHROUT        ;Send final ACK
  1818 00:E974: A0 02                        LDY     #$02            ;Get delay count
  1819 00:E976: A9 25                        LDA     #$25            ;Get Good xfer message number
  1820 00:E978: 20 BD E2     FLSH_DLY        JSR     NOLOOPS         ;Zero input buffer pointers
  1821 00:E97B: 48                           PHA                     ;Save Message number
  1822 00:E97C: A9 19                        LDA     #$19            ;Load milliseconds = 250 ms (25x10ms)
  1823 00:E97E: A2 00                        LDX     #$00            ;Load High multiplier to 0 decimal
  1824 00:E980: 20 3F FF                     JSR     B_SET_DLY       ;Set Delay parameters
  1825 00:E983: 20 45 FF                     JSR     B_EXE_LGDLY     ;Execute delay, (wait to get terminal back)
  1826 00:E986: 68                           PLA                     ;Get message number back
  1827 00:E987: C9 26                        CMP     #$26            ;Check for error msg#
  1828 00:E989: F0 11                        BEQ     SHRT_EXIT       ;Do only one message
  1829 00:E98B: 48                           PHA                     ;Save MSG number
  1830 00:E98C: 7F C6 0C                     BBR7    OPXMDM,END_LOAD ;Branch if no S-Record
  1831 00:E98F: A9 27                        LDA     #$27            ;Get S-Record load address msg
  1832 00:E991: 20 01 E1                     JSR     PROMPT          ;Printer header msg
  1833 00:E994: A5 B8                        LDA     SRCL            ;Get source Low byte
  1834 00:E996: A4 B9                        LDY     SRCH            ;Get source High byte
  1835 00:E998: 20 3D E2                     JSR     PRWORD          ;Print Hex address
  1836 00:E99B: 68           END_LOAD        PLA                     ;Get Message number
  1837 00:E99C: 4C 01 E1     SHRT_EXIT       JMP     PROMPT          ;Print Message and exit
  1838                        ;
  1839 00:E99F: 20 39 FF     STRT_BLK        JSR     B_CHRIN         ;Get a character
  1840 00:E9A2: C9 1B                        CMP     #$1B            ;Is it escape - quit?
  1841 00:E9A4: F0 0A                        BEQ     XM_END          ;If yes, exit
  1842 00:E9A6: C9 01                        CMP     #SOH            ;Start of header?
  1843 00:E9A8: F0 07                        BEQ     GET_BLK         ;If yes, branch and receive block
  1844 00:E9AA: C9 04                        CMP     #EOT            ;End of Transmission?
  1845 00:E9AC: F0 C1                        BEQ     XDONE           ;If yes, branch and exit
  1846 00:E9AE: 80 3C                        BRA     STRT_ERR        ;Else branch to error
  Thu Mar 16 2023 11:46                                                                                                    Page 37


  1847 00:E9B0: 60           XM_END          RTS                     ;Cancelled by user, return
  1848                        ;
  1849 00:E9B1: A2 00        GET_BLK         LDX     #$00            ;Zero index for block receive
  1850                        ;
  1851 00:E9B3: 20 39 FF     GET_BLK1        JSR     B_CHRIN         ;Get a character
  1852 00:E9B6: 9D 7C 03                     STA     RBUFF,X         ;Move into buffer
  1853 00:E9B9: E8                           INX                     ;Increment buffer index
  1854 00:E9BA: E0 84                        CPX     #$84            ;Compare size (<01><FE><128 bytes><CRCH><CRCL>)
  1855 00:E9BC: D0 F5                        BNE     GET_BLK1        ;If not done, loop back and continue
  1856                        ;
  1857 00:E9BE: AD 7C 03                     LDA     RBUFF           ;Get block number from buffer
  1858 00:E9C1: C5 CC                        CMP     BLKNO           ;Compare to expected block number
  1859 00:E9C3: D0 07                        BNE     RESTRT          ;If not correct, restart the block
  1860 00:E9C5: 49 FF                        EOR     #$FF            ;Create one's complement of block number
  1861 00:E9C7: CD 7D 03                     CMP     RBUFF+1         ;Compare with rcv'd value for block number
  1862 00:E9CA: F0 07                        BEQ     BLK_OKAY        ;Branch if compare is good
  1863                        ;
  1864 00:E9CC: A9 15        RESTRT          LDA     #NAK            ;Get NAK character
  1865 00:E9CE: 20 3C FF     RESTRT2         JSR     B_CHROUT        ;Send to xfer program
  1866 00:E9D1: 80 CC                        BRA     STRT_BLK        ;Restart block transfer
  1867                        ;
  1868 00:E9D3: A9 0A        BLK_OKAY        LDA     #$0A            ;Set retry value to 10
  1869 00:E9D5: 85 C9                        STA     CRCCNT          ;Save it to CRC retry count
  1870                        ;
  1871 00:E9D7: 20 B4 EB                     JSR     CRC16_GEN       ;Generate CRC16 from Buffer data
  1872                        ;
  1873 00:E9DA: B9 7E 03                     LDA     RBUFF+2,Y       ;Get received CRC hi byte (4)
  1874 00:E9DD: C5 C7                        CMP     CRCHI           ;Compare against calculated CRC hi byte (3)
  1875 00:E9DF: D0 07                        BNE     BADCRC          ;If bad CRC, handle error (2/3)
  1876 00:E9E1: B9 7F 03                     LDA     RBUFF+3,Y       ;Get CRC lo byte (4)
  1877 00:E9E4: C5 C8                        CMP     CRCLO           ;Compare against calculated CRC lo byte (3)
  1878 00:E9E6: F0 15                        BEQ     GOODCRC         ;If good, go move frame to memory (2/3)
  1879                        ;
  1880                        ;CRC was bad! Need to retry and receive the last frame again. Decrement the CRC retry count,
  1881                        ; send a NAK and try again. Count allows up to 10 retries, then cancels the transfer.
  1882 00:E9E8: C6 C9        BADCRC          DEC     CRCCNT          ;Decrement retry count
  1883 00:E9EA: D0 0C                        BNE     CRCRTRY         ;Retry again if count not zero
  1884 00:E9EC: A9 18        STRT_ERR        LDA     #CAN            ;Else get Cancel code
  1885 00:E9EE: 20 3C FF                     JSR     B_CHROUT        ;Send it to terminal program
  1886 00:E9F1: A0 08                        LDY     #$08            ;Set delay multiplier
  1887 00:E9F3: A9 26                        LDA     #$26            ;Get message for receive error
  1888 00:E9F5: 4C 78 E9                     JMP     FLSH_DLY        ;Do a flush, delay and exit
  1889 00:E9F8: 20 BD E2     CRCRTRY         JSR     NOLOOPS         ;Zero Input buffer pointers
  1890 00:E9FB: 80 CF                        BRA     RESTRT          ;Send NAK and retry
  1891                        ;
  1892                        ;Block has been received, check for S19 record transfer
  1893 00:E9FD: FF C6 2D     GOODCRC         BBS7    OPXMDM,XFER_S19 ;Branch if bit 7 set (active S-record)
  1894 00:EA00: A5 CC                        LDA     BLKNO           ;Else, check current block number
  1895 00:EA02: 3A                           DEC     A               ;Check for block 1 only (first time thru)
  1896 00:EA03: F0 16                        BEQ     TEST_S19        ;If yes, test for S19 record
  1897                        ;
  1898 00:EA05: A2 00        MOVE_BLK        LDX     #$00            ;Zero index offset to data
  1899 00:EA07: BD 7E 03     COPYBLK         LDA     RBUFF+2,X       ;Get data byte from buffer
  1900 00:EA0A: 92 CA                        STA     (PTRL)          ;Store to target address
  1901 00:EA0C: E6 CA                        INC     PTRL            ;Increment low address byte
  1902 00:EA0E: D0 02                        BNE     COPYBLK2        ;Check for hi byte loop
  1903 00:EA10: E6 CB                        INC     PTRH            ;Increment hi byte address
  1904 00:EA12: E8           COPYBLK2        INX                     ;Point to next data byte
  1905 00:EA13: 10 F2                        BPL     COPYBLK         ;Loop back until done (128)
  1906 00:EA15: E6 CC        INCBLK          INC     BLKNO           ;Increment block number
  1907 00:EA17: A9 06                        LDA     #ACK            ;Get ACK character
  1908 00:EA19: 80 B3                        BRA     RESTRT2         ;Send ACK and continue xfer
  1909                        ;
  Thu Mar 16 2023 11:46                                                                                                    Page 38


  1910 00:EA1B: AD 7E 03     TEST_S19        LDA     RBUFF+2         ;Get first character
  1911 00:EA1E: C9 53                        CMP     #"S"            ;Check for S character
  1912 00:EA20: D0 E3                        BNE     MOVE_BLK        ;If not equal, no S-record, move block
  1913 00:EA22: AD 7F 03                     LDA     RBUFF+3         ;Get second character
  1914 00:EA25: C9 31                        CMP     #"1"            ;Check for 1 character
  1915 00:EA27: D0 DC                        BNE     MOVE_BLK        ;If not equal, no S-record, move block
  1916 00:EA29: F7 C6                        SMB7    OPXMDM          ;Set bit 7 for S-record xfer
  1917 00:EA2B: 64 C1                        STZ     IDY             ;Zero index for SRBUFF
  1918                        ;
  1919                        ;S-Record transfer routine: Xmodem is a 128 byte data block, S-Record is variable, up to
  1920                        ; 44 bytes needed to move a record at a time to the SRBUFF based on length, check as valid,
  1921                        ; then calculate the address and transfer to that location. Once the Xmodem buffer is empty,
  1922                        ; loop back to get the next block and continue processing S-Records until completed.
  1923                        ;
  1924                        ;RBUFF is the full Xmodem block, which starts with the block number, one's compliment of the
  1925                        ; block number, followed by the 128-bytes of data. The data is confirmed as "S1", which validates
  1926                        ; the start of a S-Record format.
  1927                        ;
  1928                        ;At first entry here, pointer IDY is zero. At all entries here, a 128 byte block has been received.
  1929                        ; The S-record type and length needs to be calculated, then the proper count moved to the
  1930                        ; SRBUFF location and both pointers (IDX/IDY) are updated.
  1931                        ;
  1932                        ;S-Record format is as follows (44 bytes max):
  1933                        ; 2 bytes for type: "S1" or "S9" (ASCII text)
  1934                        ; 2 bytes for length (ASCII Hex) - includes load address, data and checksum (not CR/LF)
  1935                        ; 4 bytes for load address (ASCII Hex - 16-bit load address)
  1936                        ; 2-32 bytes for data (ASCII Hex - 1-16 bytes of data) - always an even number
  1937                        ; 2 bytes for checksum (ASCII Hex - 1 byte for checksum)
  1938                        ; 2 bytes for CR/LF
  1939                        ;
  1940                        ;First grab the 2 bytes for the length, convert to binary and transfer the correct count of
  1941                        ; data from RBUFF to SRBUFF. Note: increment count by two additional for CR/LF
  1942                        ; then update the running index into the 128 byte record (IDX) which points to the next record.
  1943                        ; minor update from Mike Barry, saves a byte.
  1944 00:EA2D: 64 C0        XFER_S19        STZ     IDX             ;Zero offset to RBUFF
  1945                        ;
  1946 00:EA2F: A6 C0        S19_LOOP2       LDX     IDX             ;Load current offset to RBUFF
  1947 00:EA31: A4 C1                        LDY     IDY             ;Get current offset SRBUFF
  1948 00:EA33: D0 11                        BNE     FIL_SRBUFF      ;Branch to complete RBUFF to SRBUFF xfer
  1949                        ;
  1950 00:EA35: BD 80 03                     LDA     RBUFF+4,X       ;Get first ASCII length character
  1951 00:EA38: BC 81 03                     LDY     RBUFF+5,X       ;Get second ASCII length character
  1952 00:EA3B: 20 93 E0                     JSR     ASC2BIN         ;Convert to binary length
  1953 00:EA3E: 1A                           INC     A               ;Increment length for "S1" or "S9"
  1954 00:EA3F: 1A                           INC     A               ;Increment length for "length characters"
  1955 00:EA40: 1A                           INC     A               ;Increment length for "CR/LF"
  1956 00:EA41: 0A                           ASL     A               ;Multiply by two for 2-characters per byte
  1957 00:EA42: 85 C4                        STA     TEMP3           ;Save total bytes to move to SRBUFF
  1958 00:EA44: A4 C1                        LDY     IDY             ;Get offset to SRBUFF
  1959                        ;
  1960 00:EA46: BD 7E 03     FIL_SRBUFF      LDA     RBUFF+2,X       ;Get S-Record data
  1961 00:EA49: 99 50 03                     STA     SRBUFF,Y        ;Move into SREC buffer
  1962 00:EA4C: E8                           INX                     ;Increment index to RBUFF
  1963 00:EA4D: E0 81                        CPX     #$81            ;Check for end of buffer
  1964 00:EA4F: F0 0E                        BEQ     NXT_FRAME       ;If yes, go receive another block into the buffer
  1965 00:EA51: C8                           INY                     ;Increment index to SRBUFF
  1966 00:EA52: C4 C4                        CPY     TEMP3           ;Compare to length
  1967 00:EA54: D0 F0                        BNE     FIL_SRBUFF      ;Loop back until the full record is moved to SRBUFF
  1968                        ;
  1969 00:EA56: 86 C0                        STX     IDX             ;Update running offset to RBUFF
  1970 00:EA58: 64 C1                        STZ     IDY             ;Reset SRBUFF index pointer (for next S-record xfer)
  1971 00:EA5A: 20 63 EA                     JSR     SREC_PROC       ;Process the S-Record in SRBUFF
  1972 00:EA5D: 80 D0                        BRA     S19_LOOP2       ;Branch back and get another S-Record
  Thu Mar 16 2023 11:46                                                                                                    Page 39


  1973                        ;
  1974 00:EA5F: 84 C1        NXT_FRAME       STY     IDY             ;Save SRBUFF offset
  1975 00:EA61: 80 B2        INCBLK2         BRA     INCBLK          ;Increment block and get next frame
  1976                        ;
  1977 00:EA63: AD 51 03     SREC_PROC       LDA     SRBUFF+1        ;Get the Record type character
  1978 00:EA66: C9 31                        CMP     #"1"            ;Check for S1 record
  1979 00:EA68: F0 54                        BEQ     S1_PROC         ;Process a S1 record
  1980 00:EA6A: C9 39                        CMP     #"9"            ;Check for S9 (final) record
  1981 00:EA6C: F0 3F                        BEQ     S9_PROC         ;Process a S9 record
  1982 00:EA6E: 68           SREC_ERR        PLA                     ;Else, pull return address
  1983 00:EA6F: 68                           PLA                     ;(two) bytes from stack
  1984 00:EA70: 4C EC E9                     JMP     STRT_ERR        ;Jump to Xmodem error/exit routine
  1985                        ;
  1986                        ;This routine will decode the SRBUFF ASCII data to binary data.
  1987                        ; As each byte is two ASCII characters, the result is half the length.
  1988                        ; TEMP3 contains the overall length from above, plus extra to add in the "S1" or "S9" and CR/LF
  1989                        ; so we need to decrement TEMP3 by two to correct the required length.
  1990 00:EA73: C6 C4        SR_PROC         DEC     TEMP3           ;Decrement length
  1991 00:EA75: C6 C4                        DEC     TEMP3           ;Decrement length
  1992                        ;
  1993 00:EA77: A2 00        SR_COMP         LDX     #$00            ;Zero Index
  1994 00:EA79: A0 00                        LDY     #$00            ;Zero Index
  1995 00:EA7B: 5A           SR_CMPLP        PHY                     ;Save Y Reg index
  1996 00:EA7C: BC 53 03                     LDY     SRBUFF+3,X      ;Get LS character
  1997 00:EA7F: BD 52 03                     LDA     SRBUFF+2,X      ;Get MS character
  1998 00:EA82: 20 93 E0                     JSR     ASC2BIN         ;Convert two ASCII characters to HEX byte
  1999 00:EA85: 7A                           PLY                     ;Restore Y Reg index
  2000 00:EA86: 99 50 03                     STA     SRBUFF,Y        ;Store in SRBUFF starting at front
  2001 00:EA89: E8                           INX                     ;Increment X Reg twice
  2002 00:EA8A: E8                           INX                     ;Points to next character pair
  2003 00:EA8B: C8                           INY                     ;Increment Y Reg once for offset to SRBUFF
  2004 00:EA8C: C6 C4                        DEC     TEMP3           ;Decrement character count
  2005 00:EA8E: D0 EB                        BNE     SR_CMPLP        ;Branch back until done
  2006                        ;
  2007                        ;SRBUFF now has the decoded HEX data, which is:
  2008                        ; 1 byte for length, 2 bytes for the load address, up to 16 bytes for data and 1 byte checksum
  2009                        ; Now calculate the checksum and ensure valid S-Record content
  2010 00:EA90: 64 C8                        STZ     CRCLO           ;Zero Checksum location
  2011 00:EA92: AE 50 03                     LDX     SRBUFF          ;Load index with record length
  2012 00:EA95: A0 00                        LDY     #$00            ;Zero index
  2013 00:EA97: 18           SR_CHKSM        CLC                     ;Clear carry for add
  2014 00:EA98: B9 50 03                     LDA     SRBUFF,Y        ;Get S-Record byte
  2015 00:EA9B: 65 C8                        ADC     CRCLO           ;Add in checksum Temp
  2016 00:EA9D: 85 C8                        STA     CRCLO           ;Update checksum Temp
  2017 00:EA9F: C8                           INY                     ;Increment offset
  2018 00:EAA0: CA                           DEX                     ;Decrement count
  2019 00:EAA1: D0 F4                        BNE     SR_CHKSM        ;Branch back until done
  2020                        ;
  2021 00:EAA3: A9 FF                        LDA     #$FF            ;Get all bits on
  2022 00:EAA5: 45 C8                        EOR     CRCLO           ;Exclusive OR TEMP for one's complement
  2023 00:EAA7: D9 50 03                     CMP     SRBUFF,Y        ;Compare to last byte (which is checksum)
  2024 00:EAAA: D0 C2                        BNE     SREC_ERR        ;If bad, exit out
  2025 00:EAAC: 60                           RTS                     ;Return to caller
  2026                        ;
  2027 00:EAAD: 20 73 EA     S9_PROC         JSR     SR_PROC         ;Process the S-Record and checksum
  2028 00:EAB0: AD 51 03                     LDA     SRBUFF+1        ;Get MSB load address
  2029 00:EAB3: 85 AF                        STA     COMHI           ;Store to execution pointer
  2030 00:EAB5: AD 52 03                     LDA     SRBUFF+2        ;Get LSB load address
  2031 00:EAB8: 85 AE                        STA     COMLO           ;Store to execution pointer
  2032 00:EABA: 68                           PLA                     ;Pull return address
  2033 00:EABB: 68                           PLA                     ;second byte
  2034 00:EABC: 80 A3                        BRA     INCBLK2         ;Branch back to close out transfer
  2035                        ;
  Thu Mar 16 2023 11:46                                                                                                    Page 40


  2036 00:EABE: 20 73 EA     S1_PROC         JSR     SR_PROC         ;Process the S-Record and checksum
  2037                        ;
  2038                        ;Valid binary S-Record decoded at SRBUFF. Calculate offset from input, add to specified load
  2039                        ; address and store into memory, then loop back until done. Offset is stored in PTR L/H from
  2040                        ; initial input. If no input entered, BUFIDX is zero and PTR L/H is preset to $0800, so checking
  2041                        ; for BUFIDX being zero bypasses adding the offset, if BUFIDX is non zero, then PTR L/H contains
  2042                        ; the offset address which is added to TGT L/H moving the S-Record data to memory.
  2043 00:EAC1: AD 51 03                     LDA     SRBUFF+1        ;Get MS load address
  2044 00:EAC4: 85 BB                        STA     TGTH            ;Store to target pointer
  2045 00:EAC6: AD 52 03                     LDA     SRBUFF+2        ;Get LS load address
  2046 00:EAC9: 85 BA                        STA     TGTL            ;Store to target pointer
  2047 00:EACB: A5 BE                        LDA     BUFIDX          ;Check input count for offset required
  2048 00:EACD: F0 11                        BEQ     NO_OFFSET       ;If Zero, no offset was entered
  2049                        ;
  2050                        ;Add in offset contained at PTR L/H to TGT L/H
  2051 00:EACF: 18                           CLC                     ;Clear carry for add
  2052 00:EAD0: A5 CA                        LDA     PTRL            ;Get LS offset
  2053 00:EAD2: 65 BA                        ADC     TGTL            ;Add to TGTL address
  2054 00:EAD4: 90 02                        BCC     SKIP_HB         ;Skip increment HB if no carry
  2055 00:EAD6: E6 BB                        INC     TGTH            ;Else increment TGTH by one
  2056 00:EAD8: 85 BA        SKIP_HB         STA     TGTL            ;Save TGTL
  2057 00:EADA: A5 CB                        LDA     PTRH            ;Get MS offset
  2058 00:EADC: 65 BB                        ADC     TGTH            ;Add to TGTH
  2059 00:EADE: 85 BB                        STA     TGTH            ;Save it
  2060                        ;
  2061                        ;Check for first Block and load SRC H/L with load address
  2062 00:EAE0: A5 CC        NO_OFFSET       LDA     BLKNO           ;Get Block number
  2063 00:EAE2: 3A                           DEC     A               ;Decrement to test for block one
  2064 00:EAE3: D0 0E                        BNE     NO_OFFST2       ;If not first block, skip around
  2065 00:EAE5: A5 C0                        LDA     IDX             ;Get running count for first block
  2066 00:EAE7: C9 2C                        CMP     #$2C            ;First S-record?
  2067 00:EAE9: D0 08                        BNE     NO_OFFST2       ;If yes, setup load address pointer
  2068 00:EAEB: A5 BA                        LDA     TGTL            ;Get starting address Lo byte
  2069 00:EAED: 85 B8                        STA     SRCL            ;Save it as Source Lo byte
  2070 00:EAEF: A5 BB                        LDA     TGTH            ;Get starting address Hi byte
  2071 00:EAF1: 85 B9                        STA     SRCH            ;Save it as Source Hi byte
  2072                        ;
  2073 00:EAF3: AE 50 03     NO_OFFST2       LDX     SRBUFF          ;Get record length
  2074 00:EAF6: CA                           DEX                     ;Decrement by 3
  2075 00:EAF7: CA                           DEX                     ;to only transfer the data
  2076 00:EAF8: CA                           DEX                     ;and not the count/load address
  2077 00:EAF9: A0 00                        LDY     #$00            ;Zero index
  2078 00:EAFB: B9 53 03     MVE_SREC        LDA     SRBUFF+3,Y      ;Get offset to data in record
  2079 00:EAFE: 91 BA                        STA     (TGTL),Y        ;Store it to memory
  2080 00:EB00: C8                           INY                     ;Increment index
  2081 00:EB01: CA                           DEX                     ;Decrement record count
  2082 00:EB02: D0 F7                        BNE     MVE_SREC        ;Branch back until done
  2083 00:EB04: 60           XMDMQ           RTS                     ;Return to caller
  2084                        ;
  2085                        ;[CNTRL-S] Xmodem/CRC Save command: Sends data to the Terminal program via Xmodem CRC.
  2086                        ; No cable swapping is required, uses the console UART for all transfers. User must
  2087                        ; enter a starting address for the data and a length, both 16-bit. Once entered, the
  2088                        ; user will need to setup the terminal program to receive data via Xmodem CRC protocol.
  2089                        ;
  2090                        ; NOTE: Tested with ExtraPutty (Win7) and Serial (OSX). Serial (OSX) has a problem with EOT.
  2091                        ; Serial does not release the port after completed, so the last message does not show!
  2092                        ; I submitted a problem report with their support, they have asked for more detail which I
  2093                        ; provided. Further note: Zoc7 also works properly on OSX, so the problem is with Serial.
  2094                        ;
  2095                        ; 20/06/2019 Serial Update!
  2096                        ;
  2097                        ;A workaround has been implemented for the problem with Serial:
  2098                        ; by implementing a 15 seconds delay to allow the user to name the saved file, Serial will
  Thu Mar 16 2023 11:46                                                                                                    Page 41


  2099                        ; release the port nicely and the Monitor code can display the exit message and return with
  2100                        ; the Monitor prompt as normal. This is basically an anomaly with Serial and I have sent this
  2101                        ; in to them. So far, no response from them, which is disappointing ;-(
  2102                        ;
  2103                        ; 10/09/2019 Serial Update!
  2104                        ;
  2105                        ; Version 1.4.0 has been released. The problem noted here has been fixed, so all workarounds
  2106                        ; have been removed and the code functions as designed without issues.
  2107                        ;
  2108 00:EB05: 64 C6        XMODEMS         STZ     OPXMDM          ;Clear Xmodem flag
  2109 00:EB07: A9 01                        LDA     #$01            ;Set block count to one
  2110 00:EB09: 85 CC                        STA     BLKNO           ;Save it
  2111                        ;
  2112 00:EB0B: A9 23                        LDA     #$23            ;Get Xmodem Save intro msg
  2113 00:EB0D: 20 24 E1                     JSR     HEX4            ;Send msg and get Source address
  2114 00:EB10: 85 B8                        STA     SRCL            ;Save Source low byte
  2115 00:EB12: 84 B9                        STY     SRCH            ;Save Source high byte
  2116 00:EB14: A9 04                        LDA     #$04            ;Get " len:" msg
  2117 00:EB16: 20 24 E1                     JSR     HEX4            ;Send msg and get length to send
  2118 00:EB19: 85 BC                        STA     LENL            ;Save Length low byte
  2119 00:EB1B: 84 BD                        STY     LENH            ;Save length high byte
  2120                        ;
  2121                        XMDM_SAVE       ;Entry point for an external program to save data via Xmodem CRC
  2122                        ; Entry at this point assumes that the variables have been setup properly.
  2123                        ; This includes the Source address (SCRL/H), Length (LENL/H), and that the
  2124                        ; Block count has been set to one and the OPXMDM flag has been cleared.
  2125 00:EB1D: A9 24                        LDA     #$24            ;Get Terminal Setup message
  2126 00:EB1F: 20 01 E1                     JSR     PROMPT          ;Send to console
  2127                        ;
  2128                        ; User now needs to setup terminal program to receive data via Xmodem/CRC.
  2129                        ;  Once setup, the terminal program will send an ASCII "C" character to signal the start
  2130                        ;  of data transfer. We can prompt the user to terminate the transfer by hitting ESC.
  2131                        ;  Once the transfer starts however, it is basically controlled by the receiving end.
  2132 00:EB22: 20 39 FF                     JSR     B_CHRIN         ;Wait for a key from the terminal program
  2133 00:EB25: C9 1B                        CMP     #$1B            ;Check for ESC key
  2134 00:EB27: F0 DB                        BEQ     XMDMQ           ;If yes, quit Xmodem save function
  2135 00:EB29: C9 43                        CMP     #'C'            ;Check for upper case ASCII "C"
  2136 00:EB2B: D0 D7                        BNE     XMDMQ           ;If not, quit Xmodem save function
  2137                        ;
  2138                        ; Terminal has sent an ASCII "C" character to initiate Xmodem/CRC transfer.
  2139                        ;  Note that per protocol, if receiver does not receive data within 3 seconds,
  2140                        ;  it will send another "C" to the device. This dictates the maximum time to
  2141                        ;  assemble the 133-byte block with 16-bit checksum must be less than 3 seconds.
  2142 00:EB2D: A5 CC        SND_LP          LDA     BLKNO           ;Get current block number
  2143 00:EB2F: 8D 7C 03                     STA     RBUFF           ;Store into buffer
  2144 00:EB32: 49 FF                        EOR     #$FF            ;One's compliment of BLKNO
  2145 00:EB34: 8D 7D 03                     STA     RBUFF+1         ;Store into buffer
  2146                        ;
  2147                        ; Now assemble 128 byte buffer and 16-bit CRC to send to terminal
  2148                        ;  SRCL/H is the start of the data to be sent. Start by moving 128 bytes into RBUFF
  2149 00:EB37: A2 00                        LDX     #$00            ;Zero index count
  2150 00:EB39: A5 BC        XMD_FIL         LDA     LENL            ;Get length low byte
  2151 00:EB3B: 05 BD                        ORA     LENH            ;Or in high byte
  2152 00:EB3D: F0 0F                        BEQ     XM_BLK          ;If length is zero, finish last block
  2153 00:EB3F: B2 B8                        LDA     (SRCL)          ;Get a byte from the source
  2154 00:EB41: 9D 7E 03                     STA     RBUFF+2,X       ;Save it into the buffer
  2155 00:EB44: 20 B2 E1                     JSR     UPD_STL         ;Update source and length variables
  2156 00:EB47: E8                           INX                     ;Increment count
  2157 00:EB48: E0 80                        CPX     #$80            ;Compare to 128
  2158 00:EB4A: D0 ED                        BNE     XMD_FIL         ;Loop back until buffer is filled
  2159 00:EB4C: 80 0E                        BRA     DO_UP_CRC       ;Calculate CRC and send block
  2160                        ;
  2161                        ;As each Xmodem block must contain 128 bytes, if the total amount data to be sent is less than
  Thu Mar 16 2023 11:46                                                                                                    Page 42


  2162                        ; 128 bytes, then the block must be padded to fill up the remaining space. By protocol
  2163                        ; definition, the default fill byte is hex $1E. The routine above checks the length during
  2164                        ; each byte transfer into the block buffer and will arrive here upon the length going to zero.
  2165                        ; Having arrived here with no more data to put into a block, we must determine if it's the
  2166                        ; last block and ensure that the block is a full 128 bytes with the proper $1E padding
  2167                        ; character for any unused data space.
  2168 00:EB4E: E0 80        XM_BLK          CPX     #$80            ;Check for X Reg at 128 bytes
  2169 00:EB50: F0 08                        BEQ     LAST_BLK        ;If yes, complete last block and exit
  2170 00:EB52: A9 1A        LST_BKLP        LDA     #$1A            ;Get padding character
  2171 00:EB54: 9D 7E 03                     STA     RBUFF+2,X       ;Place into buffer
  2172 00:EB57: E8                           INX                     ;Increment count
  2173 00:EB58: 80 F4                        BRA     XM_BLK          ;Loop back until done
  2174 00:EB5A: 97 C6        LAST_BLK        SMB1    OPXMDM          ;Set bit in flag for last block
  2175                        ;
  2176                        ; Now calculate the 16-bit CRC value and add into buffer
  2177 00:EB5C: 20 B4 EB     DO_UP_CRC       JSR     CRC16_GEN       ;Generate CRC for block
  2178                        ;
  2179 00:EB5F: A5 C7                        LDA     CRCHI           ;Get calculated CRC hi byte
  2180 00:EB61: 99 7E 03                     STA     RBUFF+2,Y       ;Save into buffer
  2181 00:EB64: A5 C8                        LDA     CRCLO           ;Get calculated CRC lo byte
  2182 00:EB66: 99 7F 03                     STA     RBUFF+3,Y       ;Save into buffer
  2183                        ;
  2184                        ; Buffer now has Block number/block compliment, 128 bytes of data and a 16-bit CRC
  2185 00:EB69: A9 01        RE_SEND         LDA     #SOH            ;Get start of header code
  2186 00:EB6B: 20 3C FF                     JSR     B_CHROUT        ;Send to terminal
  2187                        ;
  2188 00:EB6E: A2 00                        LDX     #$00            ;Zero index count
  2189 00:EB70: BD 7C 03     BLK_SND         LDA     RBUFF,X         ;Get Buffer data
  2190 00:EB73: 20 3C FF                     JSR     B_CHROUT        ;Send to terminal
  2191 00:EB76: E8                           INX                     ;Increment count
  2192 00:EB77: E0 84                        CPX     #$84            ;Check for all bytes sent
  2193 00:EB79: D0 F5                        BNE     BLK_SND         ;Branch back till buffer sent
  2194                        ;
  2195                        ; Buffer sent, now check for either an ACK or NAK from the terminal to confirm receive
  2196 00:EB7B: 20 39 FF     CHK_LAST        JSR     B_CHRIN         ;Get a character back from the terminal
  2197 00:EB7E: C9 06                        CMP     #ACK            ;Check for good receive
  2198 00:EB80: D0 0D                        BNE     BAD_RCV         ;Branch if error
  2199 00:EB82: 9F C6 1A                     BBS1    OPXMDM,XMUPDON  ;If last block sent, exit
  2200 00:EB85: A5 BC                        LDA     LENL            ;Check for zero length left
  2201 00:EB87: 05 BD                        ORA     LENH            ; - Even block size will be zero
  2202 00:EB89: F0 12                        BEQ     ZERO_BLK        ;If zero, just set bit and finish up
  2203 00:EB8B: E6 CC                        INC     BLKNO           ;Increment block count to next
  2204 00:EB8D: 80 9E                        BRA     SND_LP          ;Branch back to send next block
  2205                        ;
  2206                        ; ACK not received from terminal, check for NAK
  2207 00:EB8F: C9 15        BAD_RCV         CMP     #NAK            ;Check for NAK
  2208 00:EB91: F0 D6                        BEQ     RE_SEND         ;Resend block
  2209                        ;
  2210                        ; Unknown error at the this point... ACK or NAK not received.
  2211                        ;  Cancel the transfer with two CAN characters and return to Monitor
  2212 00:EB93: A9 18                        LDA     #CAN            ;Get cancel code
  2213 00:EB95: 20 3C FF                     JSR     B_CHROUT        ;Send to terminal (A Reg preserved)
  2214 00:EB98: 20 3C FF                     JSR     B_CHROUT        ;Send to terminal again
  2215 00:EB9B: 80 13                        BRA     XMDM_ERR        ;Finish up with error message and exit
  2216                        ;
  2217 00:EB9D: 97 C6        ZERO_BLK        SMB1    OPXMDM          ;Set bit for last block
  2218                        ;
  2219                        ;Transfer is now completed. Last block was received properly. So we should
  2220                        ; send a EOT character and return to the Monitor.
  2221 00:EB9F: A9 04        XMUPDON         LDA     #EOT            ;Get end of transmission character
  2222 00:EBA1: 20 3C FF                     JSR     B_CHROUT        ;Sent to terminal
  2223                        ;
  2224 00:EBA4: 20 39 FF                     JSR     B_CHRIN         ;Get a character back from terminal
  Thu Mar 16 2023 11:46                                                                                                    Page 43


  2225 00:EBA7: C9 06                        CMP     #ACK            ;Check for completion of transfer
  2226 00:EBA9: D0 05                        BNE     XMDM_ERR        ;Branch if an error occurred
  2227                        ;
  2228 00:EBAB: A9 25                        LDA     #$25            ;Else, get complete msg
  2229 00:EBAD: 4C 01 E1     XMDM_NE         JMP     PROMPT          ;Send to console and return
  2230                        ;
  2231 00:EBB0: A9 26        XMDM_ERR        LDA     #$26            ;Get xfer fail msg
  2232 00:EBB2: 80 F9                        BRA     XMDM_NE         ;Send message and return to Monitor
  2233                        ;
  2234                        ;CRC-16 Generation program. This routine generates the 16-bit CRC for the 128 byte
  2235                        ;  data block stored in RBUFF. It is a separate routine as it's used in both the
  2236                        ;  Xmodem load and save routines. It saves 31 bytes with a small penalty in speed.
  2237 00:EBB4: 64 C8        CRC16_GEN       STZ     CRCLO           ;Reset the CRC value by
  2238 00:EBB6: 64 C7                        STZ     CRCHI           ;putting all bits off
  2239 00:EBB8: A0 00                        LDY     #$00            ;Set index for data offset
  2240 00:EBBA: B9 7E 03     CALCCRC         LDA     RBUFF+2,Y       ;Get data byte
  2241 00:EBBD: 08                           PHP                     ;Save status Reg
  2242 00:EBBE: A2 08                        LDX     #$08            ;Load index for 8 bits
  2243 00:EBC0: 45 C7                        EOR     CRCHI           ;XOR High CRC byte
  2244 00:EBC2: 06 C8        CRCLOOP         ASL     CRCLO           ;Shift carry to CRC low byte
  2245 00:EBC4: 2A                           ROL     A               ;Shift bit to carry flag
  2246 00:EBC5: 90 0A                        BCC     CRCLP1          ;Branch if MSB is 1
  2247 00:EBC7: 49 10                        EOR     #$10            ;Exclusive OR with polynomial
  2248 00:EBC9: 48                           PHA                     ;Save result on stack
  2249 00:EBCA: A5 C8                        LDA     CRCLO           ;Get CRC low byte
  2250 00:EBCC: 49 21                        EOR     #$21            ;Exclusive OR with polynomial
  2251 00:EBCE: 85 C8                        STA     CRCLO           ;Save it back
  2252 00:EBD0: 68                           PLA                     ;Get previous result
  2253 00:EBD1: CA           CRCLP1          DEX                     ;Decrement index
  2254 00:EBD2: D0 EE                        BNE     CRCLOOP         ;Loop back for all 8 bits
  2255 00:EBD4: 85 C7                        STA     CRCHI           ;Update CRC high byte
  2256 00:EBD6: 28                           PLP                     ;Restore status Reg
  2257 00:EBD7: C8                           INY                     ;Increment index to the next data byte
  2258 00:EBD8: 10 E0                        BPL     CALCCRC         ;Branch back until all 128 fed to CRC routine
  2259 00:EBDA: 60                           RTS                     ;Return to caller
  2260                        ;
  2261                        ;[CNTL-R] Reset System command: Resets system by calling Coldstart routine. Page Zero is
  2262                        ; cleared, Vectors and Config data re-initialized from ROM. All I/O devices are reset from
  2263                        ; initial ROM parameters. Monitor Cold Start is entered.
  2264                        ;
  2265 00:EBDB: A9 1A        SYS_RST         LDA     #$1A            ;Get msg "Reset System"
  2266 00:EBDD: 87 C5                        SMB0    CMDFLAG         ;Set bit0 of command flag
  2267 00:EBDF: 80 02                        BRA     RST_ONLY        ;Branch below and handle reset
  2268                        ;
  2269                        ;[CNTL-Z] Zero command: zero RAM from $0100-$7FFF and Reset
  2270 00:EBE1: A9 19        ZERO            LDA     #$19            ;Get msg "Zero RAM/Reset System"
  2271 00:EBE3: 20 01 E1     RST_ONLY        JSR     PROMPT          ;Send to terminal
  2272 00:EBE6: 20 47 E2                     JSR     CONTINUE        ;Prompt for Continue
  2273 00:EBE9: 8F C5 16                     BBS0    CMDFLAG,DO_COLD ;Branch if reset only
  2274 00:EBEC: 78                           SEI                     ;Else, disable IRQs
  2275 00:EBED: A9 01                        LDA     #$01            ;Initialize address pointer to $0100
  2276 00:EBEF: 85 01                        STA     $01             ;Store to pointer high byte
  2277 00:EBF1: 64 00                        STZ     $00             ;Zero address low byte
  2278 00:EBF3: 3A                           DEC     A               ;LDA #$00
  2279 00:EBF4: 92 00        ZEROLOOP        STA     ($00)           ;Write $00 to current address
  2280 00:EBF6: E6 00                        INC     $00             ;Increment address pointer
  2281 00:EBF8: D0 FA                        BNE     ZEROLOOP        ;Loop back until done
  2282 00:EBFA: E6 01                        INC     $01             ;Increment page
  2283 00:EBFC: A6 01                        LDX     $01             ;Get Page number
  2284 00:EBFE: E0 E0                        CPX     #$E0            ;Check for start of ROM     
  2285 00:EC00: D0 F2                        BNE     ZEROLOOP        ;Loop back IF address pointer < $E000
  2286 00:EC02: 4C 5D FF     DO_COLD         JMP     B_COLDSTRT      ;Jump to coldstart vector
  2287                        ;
  Thu Mar 16 2023 11:46                                                                                                    Page 44


  2288                        ;END OF MONITOR CODE
  2289                        ;**************************************************************************************************
  2290                        ;                               START OF MONITOR DATA                                             *
  2291                        ;**************************************************************************************************
  2292                        ;Monitor command & jump table
  2293                        ; There are two parts to the Monitor command and jump table; First is the list of commands, which
  2294                        ; are one byte each. Alpha command characters are upper case. Second is the 16-bit address table
  2295                        ; that corresponds to the command routines for each command character.
  2296 00:EC05: 01           MONCMD  .DB     $01             ;[CNTRL-A] Start Assembler
  2297 00:EC06: 02                   .DB     $02             ;[CNTRL-B] Boot DOS/65 ROM Version
  2298 00:EC07: 04                   .DB     $04             ;[CNTRL-D] Start Disassembler
  2299 00:EC08: 05                   .DB     $05             ;[CNTRL-E] Edit EEPROM byte location
  2300 00:EC09: 0C                   .DB     $0C             ;[CNTRL-L] Xmodem/CRC Load
  2301 00:EC0A: 10                   .DB     $10             ;[CNTRL-P] Program EEPROM
  2302 00:EC0B: 11                   .DB     $11             ;[CNTRL-Q] Query Monitor Commands
  2303 00:EC0C: 12                   .DB     $12             ;[CNTRL-R] Reset - same as power up
  2304 00:EC0D: 13                   .DB     $13             ;[CNTRL-S] Xmodem/CRC Save
  2305 00:EC0E: 14                   .DB     $14             ;[CNTRL-T] Time/Date display
  2306 00:EC0F: 16                   .DB     $16             ;[CNTRL-V] Display Monitor Version
  2307 00:EC10: 1A                   .DB     $1A             ;[CNTRL-Z] Zero Memory - calls reset
  2308 00:EC11: 28                   .DB     $28             ;(         Init Macro
  2309 00:EC12: 29                   .DB     $29             ;)         Run Macro
  2310 00:EC13: 2C                   .DB     $2C             ;,         Setup Delay parameters
  2311 00:EC14: 2E                   .DB     $2E             ;.         Execute Millisecond Delay
  2312 00:EC15: 2F                   .DB     $2F             ;/         Execute Long Delay
  2313 00:EC16: 41                   .DB     $41             ;A         Display/Edit A Register
  2314 00:EC17: 42                   .DB     $42             ;B         Benchmark Timer clear/start
  2315 00:EC18: 43                   .DB     $43             ;C         Compare memory block
  2316 00:EC19: 44                   .DB     $44             ;D         Display Memory contents in HEX/TEXT
  2317 00:EC1A: 45                   .DB     $45             ;E         Examine/Edit memory
  2318 00:EC1B: 46                   .DB     $46             ;F         Fill memory block
  2319 00:EC1C: 47                   .DB     $47             ;G         Go execute to <addr>
  2320 00:EC1D: 48                   .DB     $48             ;H         Hex byte string search
  2321 00:EC1E: 49                   .DB     $49             ;I         Input Text string
  2322 00:EC1F: 4D                   .DB     $4D             ;M         Move memory block
  2323 00:EC20: 50                   .DB     $50             ;P         Display/Edit CPU status Reg
  2324 00:EC21: 51                   .DB     $51             ;Q         Quit Benchmark timer
  2325 00:EC22: 52                   .DB     $52             ;R         Display Registers
  2326 00:EC23: 53                   .DB     $53             ;S         Display/Edit stack pointer
  2327 00:EC24: 54                   .DB     $54             ;T         Text character string search
  2328 00:EC25: 58                   .DB     $58             ;X         Display/Edit X Register
  2329 00:EC26: 59                   .DB     $59             ;Y         Display/Edit Y Register
  2330                        ;
  2331 00:EC27: 5B E6        MONTAB  .DW     ASSEMBLER       ;[CNTRL-A] $01 Start Assembler
  2332 00:EC29: AC E6                .DW     BOOT_MICRODRIVE ;[CNTRL-B] $02 Boot from Microdrive
  2333 00:EC2B: D9 E6                .DW     DISASSEMBLER    ;[CNTRL-D] $04 Start Disassembler
  2334 00:EC2D: 81 E8                .DW     EEDIT           ;[CNTRL-E] $05 Edit EEPROM byte location
  2335 00:EC2F: 35 E9                .DW     XMODEML         ;[CNTRL-L] $0C Xmodem Download. Uses Console Port
  2336 00:EC31: 0B E3                .DW     PROGEE          ;[CNTRL-P] $10 Program the EEPROM
  2337 00:EC33: C8 E8                .DW     QUERY           ;[CNTRL-Q] $11 Query Monitor Commands
  2338 00:EC35: DB EB                .DW     SYS_RST         ;[CNTRL-R] $12 Reset CO2Monitor
  2339 00:EC37: 05 EB                .DW     XMODEMS         ;[CNTRL-S] $13 Xmodem Upload. Uses Console Port
  2340 00:EC39: CC E8                .DW     TIME            ;[CNTRL-T] $14 System Date and Time
  2341 00:EC3B: 29 E9                .DW     VER             ;[CNTRL-V] $16 Display Monitor Version level
  2342 00:EC3D: E1 EB                .DW     ZERO            ;[CNTRL-Z] $1A Zero memory ($0100-$7FFF) then Reset
  2343 00:EC3F: 9B E2                .DW     INIMACRO        ;(         $28 Clear input buffer/reset pointers
  2344 00:EC41: C4 E2                .DW     RUNMACRO        ;)         $29 Run Macro from start of input buffer
  2345 00:EC43: 65 E2                .DW     SET_DELAY       ;.         $2C Setup Delay Parameters
  2346 00:EC45: 42 FF                .DW     B_EXE_MSDLY     ;,         $2E Perform Millisecond Delay
  2347 00:EC47: 45 FF                .DW     B_EXE_LGDLY     ;/         $2F Execute Long Delay
  2348 00:EC49: 11 E6                .DW     ARG             ;A         $41 Examine/Edit ACCUMULATOR preset/result
  2349 00:EC4B: 76 E2                .DW     BENCH           ;B         $42 Clear count and start Benchmark timer
  2350 00:EC4D: FE E2                .DW     CPMVFL          ;C         $43 Compare command - new
  Thu Mar 16 2023 11:46                                                                                                    Page 45


  2351 00:EC4F: 0F E4                .DW     MDUMP           ;D         $44 HEX/TEXT dump from specified memory address
  2352 00:EC51: 94 E4                .DW     CHANGE          ;E         $45 Examine/change a memory location's contents
  2353 00:EC53: FE E2                .DW     CPMVFL          ;F         $46 Fill specified memory range with a value
  2354 00:EC55: C7 E4                .DW     GO              ;G         $47 Execute program code at specified address
  2355 00:EC57: 1F E5                .DW     SRCHBYT         ;H         $48 Search memory for a specified byte string
  2356 00:EC59: AE E5                .DW     TEXT            ;I         $49 Input text string into memory
  2357 00:EC5B: FE E2                .DW     CPMVFL          ;M         $4D Copy memory from Source to Target space
  2358 00:EC5D: 01 E6                .DW     PRG             ;P         $50 Examine/Edit CPU STATUS REGISTER preset/result
  2359 00:EC5F: 81 E2                .DW     QUITB           ;Q         $51 Quit Benchmark timer and display count
  2360 00:EC61: 28 E6                .DW     PRSTAT          ;R         $52 Display all preset/result contents
  2361 00:EC63: 05 E6                .DW     SRG             ;S         $53 Examine/Edit STACK POINTER preset/result
  2362 00:EC65: F1 E4                .DW     SRCHTXT         ;T         $54 Search memory for a specified text string
  2363 00:EC67: 0D E6                .DW     XRG             ;X         $58 Examine/Edit X-REGISTER preset/result
  2364 00:EC69: 09 E6                .DW     YRG             ;Y         $59 Examine/Edit Y-REGISTER preset/result
  2365                        ;
  2366                        ;**************************************************************************************************
  2367                        ;       C02Monitor message strings used with PROMPT routine, terminated with $00                  *
  2368                        ;**************************************************************************************************
  2369 00:EC6B: 20 63 6F 6E  MSG_00  .DB     " cont?"
       00:EC6F: 74 3F 
  2370 00:EC71: 28 79 2F 6E  MSG_01  .DB     "(y/n)"
       00:EC75: 29 
  2371 00:EC76: 00                   .DB     $00
  2372 00:EC77: 0D 0A        MSG_02  .DB     $0D,$0A
  2373 00:EC79: 20 20 20             .DB     "   "
  2374 00:EC7C: 20 61 64 64  MSG_03  .DB     " addr:"
       00:EC80: 72 3A 
  2375 00:EC82: 00                   .DB     $00
  2376 00:EC83: 20 6C 65 6E  MSG_04  .DB     " len:"
       00:EC87: 3A 
  2377 00:EC88: 00                   .DB     $00
  2378 00:EC89: 20 76 61 6C  MSG_05  .DB     " val:"
       00:EC8D: 3A 
  2379 00:EC8E: 00                   .DB     $00
  2380 00:EC8F: 20 73 72 63  MSG_06  .DB     " src:"
       00:EC93: 3A 
  2381 00:EC94: 00                   .DB     $00
  2382 00:EC95: 20 74 67 74  MSG_07  .DB     " tgt:"
       00:EC99: 3A 
  2383 00:EC9A: 00                   .DB     $00
  2384 00:EC9B: 20 66 69 6E  MSG_08  .DB     " find txt:"
       00:EC9F: 64 20 74 78 
       00:ECA3: 74 3A 
  2385 00:ECA5: 00                   .DB     $00
  2386 00:ECA6: 20 66 69 6E  MSG_09  .DB     " find bin:"
       00:ECAA: 64 20 62 69 
       00:ECAE: 6E 3A 
  2387 00:ECB0: 00                   .DB     $00
  2388 00:ECB1: 6E 6F 74 20  MSG_0A  .DB     "not "
  2389 00:ECB5: 66 6F 75 6E  MSG_0B  .DB     "found"
       00:ECB9: 64 
  2390 00:ECBA: 00                   .DB     $00
  2391 00:ECBB: 0D 0A        MSG_0C  .DB     $0D,$0A
  2392 00:ECBD: 73 65 61 72          .DB     "search- "
       00:ECC1: 63 68 2D 20 
  2393 00:ECC5: 00                   .DB     $00
  2394 00:ECC6: 0D 0A        MSG_0D  .DB     $0D,$0A
  2395 00:ECC8: 28 6E 29 65          .DB     "(n)ext? "
       00:ECCC: 78 74 3F 20 
  2396 00:ECD0: 00                   .DB     $00
  2397 00:ECD1: 53 52 3A 24  MSG_0E  .DB     "SR:$"
  2398 00:ECD5: 00                   .DB     $00
  2399 00:ECD6: 53 50 3A 24  MSG_0F  .DB     "SP:$"
  Thu Mar 16 2023 11:46                                                                                                    Page 46


  2400 00:ECDA: 00                   .DB     $00
  2401 00:ECDB: 59 52 3A 24  MSG_10  .DB     "YR:$"
  2402 00:ECDF: 00                   .DB     $00
  2403 00:ECE0: 58 52 3A 24  MSG_11  .DB     "XR:$"
  2404 00:ECE4: 00                   .DB     $00
  2405 00:ECE5: 41 43 3A 24  MSG_12  .DB     "AC:$"
  2406 00:ECE9: 00                   .DB     $00
  2407 00:ECEA: 0D 0A        MSG_13  .DB     $0D,$0A
  2408 00:ECEC: 20 20 20 50          .DB      "   PC  AC XR YR SP NV-BDIZC",$0D,$0A
       00:ECF0: 43 20 20 41 
       00:ECF4: 43 20 58 52 
       00:ECF8: 20 59 52 20 
       00:ECFC: 53 50 20 4E 
       00:ED00: 56 2D 42 44 
       00:ED04: 49 5A 43 0D 
       00:ED08: 0A 
  2409 00:ED09: 3B 20                .DB     "; "
  2410 00:ED0B: 00                   .DB     $00
  2411 00:ED0C: 0D 0A        MSG_14  .DB     $0D,$0A
  2412 00:ED0E: 28 63 29 32          .DB     "(c)2013-2022 K.E.Maier",$07
       00:ED12: 30 31 33 2D 
       00:ED16: 32 30 32 32 
       00:ED1A: 20 4B 2E 45 
       00:ED1E: 2E 4D 61 69 
       00:ED22: 65 72 07 
  2413 00:ED25: 0D 0A                .DB     $0D,$0A
  2414 00:ED27: 43 54 52 4C          .DB     "CTRL-Q for command list"
       00:ED2B: 2D 51 20 66 
       00:ED2F: 6F 72 20 63 
       00:ED33: 6F 6D 6D 61 
       00:ED37: 6E 64 20 6C 
       00:ED3B: 69 73 74 
  2415 00:ED3E: 0D 0A                .DB     $0D,$0A
  2416 00:ED40: 00                   .DB     $00
  2417 00:ED41: 0D 0A        MSG_15  .DB     $0D,$0A
  2418 00:ED43: 43 30 32 4D          .DB     "C02Monitor 4.02"
       00:ED47: 6F 6E 69 74 
       00:ED4B: 6F 72 20 34 
       00:ED4F: 2E 30 32 
  2419 00:ED52: 0D 0A                .DB     $0D,$0A
  2420 00:ED54: 31 35 2F 30          .DB     "15/02/2023"
       00:ED58: 32 2F 32 30 
       00:ED5C: 32 33 
  2421 00:ED5E: 0D 0A                .DB     $0D,$0A
  2422 00:ED60: 00                   .DB     $00
  2423 00:ED61: 0D 0A        MSG_16  .DB     $0D,$0A
  2424 00:ED63: 3B 2D                .DB     ";-"
  2425 00:ED65: 00                   .DB     $00
  2426 00:ED66: 20 64 65 6C  MSG_17  .DB     " delay ms:"
       00:ED6A: 61 79 20 6D 
       00:ED6E: 73 3A 
  2427 00:ED70: 00                   .DB     $00
  2428 00:ED71: 20 6D 75 6C  MSG_18  .DB     " mult:"
       00:ED75: 74 3A 
  2429 00:ED77: 00                   .DB     $00
  2430 00:ED78: 5A 65 72 6F  MSG_19  .DB     "Zero RAM/"
       00:ED7C: 20 52 41 4D 
       00:ED80: 2F 
  2431 00:ED81: 52 65 73 65  MSG_1A  .DB     "Reset,"
       00:ED85: 74 2C 
  2432 00:ED87: 00                   .DB     $00
  2433 00:ED88: 50 72 6F 67  MSG_1B  .DB     "Program EEPROM",$0D,$0A
       00:ED8C: 72 61 6D 20 
  Thu Mar 16 2023 11:46                                                                                                    Page 47


       00:ED90: 45 45 50 52 
       00:ED94: 4F 4D 0D 0A 
  2434 00:ED98: 00                   .DB     $00
  2435 00:ED99: 0D 0A        MSG_1C  .DB     $0D,$0A
  2436 00:ED9B: 41 72 65 20          .DB     "Are you sure? "
       00:ED9F: 79 6F 75 20 
       00:EDA3: 73 75 72 65 
       00:EDA7: 3F 20 
  2437 00:EDA9: 00                   .DB     $00
  2438 00:EDAA: 0D 0A        MSG_1D  .DB     $0D,$0A
  2439 00:EDAC: 57 72 69 74          .DB     "Writing EEPROM..."
       00:EDB0: 69 6E 67 20 
       00:EDB4: 45 45 50 52 
       00:EDB8: 4F 4D 2E 2E 
       00:EDBC: 2E 
  2440 00:EDBD: 00                   .DB     $00
  2441 00:EDBE: 0D 0A        MSG_1E  .DB     $0D,$0A
  2442 00:EDC0: 45 45 50 52          .DB     "EEPROM write complete."
       00:EDC4: 4F 4D 20 77 
       00:EDC8: 72 69 74 65 
       00:EDCC: 20 63 6F 6D 
       00:EDD0: 70 6C 65 74 
       00:EDD4: 65 2E 
  2443 00:EDD6: 00                   .DB     $00
  2444 00:EDD7: 0D 0A        MSG_1F  .DB     $0D,$0A
  2445 00:EDD9: 45 45 50 52          .DB     "EEPROM write failed!",$0D,$0A
       00:EDDD: 4F 4D 20 77 
       00:EDE1: 72 69 74 65 
       00:EDE5: 20 66 61 69 
       00:EDE9: 6C 65 64 21 
       00:EDED: 0D 0A 
  2446 00:EDEF: 43 68 65 63          .DB     "Check R/W jumper."
       00:EDF3: 6B 20 52 2F 
       00:EDF7: 57 20 6A 75 
       00:EDFB: 6D 70 65 72 
       00:EDFF: 2E 
  2447 00:EE00: 00                   .DB     $00
  2448 00:EE01: 0D 0A        MSG_20  .DB     $0D,$0A
  2449 00:EE03: 53 68 6F 77          .DB     "Show Loop count "
       00:EE07: 20 4C 6F 6F 
       00:EE0B: 70 20 63 6F 
       00:EE0F: 75 6E 74 20 
  2450 00:EE13: 00                   .DB     $00
  2451 00:EE14: 0D 0A        MSG_21  .DB     $0D,$0A
  2452 00:EE16: 4C 6F 6F 70          .DB     "Loops: "
       00:EE1A: 73 3A 20 
  2453 00:EE1D: 00                   .DB     $00
  2454 00:EE1E: 58 6D 6F 64  MSG_22  .DB     "Xmodem Download, <ESC> to abort, or"
       00:EE22: 65 6D 20 44 
       00:EE26: 6F 77 6E 6C 
       00:EE2A: 6F 61 64 2C 
       00:EE2E: 20 3C 45 53 
       00:EE32: 43 3E 20 74 
       00:EE36: 6F 20 61 62 
       00:EE3A: 6F 72 74 2C 
       00:EE3E: 20 6F 72 
  2455 00:EE41: 0D 0A                .DB     $0D,$0A
  2456 00:EE43: 4C 6F 61 64          .DB     "Load Address/S-Record offset:"
       00:EE47: 20 41 64 64 
       00:EE4B: 72 65 73 73 
       00:EE4F: 2F 53 2D 52 
       00:EE53: 65 63 6F 72 
       00:EE57: 64 20 6F 66 
  Thu Mar 16 2023 11:46                                                                                                    Page 48


       00:EE5B: 66 73 65 74 
       00:EE5F: 3A 
  2457 00:EE60: 00                   .DB     $00
  2458 00:EE61: 58 6D 6F 64  MSG_23  .DB     "Xmodem Upload, <ESC> to abort, or"
       00:EE65: 65 6D 20 55 
       00:EE69: 70 6C 6F 61 
       00:EE6D: 64 2C 20 3C 
       00:EE71: 45 53 43 3E 
       00:EE75: 20 74 6F 20 
       00:EE79: 61 62 6F 72 
       00:EE7D: 74 2C 20 6F 
       00:EE81: 72 
  2459 00:EE82: 0D 0A                .DB     $0D,$0A
  2460 00:EE84: 45 6E 74 65          .DB     "Enter Start address:"
       00:EE88: 72 20 53 74 
       00:EE8C: 61 72 74 20 
       00:EE90: 61 64 64 72 
       00:EE94: 65 73 73 3A 
  2461 00:EE98: 00                   .DB     $00
  2462 00:EE99: 0D 0A        MSG_24  .DB     $0D,$0A
  2463 00:EE9B: 53 65 74 75          .DB     "Setup Terminal program for Data transfer."
       00:EE9F: 70 20 54 65 
       00:EEA3: 72 6D 69 6E 
       00:EEA7: 61 6C 20 70 
       00:EEAB: 72 6F 67 72 
       00:EEAF: 61 6D 20 66 
       00:EEB3: 6F 72 20 44 
       00:EEB7: 61 74 61 20 
       00:EEBB: 74 72 61 6E 
       00:EEBF: 73 66 65 72 
       00:EEC3: 2E 
  2464 00:EEC4: 0D 0A                .DB     $0D,$0A
  2465 00:EEC6: 00                   .DB     $00
  2466 00:EEC7: 0D 0A        MSG_25  .DB     $0D,$0A
  2467 00:EEC9: 44 61 74 61          .DB     "Data transfer complete."
       00:EECD: 20 74 72 61 
       00:EED1: 6E 73 66 65 
       00:EED5: 72 20 63 6F 
       00:EED9: 6D 70 6C 65 
       00:EEDD: 74 65 2E 
  2468 00:EEE0: 00                   .DB     $00
  2469 00:EEE1: 0D 0A        MSG_26  .DB     $0D,$0A
  2470 00:EEE3: 44 61 74 61          .DB     "Data transfer error!"
       00:EEE7: 20 74 72 61 
       00:EEEB: 6E 73 66 65 
       00:EEEF: 72 20 65 72 
       00:EEF3: 72 6F 72 21 
  2471 00:EEF7: 00                   .DB     $00
  2472 00:EEF8: 0D 0A        MSG_27  .DB     $0D,$0A
  2473 00:EEFA: 53 2D 52 65          .DB     "S-Record load at:$"
       00:EEFE: 63 6F 72 64 
       00:EF02: 20 6C 6F 61 
       00:EF06: 64 20 61 74 
       00:EF0A: 3A 24 
  2474 00:EF0C: 00                   .DB     $00
  2475 00:EF0D: 0D 0A        MSG_28  .DB     $0D,$0A
  2476 00:EF0F: 44 69 73 61          .DB     "Disassembly from"
       00:EF13: 73 73 65 6D 
       00:EF17: 62 6C 79 20 
       00:EF1B: 66 72 6F 6D 
  2477 00:EF1F: 00                   .DB     $00
  2478 00:EF20: 53 74 61 72  MSG_29  .DB     "Start Benchmark counter? "
       00:EF24: 74 20 42 65 
  Thu Mar 16 2023 11:46                                                                                                    Page 49


       00:EF28: 6E 63 68 6D 
       00:EF2C: 61 72 6B 20 
       00:EF30: 63 6F 75 6E 
       00:EF34: 74 65 72 3F 
       00:EF38: 20 
  2479 00:EF39: 00                   .DB     $00
  2480 00:EF3A: 43 61 75 74  MSG_2A  .DB     "Caution! Editing EEPROM data."
       00:EF3E: 69 6F 6E 21 
       00:EF42: 20 45 64 69 
       00:EF46: 74 69 6E 67 
       00:EF4A: 20 45 45 50 
       00:EF4E: 52 4F 4D 20 
       00:EF52: 64 61 74 61 
       00:EF56: 2E 
  2481 00:EF57: 00                   .DB     $00
  2482 00:EF58: 0D 0A        MSG_2B  .DB     $0D,$0A
  2483 00:EF5A: 41 64 64 72          .DB     "Address not in "
       00:EF5E: 65 73 73 20 
       00:EF62: 6E 6F 74 20 
       00:EF66: 69 6E 20 
  2484 00:EF69: 00                   .DB     $00
  2485 00:EF6A: 45 45 50 52  MSG_2C  .DB     "EEPROM!"
       00:EF6E: 4F 4D 21 
  2486 00:EF71: 0D 0A                .DB     $0D,$0A
  2487 00:EF73: 00                   .DB     $00
  2488 00:EF74: 52 41 4D 21  MSG_2D  .DB     "RAM!"
  2489 00:EF78: 0D 0A                .DB     $0D,$0A
  2490 00:EF7A: 00                   .DB     $00
  2491 00:EF7B: 0D 0A        MSG_2E  .DB     $0D,$0A
  2492 00:EF7D: 41 73 73 65          .DB     "Assembly from"
       00:EF81: 6D 62 6C 79 
       00:EF85: 20 66 72 6F 
       00:EF89: 6D 
  2493 00:EF8A: 00                   .DB     $00
  2494 00:EF8B: 0D 0A        MSG_2F  .DB     $0D,$0A
  2495 00:EF8D: 62 72 61 6E          .DB     "branch out of range",$0D, $0A
       00:EF91: 63 68 20 6F 
       00:EF95: 75 74 20 6F 
       00:EF99: 66 20 72 61 
       00:EF9D: 6E 67 65 0D 
       00:EFA1: 0A 
  2496 00:EFA2: 00                   .DB     $00
  2497                        ;
  2498 00:EFA3: 44 61 74 65  MSG_30  .DB     "Date: "
       00:EFA7: 3A 20 
  2499 00:EFA9: 00                   .DB     $00
  2500 00:EFAA: 53 61 74     MSG_31  .DB     "Sat"
  2501 00:EFAD: 00                   .DB     $00
  2502 00:EFAE: 53 75 6E     MSG_32  .DB     "Sun"
  2503 00:EFB1: 00                   .DB     $00
  2504 00:EFB2: 4D 6F 6E     MSG_33  .DB     "Mon"
  2505 00:EFB5: 00                   .DB     $00
  2506 00:EFB6: 54 75 65     MSG_34  .DB     "Tue"
  2507 00:EFB9: 00                   .DB     $00
  2508 00:EFBA: 57 65 64     MSG_35  .DB     "Wed"
  2509 00:EFBD: 00                   .DB     $00
  2510 00:EFBE: 54 68 75     MSG_36  .DB     "Thu"
  2511 00:EFC1: 00                   .DB     $00
  2512 00:EFC2: 46 72 69     MSG_37  .DB     "Fri"
  2513 00:EFC5: 00                   .DB     $00
  2514 00:EFC6: 4A 61 6E     MSG_38  .DB     "Jan"
  2515 00:EFC9: 00                   .DB     $00
  2516 00:EFCA: 46 65 62     MSG_39  .DB     "Feb"
  Thu Mar 16 2023 11:46                                                                                                    Page 50


  2517 00:EFCD: 00                   .DB     $00
  2518 00:EFCE: 4D 61 72     MSG_3A  .DB     "Mar"
  2519 00:EFD1: 00                   .DB     $00
  2520 00:EFD2: 41 70 72     MSG_3B  .DB     "Apr"
  2521 00:EFD5: 00                   .DB     $00
  2522 00:EFD6: 4D 61 79     MSG_3C  .DB     "May"
  2523 00:EFD9: 00                   .DB     $00
  2524 00:EFDA: 4A 75 6E     MSG_3D  .DB     "Jun"
  2525 00:EFDD: 00                   .DB     $00
  2526 00:EFDE: 4A 75 6C     MSG_3E  .DB     "Jul"
  2527 00:EFE1: 00                   .DB     $00
  2528 00:EFE2: 41 75 67     MSG_3F  .DB     "Aug"
  2529 00:EFE5: 00                   .DB     $00
  2530 00:EFE6: 53 65 70     MSG_40  .DB     "Sep"
  2531 00:EFE9: 00                   .DB     $00
  2532 00:EFEA: 4F 63 74     MSG_41  .DB     "Oct"
  2533 00:EFED: 00                   .DB     $00
  2534 00:EFEE: 4E 6F 76     MSG_42  .DB     "Nov"
  2535 00:EFF1: 00                   .DB     $00
  2536 00:EFF2: 44 65 63     MSG_43  .DB     "Dec"
  2537 00:EFF5: 00                   .DB     $00
  2538 00:EFF6: 3A           MSG_44  .DB     ":"
  2539 00:EFF7: 00                   .DB     $00
  2540 00:EFF8: 2C 20        MSG_45  .DB     ", "
  2541 00:EFFA: 00                   .DB     $00
  2542 00:EFFB: 20 54 69 6D  MSG_46  .DB     " Time: "
       00:EFFF: 65 3A 20 
  2543 00:F002: 00                   .DB     $00
  2544 00:F003: 20           MSG_47  .DB     " "
  2545 00:F004: 00                   .DB     $00
  2546 00:F005: 20 53 65 63  MSG_48  .DB     " Seconds"
       00:F009: 6F 6E 64 73 
  2547 00:F00D: 00                   .DB     $00
  2548 00:F00E: 0D 0A        MSG_49  .DB     $0D,$0A
  2549 00:F010: 4D 65 6D 6F          .DB     "Memory Ops: "
       00:F014: 72 79 20 4F 
       00:F018: 70 73 3A 20 
  2550 00:F01C: 5B 43 5D 6F          .DB     "[C]ompare, "
       00:F020: 6D 70 61 72 
       00:F024: 65 2C 20 
  2551 00:F027: 5B 44 5D 69          .DB     "[D]isplay, "
       00:F02B: 73 70 6C 61 
       00:F02F: 79 2C 20 
  2552 00:F032: 5B 45 5D 64          .DB     "[E]dit, "
       00:F036: 69 74 2C 20 
  2553 00:F03A: 5B 46 5D 69          .DB     "[F]ill, "
       00:F03E: 6C 6C 2C 20 
  2554 00:F042: 5B 47 5D 6F          .DB     "[G]o Exec,",$0D,$0A
       00:F046: 20 45 78 65 
       00:F04A: 63 2C 0D 0A 
  2555 00:F04E: 5B 48 5D 65          .DB     "[H]ex Find, "
       00:F052: 78 20 46 69 
       00:F056: 6E 64 2C 20 
  2556 00:F05A: 5B 49 5D 6E          .DB     "[I]nput Text, "
       00:F05E: 70 75 74 20 
       00:F062: 54 65 78 74 
       00:F066: 2C 20 
  2557 00:F068: 5B 4D 5D 6F          .DB     "[M]ove, "
       00:F06C: 76 65 2C 20 
  2558 00:F070: 5B 54 5D 65          .DB     "[T]ext Find",$0D,$0A,$0A
       00:F074: 78 74 20 46 
       00:F078: 69 6E 64 0D 
       00:F07C: 0A 0A 
  Thu Mar 16 2023 11:46                                                                                                    Page 51


  2559 00:F07E: 52 65 67 69          .DB     "Register Ops: "
       00:F082: 73 74 65 72 
       00:F086: 20 4F 70 73 
       00:F08A: 3A 20 
  2560 00:F08C: 52 2C 41 2C          .DB     "R,A,X,Y,S,P",$0D,$0A,$0A
       00:F090: 58 2C 59 2C 
       00:F094: 53 2C 50 0D 
       00:F098: 0A 0A 
  2561 00:F09A: 43 6F 75 6E          .DB     "Counter/Timer Ops: "
       00:F09E: 74 65 72 2F 
       00:F0A2: 54 69 6D 65 
       00:F0A6: 72 20 4F 70 
       00:F0AA: 73 3A 20 
  2562 00:F0AD: 2C 3D 20 73          .DB     ",= set ms|mult, "
       00:F0B1: 65 74 20 6D 
       00:F0B5: 73 7C 6D 75 
       00:F0B9: 6C 74 2C 20 
  2563 00:F0BD: 2E 3D 20 65          .DB     ".= exe ms, "
       00:F0C1: 78 65 20 6D 
       00:F0C5: 73 2C 20 
  2564 00:F0C8: 2F 3D 20 65          .DB     "/= exe ms*mult",$0D,$0A
       00:F0CC: 78 65 20 6D 
       00:F0D0: 73 2A 6D 75 
       00:F0D4: 6C 74 0D 0A 
  2565 00:F0D8: 5B 42 5D 65          .DB     "[B]enchmark clear/start, "
       00:F0DC: 6E 63 68 6D 
       00:F0E0: 61 72 6B 20 
       00:F0E4: 63 6C 65 61 
       00:F0E8: 72 2F 73 74 
       00:F0EC: 61 72 74 2C 
       00:F0F0: 20 
  2566 00:F0F1: 5B 51 5D 75          .DB     "[Q]uit benchmark/display elapsed time",$0D,$0A,$0A
       00:F0F5: 69 74 20 62 
       00:F0F9: 65 6E 63 68 
       00:F0FD: 6D 61 72 6B 
       00:F101: 2F 64 69 73 
       00:F105: 70 6C 61 79 
       00:F109: 20 65 6C 61 
       00:F10D: 70 73 65 64 
       00:F111: 20 74 69 6D 
       00:F115: 65 0D 0A 0A 
  2567 00:F119: 4D 61 63 72          .DB     "Macro: "
       00:F11D: 6F 3A 20 
  2568 00:F120: 28 3D 20 49          .DB     "(= Init "
       00:F124: 6E 69 74 20 
  2569 00:F128: 29 3D 20 52          .DB     ")= Run",$0D,$0A,$0A
       00:F12C: 75 6E 0D 0A 
       00:F130: 0A 
  2570 00:F131: 43 54 52 4C          .DB     "CTRL[?]: "
       00:F135: 5B 3F 5D 3A 
       00:F139: 20 
  2571 00:F13A: 5B 41 5D 73          .DB     "[A]ssemble, "
       00:F13E: 73 65 6D 62 
       00:F142: 6C 65 2C 20 
  2572 00:F146: 5B 42 5D 6F          .DB     "[B]oot from IDE, "
       00:F14A: 6F 74 20 66 
       00:F14E: 72 6F 6D 20 
       00:F152: 49 44 45 2C 
       00:F156: 20 
  2573 00:F157: 5B 44 5D 69          .DB     "[D]isassemble, "
       00:F15B: 73 61 73 73 
       00:F15F: 65 6D 62 6C 
       00:F163: 65 2C 20 
  Thu Mar 16 2023 11:46                                                                                                    Page 52


  2574 00:F166: 5B 45 5D 64          .DB     "[E]dit EEPROM, "
       00:F16A: 69 74 20 45 
       00:F16E: 45 50 52 4F 
       00:F172: 4D 2C 20 
  2575 00:F175: 5B 4C 5D 6F          .DB     "[L]oad",$0D,$0A
       00:F179: 61 64 0D 0A 
  2576 00:F17D: 5B 50 5D 72          .DB     "[P]rogram, "
       00:F181: 6F 67 72 61 
       00:F185: 6D 2C 20 
  2577 00:F188: 5B 51 5D 75          .DB     "[Q]uery Cmds ,"
       00:F18C: 65 72 79 20 
       00:F190: 43 6D 64 73 
       00:F194: 20 2C 
  2578 00:F196: 5B 52 5D 65          .DB     "[R]eset, "
       00:F19A: 73 65 74 2C 
       00:F19E: 20 
  2579 00:F19F: 5B 53 5D 61          .DB     "[S]ave, "
       00:F1A3: 76 65 2C 20 
  2580 00:F1A7: 5B 54 5D 69          .DB     "[T]ime/Date, "
       00:F1AB: 6D 65 2F 44 
       00:F1AF: 61 74 65 2C 
       00:F1B3: 20 
  2581 00:F1B4: 5B 56 5D 65          .DB     "[V]ersion",$0D,$0A
       00:F1B8: 72 73 69 6F 
       00:F1BC: 6E 0D 0A 
  2582 00:F1BF: 5B 5A 5D 65          .DB     "[Z]ero RAM/Reset",$0A
       00:F1C3: 72 6F 20 52 
       00:F1C7: 41 4D 2F 52 
       00:F1CB: 65 73 65 74 
       00:F1CF: 0A 
  2583 00:F1D0: 00                   .DB     $00
  2584 00:F1D1: 45 72 72 6F  MSG_4A  .DB     "Error reading Microdrive!",$0A,$0D
       00:F1D5: 72 20 72 65 
       00:F1D9: 61 64 69 6E 
       00:F1DD: 67 20 4D 69 
       00:F1E1: 63 72 6F 64 
       00:F1E5: 72 69 76 65 
       00:F1E9: 21 0A 0D 
  2585 00:F1EC: 00                   .DB     $00
  2586 00:F1ED: 50 61 72 74  MSG_4B  .DB     "Partition Record is invalid!",$0A,$0D
       00:F1F1: 69 74 69 6F 
       00:F1F5: 6E 20 52 65 
       00:F1F9: 63 6F 72 64 
       00:F1FD: 20 69 73 20 
       00:F201: 69 6E 76 61 
       00:F205: 6C 69 64 21 
       00:F209: 0A 0D 
  2587 00:F20B: 00                   .DB     #$00
  2588                        ;
  2589                        MSG_TABLE       ;Message table: contains message addresses sent via the PROMPT routine
  2590 00:F20C: 6B EC 71 EC          .DW     MSG_00, MSG_01, MSG_02, MSG_03, MSG_04, MSG_05, MSG_06, MSG_07
       00:F210: 77 EC 7C EC 
       00:F214: 83 EC 89 EC 
       00:F218: 8F EC 95 EC 
  2591 00:F21C: 9B EC A6 EC          .DW     MSG_08, MSG_09, MSG_0A, MSG_0B, MSG_0C, MSG_0D, MSG_0E, MSG_0F
       00:F220: B1 EC B5 EC 
       00:F224: BB EC C6 EC 
       00:F228: D1 EC D6 EC 
  2592 00:F22C: DB EC E0 EC          .DW     MSG_10, MSG_11, MSG_12, MSG_13, MSG_14, MSG_15, MSG_16, MSG_17
       00:F230: E5 EC EA EC 
       00:F234: 0C ED 41 ED 
       00:F238: 61 ED 66 ED 
  2593 00:F23C: 71 ED 78 ED          .DW     MSG_18, MSG_19, MSG_1A, MSG_1B, MSG_1C, MSG_1D, MSG_1E, MSG_1F
  Thu Mar 16 2023 11:46                                                                                                    Page 53


       00:F240: 81 ED 88 ED 
       00:F244: 99 ED AA ED 
       00:F248: BE ED D7 ED 
  2594 00:F24C: 01 EE 14 EE          .DW     MSG_20, MSG_21, MSG_22, MSG_23, MSG_24, MSG_25, MSG_26, MSG_27
       00:F250: 1E EE 61 EE 
       00:F254: 99 EE C7 EE 
       00:F258: E1 EE F8 EE 
  2595 00:F25C: 0D EF 20 EF          .DW     MSG_28, MSG_29, MSG_2A, MSG_2B, MSG_2C, MSG_2D, MSG_2E, MSG_2F
       00:F260: 3A EF 58 EF 
       00:F264: 6A EF 74 EF 
       00:F268: 7B EF 8B EF 
  2596 00:F26C: A3 EF AA EF          .DW     MSG_30, MSG_31, MSG_32, MSG_33, MSG_34, MSG_35, MSG_36, MSG_37
       00:F270: AE EF B2 EF 
       00:F274: B6 EF BA EF 
       00:F278: BE EF C2 EF 
  2597 00:F27C: C6 EF CA EF          .DW     MSG_38, MSG_39, MSG_3A, MSG_3B, MSG_3C, MSG_3D, MSG_3E, MSG_3F
       00:F280: CE EF D2 EF 
       00:F284: D6 EF DA EF 
       00:F288: DE EF E2 EF 
  2598 00:F28C: E6 EF EA EF          .DW     MSG_40, MSG_41, MSG_42, MSG_43, MSG_44, MSG_45, MSG_46, MSG_47
       00:F290: EE EF F2 EF 
       00:F294: F6 EF F8 EF 
       00:F298: FB EF 03 F0 
  2599 00:F29C: 05 F0 0E F0          .DW     MSG_48, MSG_49, MSG_4A, MSG_4B
       00:F2A0: D1 F1 ED F1 
  2600                        ;
  2601                        part_offset
  2602 00:F2A4: 00 00 02 00                  .LONG   131072          ;Partition offset for drive letters
  2603                        ;**************************************************************************************************
  2604                        ;                               START OF DISASSEMBLER DATA                                        *
  2605                        ;**************************************************************************************************
  2606                        ; Pointer for address mode handlers. Each byte contains handler pointer for two opcodes;
  2607                        ; Upper nibble for odd, lower nibble for even
  2608                        HDLR_IDX
  2609 00:F2A8: 26 00 33 3E          .DB     $26,$00,$33,$3E,$02,$10,$88,$8F
       00:F2AC: 02 10 88 8F 
  2610 00:F2B0: C7 B0 34 4E          .DB     $C7,$B0,$34,$4E,$0A,$10,$89,$9F
       00:F2B4: 0A 10 89 9F 
  2611 00:F2B8: 86 00 33 3E          .DB     $86,$00,$33,$3E,$02,$10,$88,$8F
       00:F2BC: 02 10 88 8F 
  2612 00:F2C0: C7 B0 44 4E          .DB     $C7,$B0,$44,$4E,$0A,$10,$99,$9F
       00:F2C4: 0A 10 99 9F 
  2613 00:F2C8: 06 00 03 3E          .DB     $06,$00,$03,$3E,$02,$10,$88,$8F
       00:F2CC: 02 10 88 8F 
  2614 00:F2D0: C7 B0 04 4E          .DB     $C7,$B0,$04,$4E,$0A,$00,$09,$9F
       00:F2D4: 0A 00 09 9F 
  2615 00:F2D8: 06 00 33 3E          .DB     $06,$00,$33,$3E,$02,$10,$B8,$8F
       00:F2DC: 02 10 B8 8F 
  2616 00:F2E0: C7 B0 44 4E          .DB     $C7,$B0,$44,$4E,$0A,$00,$D9,$9F
       00:F2E4: 0A 00 D9 9F 
  2617 00:F2E8: C6 00 33 3E          .DB     $C6,$00,$33,$3E,$02,$00,$88,$8F
       00:F2EC: 02 00 88 8F 
  2618 00:F2F0: C7 B0 44 5E          .DB     $C7,$B0,$44,$5E,$0A,$00,$89,$9F
       00:F2F4: 0A 00 89 9F 
  2619 00:F2F8: 26 20 33 3E          .DB     $26,$20,$33,$3E,$02,$00,$88,$8F
       00:F2FC: 02 00 88 8F 
  2620 00:F300: C7 B0 44 5E          .DB     $C7,$B0,$44,$5E,$0A,$00,$99,$AF
       00:F304: 0A 00 99 AF 
  2621 00:F308: 26 00 33 3E          .DB     $26,$00,$33,$3E,$02,$00,$88,$8F
       00:F30C: 02 00 88 8F 
  2622 00:F310: C7 B0 04 4E          .DB     $C7,$B0,$04,$4E,$0A,$00,$09,$9F
       00:F314: 0A 00 09 9F 
  2623 00:F318: 26 00 33 3E          .DB     $26,$00,$33,$3E,$02,$00,$88,$8F
  Thu Mar 16 2023 11:46                                                                                                    Page 54


       00:F31C: 02 00 88 8F 
  2624 00:F320: C7 B0 04 4E          .DB     $C7,$B0,$04,$4E,$0A,$00,$09,$9F
       00:F324: 0A 00 09 9F 
  2625                        ;
  2626                        ;Disassembler handler table: Handler address index: (referenced in table HDLR_IDX)
  2627                        HDLR_TAB
  2628 00:F328: 47 E7                .DW     IMPLIED         ;$00
  2629 00:F32A: 8E E7                .DW     ACC_MODE        ;$01
  2630 00:F32C: 84 E7                .DW     ZP_IMED         ;$02
  2631 00:F32E: A6 E7                .DW     ZP_ABS          ;$03
  2632 00:F330: CE E7                .DW     ZP_ABS_X        ;$04
  2633 00:F332: DA E7                .DW     ZP_ABS_Y        ;$05
  2634 00:F334: F3 E7                .DW     ZP_IND_X        ;$06
  2635 00:F336: FB E7                .DW     ZP_IND_Y        ;$07
  2636 00:F338: 96 E7                .DW     ABSOLUTE        ;$08
  2637 00:F33A: E8 E7                .DW     ABS_X           ;$09
  2638 00:F33C: E6 E7                .DW     ABS_Y           ;$0A
  2639 00:F33E: AE E7                .DW     INDIRECT        ;$0B
  2640 00:F340: 3A E8                .DW     REL_BRA         ;$0C
  2641 00:F342: 03 E8                .DW     IND_ABS_X       ;$0D
  2642 00:F344: 11 E8                .DW     ZP_XMB          ;$0E
  2643 00:F346: 25 E8                .DW     ZP_BBX          ;$0F
  2644                        ;
  2645                        ;Disassembler mnemonic pointer table. This is indexed by the instruction opcode.
  2646                        ; The values in this table are an index to the mnemonic data used to print:
  2647                        MNE_PTAB        ;Mnemonic pointer index table
  2648 00:F348: 1C 4C 00 00          .DB     $1C,$4C,$00,$00,$82,$4C,$06,$5E,$50,$4C,$06,$00,$82,$4C,$06,$08
       00:F34C: 82 4C 06 5E 
       00:F350: 50 4C 06 00 
       00:F354: 82 4C 06 08 
  2649 00:F358: 18 4C 4C 00          .DB     $18,$4C,$4C,$00,$80,$4C,$06,$5E,$22,$4C,$38,$00,$80,$4C,$06,$08
       00:F35C: 80 4C 06 5E 
       00:F360: 22 4C 38 00 
       00:F364: 80 4C 06 08 
  2650 00:F368: 40 04 00 00          .DB     $40,$04,$00,$00,$12,$04,$60,$5E,$58,$04,$60,$00,$12,$04,$60,$08
       00:F36C: 12 04 60 5E 
       00:F370: 58 04 60 00 
       00:F374: 12 04 60 08 
  2651 00:F378: 14 04 04 00          .DB     $14,$04,$04,$00,$12,$04,$60,$5E,$6A,$04,$30,$00,$12,$04,$60,$08
       00:F37C: 12 04 60 5E 
       00:F380: 6A 04 30 00 
       00:F384: 12 04 60 08 
  2652 00:F388: 64 36 00 00          .DB     $64,$36,$00,$00,$00,$36,$48,$5E,$4E,$36,$48,$00,$3E,$36,$48,$08
       00:F38C: 00 36 48 5E 
       00:F390: 4E 36 48 00 
       00:F394: 3E 36 48 08 
  2653 00:F398: 1E 36 36 00          .DB     $1E,$36,$36,$00,$00,$36,$48,$5E,$26,$36,$54,$00,$00,$36,$48,$08
       00:F39C: 00 36 48 5E 
       00:F3A0: 26 36 54 00 
       00:F3A4: 00 36 48 08 
  2654 00:F3A8: 66 02 00 00          .DB     $66,$02,$00,$00,$7A,$02,$62,$5E,$56,$02,$62,$00,$3E,$02,$62,$08
       00:F3AC: 7A 02 62 5E 
       00:F3B0: 56 02 62 00 
       00:F3B4: 3E 02 62 08 
  2655 00:F3B8: 20 02 02 00          .DB     $20,$02,$02,$00,$7A,$02,$62,$5E,$6E,$02,$5C,$00,$3E,$02,$62,$08
       00:F3BC: 7A 02 62 5E 
       00:F3C0: 6E 02 5C 00 
       00:F3C4: 3E 02 62 08 
  2656 00:F3C8: 1A 72 00 00          .DB     $1A,$72,$00,$00,$78,$72,$76,$70,$34,$12,$86,$00,$78,$72,$76,$0A
       00:F3CC: 78 72 76 70 
       00:F3D0: 34 12 86 00 
       00:F3D4: 78 72 76 0A 
  2657 00:F3D8: 0C 72 72 00          .DB     $0C,$72,$72,$00,$78,$72,$76,$70,$8A,$72,$88,$00,$7A,$72,$7A,$0A
  Thu Mar 16 2023 11:46                                                                                                    Page 55


       00:F3DC: 78 72 76 70 
       00:F3E0: 8A 72 88 00 
       00:F3E4: 7A 72 7A 0A 
  2658 00:F3E8: 46 42 44 00          .DB     $46,$42,$44,$00,$46,$42,$44,$70,$7E,$42,$7C,$00,$46,$42,$44,$0A
       00:F3EC: 46 42 44 70 
       00:F3F0: 7E 42 7C 00 
       00:F3F4: 46 42 44 0A 
  2659 00:F3F8: 0E 42 42 00          .DB     $0E,$42,$42,$00,$46,$42,$44,$70,$28,$42,$84,$00,$46,$42,$44,$0A
       00:F3FC: 46 42 44 70 
       00:F400: 28 42 84 00 
       00:F404: 46 42 44 0A 
  2660 00:F408: 2E 2A 00 00          .DB     $2E,$2A,$00,$00,$2E,$2A,$30,$70,$3C,$2A,$32,$8C,$2E,$2A,$30,$0A
       00:F40C: 2E 2A 30 70 
       00:F410: 3C 2A 32 8C 
       00:F414: 2E 2A 30 0A 
  2661 00:F418: 16 2A 2A 00          .DB     $16,$2A,$2A,$00,$00,$2A,$30,$70,$24,$2A,$52,$74,$00,$2A,$30,$0A
       00:F41C: 00 2A 30 70 
       00:F420: 24 2A 52 74 
       00:F424: 00 2A 30 0A 
  2662 00:F428: 2C 68 00 00          .DB     $2C,$68,$00,$00,$2C,$68,$38,$70,$3A,$68,$4A,$00,$2C,$68,$38,$0A
       00:F42C: 2C 68 38 70 
       00:F430: 3A 68 4A 00 
       00:F434: 2C 68 38 0A 
  2663 00:F438: 10 68 68 00          .DB     $10,$68,$68,$00,$00,$68,$38,$70,$6C,$68,$5A,$00,$00,$68,$38,$0A
       00:F43C: 00 68 38 70 
       00:F440: 6C 68 5A 00 
       00:F444: 00 68 38 0A 
  2664                        ;
  2665                        DIS_NMEM        ;Mnemonic compressed table
  2666                        ; Uses two bytes per 3-character Mnemonic. 5-bits per character uses 15-bit total
  2667                        ; Characters are left to right. 5-bits shifted into A Reg, add in $3F and print
  2668                        ; "?" starts with "00000", "A" starts with "00010", "B" starts with "00011", etc.
  2669                        ;
  2670                        ; A-00010 B-00011 C-00100 D-00101 E-00110 F-00111 G-01000 H-01001 I-01010
  2671                        ; J-01011 K-01100 L-01101 M-01110 N-01111 O-10000 P-10001 Q-10010 R-10011
  2672                        ; S-10100 T-10101 U-10110 V-10111 W-11000 X-11001 Y-11010 Z-11011
  2673 00:F448: 00 00                .DBYTE  %0000000000000000       ;???    $00
  2674 00:F44A: 11 48                .DBYTE  %0001000101001000       ;ADC    $02
  2675 00:F44C: 13 CA                .DBYTE  %0001001111001010       ;AND    $04
  2676 00:F44E: 15 1A                .DBYTE  %0001010100011010       ;ASL    $06
  2677 00:F450: 18 E6                .DBYTE  %0001100011100110       ;BBR    $08
  2678 00:F452: 18 E8                .DBYTE  %0001100011101000       ;BBS    $0A
  2679 00:F454: 19 08                .DBYTE  %0001100100001000       ;BCC    $0C
  2680 00:F456: 19 28                .DBYTE  %0001100100101000       ;BCS    $0E
  2681 00:F458: 19 A4                .DBYTE  %0001100110100100       ;BEQ    $10
  2682 00:F45A: 1A AA                .DBYTE  %0001101010101010       ;BIT    $12
  2683 00:F45C: 1B 94                .DBYTE  %0001101110010100       ;BMI    $14
  2684 00:F45E: 1B CC                .DBYTE  %0001101111001100       ;BNE    $16
  2685 00:F460: 1C 5A                .DBYTE  %0001110001011010       ;BPL    $18
  2686 00:F462: 1C C4                .DBYTE  %0001110011000100       ;BRA    $1A
  2687 00:F464: 1C D8                .DBYTE  %0001110011011000       ;BRK    $1C
  2688 00:F466: 1D C8                .DBYTE  %0001110111001000       ;BVC    $1E
  2689 00:F468: 1D E8                .DBYTE  %0001110111101000       ;BVS    $20
  2690 00:F46A: 23 48                .DBYTE  %0010001101001000       ;CLC    $22
  2691 00:F46C: 23 4A                .DBYTE  %0010001101001010       ;CLD    $24
  2692 00:F46E: 23 54                .DBYTE  %0010001101010100       ;CLI    $26
  2693 00:F470: 23 6E                .DBYTE  %0010001101101110       ;CLV    $28
  2694 00:F472: 23 A2                .DBYTE  %0010001110100010       ;CMP    $2A
  2695 00:F474: 24 72                .DBYTE  %0010010001110010       ;CPX    $2C
  2696 00:F476: 24 74                .DBYTE  %0010010001110100       ;CPY    $2E
  2697 00:F478: 29 88                .DBYTE  %0010100110001000       ;DEC    $30
  2698 00:F47A: 29 B2                .DBYTE  %0010100110110010       ;DEX    $32
  2699 00:F47C: 29 B4                .DBYTE  %0010100110110100       ;DEY    $34
  Thu Mar 16 2023 11:46                                                                                                    Page 56


  2700 00:F47E: 34 26                .DBYTE  %0011010000100110       ;EOR    $36
  2701 00:F480: 53 C8                .DBYTE  %0101001111001000       ;INC    $38
  2702 00:F482: 53 F2                .DBYTE  %0101001111110010       ;INX    $3A
  2703 00:F484: 53 F4                .DBYTE  %0101001111110100       ;INY    $3C
  2704 00:F486: 5B A2                .DBYTE  %0101101110100010       ;JMP    $3E
  2705 00:F488: 5D 26                .DBYTE  %0101110100100110       ;JSR    $40
  2706 00:F48A: 69 44                .DBYTE  %0110100101000100       ;LDA    $42
  2707 00:F48C: 69 72                .DBYTE  %0110100101110010       ;LDX    $44
  2708 00:F48E: 69 74                .DBYTE  %0110100101110100       ;LDY    $46
  2709 00:F490: 6D 26                .DBYTE  %0110110100100110       ;LSR    $48
  2710 00:F492: 7C 22                .DBYTE  %0111110000100010       ;NOP    $4A
  2711 00:F494: 84 C4                .DBYTE  %1000010011000100       ;ORA    $4C
  2712 00:F496: 8A 44                .DBYTE  %1000101001000100       ;PHA    $4E
  2713 00:F498: 8A 62                .DBYTE  %1000101001100010       ;PHP    $50
  2714 00:F49A: 8A 72                .DBYTE  %1000101001110010       ;PHX    $52
  2715 00:F49C: 8A 74                .DBYTE  %1000101001110100       ;PHY    $54
  2716 00:F49E: 8B 44                .DBYTE  %1000101101000100       ;PLA    $56
  2717 00:F4A0: 8B 62                .DBYTE  %1000101101100010       ;PLP    $58
  2718 00:F4A2: 8B 72                .DBYTE  %1000101101110010       ;PLX    $5A
  2719 00:F4A4: 8B 74                .DBYTE  %1000101101110100       ;PLY    $5C
  2720 00:F4A6: 9B 86                .DBYTE  %1001101110000110       ;RMB    $5E
  2721 00:F4A8: 9C 1A                .DBYTE  %1001110000011010       ;ROL    $60
  2722 00:F4AA: 9C 26                .DBYTE  %1001110000100110       ;ROR    $62
  2723 00:F4AC: 9D 54                .DBYTE  %1001110101010100       ;RTI    $64
  2724 00:F4AE: 9D 68                .DBYTE  %1001110101101000       ;RTS    $66
  2725 00:F4B0: A0 C8                .DBYTE  %1010000011001000       ;SBC    $68
  2726 00:F4B2: A1 88                .DBYTE  %1010000110001000       ;SEC    $6A
  2727 00:F4B4: A1 8A                .DBYTE  %1010000110001010       ;SED    $6C
  2728 00:F4B6: A1 94                .DBYTE  %1010000110010100       ;SEI    $6E
  2729 00:F4B8: A3 86                .DBYTE  %1010001110000110       ;SMB    $70
  2730 00:F4BA: A5 44                .DBYTE  %1010010101000100       ;STA    $72
  2731 00:F4BC: A5 62                .DBYTE  %1010010101100010       ;STP    $74
  2732 00:F4BE: A5 72                .DBYTE  %1010010101110010       ;STX    $76
  2733 00:F4C0: A5 74                .DBYTE  %1010010101110100       ;STY    $78
  2734 00:F4C2: A5 76                .DBYTE  %1010010101110110       ;STZ    $7A
  2735 00:F4C4: A8 B2                .DBYTE  %1010100010110010       ;TAX    $7C
  2736 00:F4C6: A8 B4                .DBYTE  %1010100010110100       ;TAY    $7E
  2737 00:F4C8: AC E8                .DBYTE  %1010110011101000       ;TRB    $80
  2738 00:F4CA: AD 06                .DBYTE  %1010110100000110       ;TSB    $82
  2739 00:F4CC: AD 32                .DBYTE  %1010110100110010       ;TSX    $84
  2740 00:F4CE: AE 44                .DBYTE  %1010111001000100       ;TXA    $86
  2741 00:F4D0: AE 68                .DBYTE  %1010111001101000       ;TXS    $88
  2742 00:F4D2: AE 84                .DBYTE  %1010111010000100       ;TYA    $8A
  2743 00:F4D4: C0 94                .DBYTE  %1100000010010100       ;WAI    $8C
  2744                        ;
  2745                        ;**************************************************************************************************
  2746                        ;                               END OF DISASSEMBLER DATA                                          *
  2747                        ;**************************************************************************************************
  2748                        ;                               END OF MONITOR DATA                                               *
  2749                        ;**************************************************************************************************
  2750                                .END


      Lines assembled: 3166
      Errors: 0
