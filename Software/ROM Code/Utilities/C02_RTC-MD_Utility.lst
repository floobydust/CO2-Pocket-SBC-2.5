  Thu Mar 16 2023 11:47                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C02 Macro Assembler    **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;**************************************************************************************************
     2                        ;*                                                                                                *
     3                        ;*                Utility program for the RTC/MicroDrive PATA Adapter 0.83                        *
     4                        ;*                                                                                                *
     5                        ;*        This Utility provides functions to setup the DS15x1 Realtime Clock Date/Time            *
     6                        ;*         - Note: Time is kept in 24hr format only                                               *
     7                        ;*                 A 2-byte signature is loaded into NVRAM to identify RTC presence               *
     8                        ;*                                                                                                *
     9                        ;*       This Utility provides functions to identify, test and edit a MicroDrive when present     *
    10                        ;*         The following functions are provided:                                                  *
    11                        ;*           - Identify MicroDrive: Vendor String, Device Serial, LBA Count in Hex/Decimal)       *
    12                        ;*           - Read any LBA into memory and display contents in Hex/ASCII                         *
    13                        ;*           - Write any LBA from memory and display contents in Hex/ASCII                        *
    14                        ;*           - Read Full LBA count sequentially or staggered                                      *
    15                        ;*           - Write Full LBA count sequentially or staggered                                     *
    16                        ;*         - Note: Write pattern is $55AA for Sequential Write                                    *
    17                        ;*                 Write pattern is User defined for Write Benchmark                              *
    18                        ;*                                                                                                *
    19                        ;**************************************************************************************************
    20                        
    21                                PL      66      ;Page Length
    22                                PW      132     ;Page Width (# of char/line)
    23                                CHIP    W65C02S ;Enable WDC 65C02 instructions
    24                                PASS1   OFF     ;Set ON when used for debug
    25                                INCLIST ON      ;Set ON for listing Include files
    26                        ;**************************************************************************************************
    27                        ;
    28                        ; C02BIOS/C02Monitor Version 4.0x is the supported BIOS/Monitor level for this utility!
    29                        ;
    30                        ; This BIOS and Monitor version also use a common source file for constants and variables used by
    31                        ; both. This just simplifies keeping both code pieces in sync.
    32                        ;
    33                        ;**************************************************************************************************
    34                        ;
    35                        ; Page Zero definitions $00 to $9F reserved for user routines
    36                        ; NOTES:- Locations $00 and $01 are used to zero RAM (calls CPU reset)
    37                        ;       - EEPROM Byte Write routine loaded into Page Zero at $90-$A4
    38                        ;
    39                        ;       - Page Zero definitions for HEX2BCD and BCD2HEX routines, RTC setup
    40                        ;
    41             00000010   HPHANTOM        .EQU    $0010           ; HPHANTOM MUST be located (in target memory)
    42             00000011   HEX0AND1        .EQU    $11             ;  immediately below the HEX0AND1 variable
    43             00000012   HEX2AND3        .EQU    $12
    44             00000013   HEX4AND5        .EQU    $13
    45             00000014   HEX6AND7        .EQU    $14
    46                        ;
    47             00000014   DPHANTOM        .EQU    $0014           ; DPHANTOM MUST be located (in target memory)
    48             00000015   DEC0AND1        .EQU    $15             ; immediately below the DEC0AND1 variable
    49             00000016   DEC2AND3        .EQU    $16
    50             00000017   DEC4AND5        .EQU    $17
    51             00000018   DEC6AND7        .EQU    $18
    52             00000019   DEC8AND9        .EQU    $19
    53                        ;
    54             00000020   BUFADR          .EQU    $20
    55             00000021   BUFADRH         .EQU    $21
    56                        ;
    57             00000030   IBUFF           .EQU    $30             ;Input buffer... lots of space available
  Thu Mar 16 2023 11:47                                                                                                    Page 2


    58                        ;
    59             00000040   RTC_LOAD        .EQU    $40             ;Start of Data to set hardware RTC
    60                        ;
    61                        ;**************************************************************************************************
    62                        ;
    63                                INCLUDE         C02Constants4.asm       ;C02 BIOS/Monitor variables, etc.
     1                        ;**************************************************************************************************
     2                        ;*                                                                                                *
     3                        ;*              C02 Constants used for the 4.0x releases of C02BIOS4 and C02Monitor4              *
     4                        ;*                                                                                                *
     5                        ;*                                                                                                *
     6                        ;*                                  15/02/2023 (Day/Month/Year)                                   *
     7                        ;*                                                                                                *
     8                        ;**************************************************************************************************
     9                        ; C02BIOS / C02Monitor Version is now at 4.02                                                     *
    10                        ; - All Constants and Variables are now defined in a single source file (this one) for assembling *
    11                        ; - both the C02BIOS4 and the C02Monitor4. It is also used for the Template for writing code to   *
    12                        ; - be used for the C02 Pocket SBC and Adapters.                                                  *
    13                        ;                                                                                                 *
    14                        ; - Be sure to include this file at the start of any source file that needs it.                   *
    15                        ;                                                                                                 *
    16                        ;**************************************************************************************************
    17                        ;                                                                                                 *
    18                        ;          - Page Zero locations $00 to $9F (160 bytes) reserved for user applications            * 
    19                        ;                                                                                                 *
    20                        ;**************************************************************************************************
    21                        ;
    22             000000A0   PGZERO_ST       .EQU    $A0                     ;Start of Monitor Page 0 use ($A0-$CF, 48 bytes)
    23                        ;
    24             000000A0   BUFF_PG0        .EQU    PGZERO_ST+00            ;Default Page zero location for Monitor buffers
    25                        ;
    26             000000A0   INBUFF          .EQU    BUFF_PG0+00             ;Input Buffer - 4 bytes ($A0-$A3)
    27             000000A4   DATABUFF        .EQU    BUFF_PG0+04             ;Data Buffer - 6 bytes ($A4-$A9)
    28                        ;
    29                        ;       - 16-bit variables:
    30             000000AA   HEXDATAH        .EQU    PGZERO_ST+10            ;Hexadecimal input
    31             000000AB   HEXDATAL        .EQU    PGZERO_ST+11
    32             000000AC   BINVALL         .EQU    PGZERO_ST+12            ;Binary Value for HEX2ASC
    33             000000AD   BINVALH         .EQU    PGZERO_ST+13
    34             000000AE   COMLO           .EQU    PGZERO_ST+14            ;User command address
    35             000000AF   COMHI           .EQU    PGZERO_ST+15
    36             000000B0   INDEXL          .EQU    PGZERO_ST+16            ;Index for address - multiple routines
    37             000000B1   INDEXH          .EQU    PGZERO_ST+17
    38             000000B2   TEMP1L          .EQU    PGZERO_ST+18            ;Index for word temp value used by Memdump
    39             000000B3   TEMP1H          .EQU    PGZERO_ST+19
    40             000000B4   TEMP2L          .EQU    PGZERO_ST+20            ;Index for Text entry
    41             000000B5   TEMP2H          .EQU    PGZERO_ST+21
    42             000000B6   PROMPTL         .EQU    PGZERO_ST+22            ;Prompt string address
    43             000000B7   PROMPTH         .EQU    PGZERO_ST+23
    44             000000B8   SRCL            .EQU    PGZERO_ST+24            ;Source address for memory operations
    45             000000B9   SRCH            .EQU    PGZERO_ST+25
    46             000000BA   TGTL            .EQU    PGZERO_ST+26            ;Target address for memory operations
    47             000000BB   TGTH            .EQU    PGZERO_ST+27
    48             000000BC   LENL            .EQU    PGZERO_ST+28            ;Length address for memory operations
    49             000000BD   LENH            .EQU    PGZERO_ST+29
    50                        ;
    51                        ;       - 8-bit variables and constants:
    52             000000BE   BUFIDX          .EQU    PGZERO_ST+30            ;Buffer index
    53             000000BF   BUFLEN          .EQU    PGZERO_ST+31            ;Buffer length
    54             000000C0   IDX             .EQU    PGZERO_ST+32            ;Temp Indexing
    55             000000C1   IDY             .EQU    PGZERO_ST+33            ;Temp Indexing
    56             000000C2   TEMP1           .EQU    PGZERO_ST+34            ;Temp - Code Conversion routines
    57             000000C3   TEMP2           .EQU    PGZERO_ST+35            ;Temp - Memory/EEPROM/SREC routines - Disassembler
  Thu Mar 16 2023 11:47                                                                                                    Page 3


    58             000000C4   TEMP3           .EQU    PGZERO_ST+36            ;Temp - EEPROM/SREC routines
    59             000000C5   CMDFLAG         .EQU    PGZERO_ST+37            ;Command Flag, bit specific, used by many routines
    60             000000C6   OPXMDM          .EQU    PGZERO_ST+38            ;Saved Opcode/Xmodem Flag variable
    61                        ;
    62                        ;       - Xmodem transfer variables
    63             000000C7   CRCHI           .EQU    PGZERO_ST+39            ;CRC hi byte  (two byte variable)
    64             000000C8   CRCLO           .EQU    PGZERO_ST+40            ;CRC lo byte - Operand in Disassembler
    65             000000C9   CRCCNT          .EQU    PGZERO_ST+41            ;CRC retry count - Operand in Disassembler
    66             000000CA   PTRL            .EQU    PGZERO_ST+42            ;Data pointer lo byte - Mnemonic in Disassembler
    67             000000CB   PTRH            .EQU    PGZERO_ST+43            ;Data pointer hi byte - Mnemonic in Disassembler
    68             000000CC   BLKNO           .EQU    PGZERO_ST+44            ;Block number
    69                        ;
    70                        ;        - Macro Loop Counter variables
    71             000000CD   LPCNTL          .EQU    PGZERO_ST+45            ;Loop Count low byte
    72             000000CE   LPCNTH          .EQU    PGZERO_ST+46            ;Loop Count high byte
    73                        ;
    74                        ;       - Spare Monitor byte for future use
    75             000000CF   SPARE_M0        .EQU    PGZERO_ST+47            ;Spare Monitor page zero byte
    76                        ;
    77                        ;       - BIOS variables, pointers, flags located at top of Page Zero
    78             000000D0   BIOS_PG0        .EQU    PGZERO_ST+48            ;Start of BIOS page 0 use ($D0-$FF, 48 bytes)
    79                        ;
    80                        ;       - BRK handler routine
    81             000000D0   PCL             .EQU    BIOS_PG0+00             ;Program Counter Low index
    82             000000D1   PCH             .EQU    BIOS_PG0+01             ;Program Counter High index
    83             000000D2   PREG            .EQU    BIOS_PG0+02             ;Temp Status Reg
    84             000000D3   SREG            .EQU    BIOS_PG0+03             ;Temp Stack ptr
    85             000000D4   YREG            .EQU    BIOS_PG0+04             ;Temp Y Reg
    86             000000D5   XREG            .EQU    BIOS_PG0+05             ;Temp X Reg
    87             000000D6   AREG            .EQU    BIOS_PG0+06             ;Temp A Reg
    88                        ;
    89                        ;       - 28L92 IRQ handler pointers and status
    90             000000D7   ICNT_A          .EQU    BIOS_PG0+07             ;Input buffer count
    91             000000D8   IHEAD_A         .EQU    BIOS_PG0+08             ;Input buffer head pointer
    92             000000D9   ITAIL_A         .EQU    BIOS_PG0+09             ;Input buffer tail pointer
    93             000000DA   OCNT_A          .EQU    BIOS_PG0+10             ;Output buffer count
    94             000000DB   OHEAD_A         .EQU    BIOS_PG0+11             ;Output buffer head pointer
    95             000000DC   OTAIL_A         .EQU    BIOS_PG0+12             ;Output buffer tail pointer
    96                        ;
    97             000000DD   ICNT_B          .EQU    BIOS_PG0+13             ;Input buffer count
    98             000000DE   IHEAD_B         .EQU    BIOS_PG0+14             ;Input buffer head pointer
    99             000000DF   ITAIL_B         .EQU    BIOS_PG0+15             ;Input buffer tail pointer
   100             000000E0   OCNT_B          .EQU    BIOS_PG0+16             ;Output buffer count
   101             000000E1   OHEAD_B         .EQU    BIOS_PG0+17             ;Output buffer head pointer
   102             000000E2   OTAIL_B         .EQU    BIOS_PG0+18             ;Output buffer tail pointer
   103             000000E3   UART_IRT        .EQU    BIOS_PG0+19             ;SC28L92 Interrupt Status byte
   104                        ;
   105                        ;       - Real-Time Clock variables
   106                        ; These are repurposed for adding a Realtime clock chip (DS1501/DS1511)
   107                        ; The Ticks, Seconds, Minutes and Hours remain the same in function.
   108                        ; The 16-bit Days variable is replaced however.
   109                        ; - The DAY_DATE is a new variable. To minimize Page Zero usage, it has two functions
   110                        ;       Bits 0-4 represent the days of the Month 1-31
   111                        ;       Bits 5-7 represent the Day of the Week, 1-7 (Saturday=1)
   112                        ; The Months are handled by the upper 4 bits of the MONTH_YEAR variable
   113                        ; The Century is handled by a the Year (0-255) and the lower 4 bits of the MONTH_YEAR variable
   114                        ;
   115             000000E4   TICKS           .EQU    BIOS_PG0+20             ;Number of timer countdowns = 1 second (100)
   116             000000E5   SECS            .EQU    BIOS_PG0+21             ;Seconds: 0-59
   117             000000E6   MINS            .EQU    BIOS_PG0+22             ;Minutes: 0-59
   118             000000E7   HOURS           .EQU    BIOS_PG0+23             ;Hours: 0-23
   119             000000E8   DAY_DATE        .EQU    BIOS_PG0+24             ;Day: (bits 5-7) Date: (bits 0-4)
   120             000000E9   MONTH_CENTURY   .EQU    BIOS_PG0+25             ;Month: (bits 4-7) Century: (bits 0-3)
  Thu Mar 16 2023 11:47                                                                                                    Page 4


   121             000000EA   YEAR            .EQU    BIOS_PG0+26             ;Century 0-255 plus 4 bits as noted above
   122             000000EB   RTC_TEMP        .EQU    BIOS_PG0+27             ;Temp work byte for updating shared variables
   123                        ;
   124                        ;       - Delay Timer variables
   125             000000EC   MSDELAY         .EQU    BIOS_PG0+28             ;Timer delay countdown byte (255 > 0)
   126             000000ED   SETMS           .EQU    BIOS_PG0+29             ;Set timeout for delay routines - BIOS use only
   127             000000EE   DELLO           .EQU    BIOS_PG0+30             ;Delay value BIOS use only
   128             000000EF   DELHI           .EQU    BIOS_PG0+31             ;Delay value BIOS use only
   129                        ;
   130                        ;       - Count variables for 10ms benchmark timing
   131             000000F0   MS10_CNT        .EQU    BIOS_PG0+32             ;10ms Count variable
   132             000000F1   SECL_CNT        .EQU    BIOS_PG0+33             ;Seconds Low byte count
   133             000000F2   SECH_CNT        .EQU    BIOS_PG0+34             ;Seconds High byte count
   134                        ;
   135                        ;       - Address and pointers for IDE Interface
   136             000000F3   LBA_ADDR_LOW    .EQU    BIOS_PG0+35             ;LBA Transfer Address low byte
   137             000000F4   LBA_ADDR_HIGH   .EQU    BIOS_PG0+36             ;LBA Transfer Address high byte
   138                        ;
   139             000000F5   LBA_XFER_CNT    .EQU    BIOS_PG0+37             ;LBA Transfer Count 1-xx (check RAM space!)
   140             000000F6   LBA_LOW_BYTE    .EQU    BIOS_PG0+38             ;LBA Block number bits 0-7
   141             000000F7   LBA_HIGH_BYTE   .EQU    BIOS_PG0+39             ;LBA Block number bits 8-15
   142             000000F8   LBA_EXT_BYTE    .EQU    BIOS_PG0+40             ;LBA Block number bits 16-23
   143                        ;
   144             000000F9   BIOS_XFERL      .EQU    BIOS_PG0+41             ;BIOS Move Routine low byte
   145             000000FA   BIOS_XFERH      .EQU    BIOS_PG0+42             ;BIOS Move Routine high byte
   146             000000FB   BIOS_XFERC      .EQU    BIOS_PG0+43             ;BIOS Block Count moved (needs to be set)
   147                        ;
   148             000000FC   IDE_STATUS_RAM  .EQU    BIOS_PG0+44             ;IDE RAM-Based Status
   149                        ;
   150             000000FD   SPARE_B0        .EQU    BIOS_PG0+45             ;Spare byte 0
   151             000000FE   SPARE_B1        .EQU    BIOS_PG0+46             ;Spare byte 1
   152                        ;
   153                        ;       - Timer/Counter Match flag for Delay/Benchmark
   154             000000FF   MATCH           .EQU    BIOS_PG0+47             ;Bit7 used for Delay, Bit6 used for Benchmark
   155                                                                        ;Bits 3,2,1 used for IDE Interrupt Handler
   156                        ;
   157                        ;       - Default for RTC tick count - number of IRQs for 1 second
   158             00000064   DF_TICKS        .EQU    100                     ;Timer is 10 milliseconds (100 x 10ms = 1 second)
   159                        ;
   160                        ;**************************************************************************************************
   161             00000200   IBUF_A          .EQU    $0200                   ;Console Input Buffer - 128 bytes
   162             00000280   OBUF_A          .EQU    $0280                   ;Console Output Buffer - 128 bytes
   163                        ;
   164             00000400   IBUF_B          .EQU    $0400                   ;Alternate Input Buffer - 128 bytes
   165             00000480   OBUF_B          .EQU    $0480                   ;Alternate Output Buffer - 128 bytes
   166                        ;**************************************************************************************************
   167             00000300   SOFTVEC         .EQU    $0300                   ;Start of soft vectors
   168                        ;The Interrupt structure is vector based. During startup, Page $03 is loaded from ROM.
   169                        ; The soft vectors are structured to allow inserting additional routines either before
   170                        ; or after the ROM based routines. This allows flexibility and changing of routine priority.
   171                        ;
   172                        ;The main set of vectors occupy the first 16 bytes of Page $03. The ROM handler for
   173                        ; NMI, BRK and IRQ jump to the first 3 vectors. The following 3 vectors are loaded with
   174                        ; return addresses to the ROM handler for each. The following 2 vectors are the cold and
   175                        ; warm entry points for the Monitor. After the basic initialization, the monitor is entered.
   176                        ;
   177                        ;The following vector set allows inserts, pre or post for NMI/BRK/IRQ. There a total of 8 inserts
   178                        ; which occupy 16 bytes. They can be used as required.
   179                        ; Currently, VECINSRT0 will be used if an IDE Controller is detected.
   180                        ;
   181             00000300   NMIVEC0         .EQU    SOFTVEC+00              ;NMI Vector Entry 0
   182             00000302   BRKVEC0         .EQU    SOFTVEC+02              ;BRK Vector Entry 0
   183             00000304   IRQVEC0         .EQU    SOFTVEC+04              ;IRQ Vector Entry 0
  Thu Mar 16 2023 11:47                                                                                                    Page 5


   184                        ;
   185             00000306   NMIRTVEC0       .EQU    SOFTVEC+06              ;NMI Vector Return 0
   186             00000308   BRKRTVEC0       .EQU    SOFTVEC+08              ;BRK Vector Return 0
   187             0000030A   IRQRTVEC0       .EQU    SOFTVEC+10              ;IRQ Vector Return 0
   188                        ;
   189             0000030C   CLDMNVEC0       .EQU    SOFTVEC+12              ;Monitor Cold Entry Vector 0
   190             0000030E   WRMMNVEC0       .EQU    SOFTVEC+14              ;Monitor Warm Entry Vector 0
   191                        ;
   192             00000310   VECINSRT0       .EQU    SOFTVEC+16              ;1st Vector Insert
   193             00000312   VECINSRT1       .EQU    SOFTVEC+18              ;2nd Vector Insert
   194             00000314   VECINSRT2       .EQU    SOFTVEC+20              ;3rd Vector Insert
   195             00000316   VECINSRT3       .EQU    SOFTVEC+22              ;4th Vector Insert
   196             00000318   VECINSRT4       .EQU    SOFTVEC+24              ;5th Vector Insert
   197             0000031A   VECINSRT5       .EQU    SOFTVEC+26              ;6th Vector Insert
   198             0000031C   VECINSRT6       .EQU    SOFTVEC+28              ;7th Vector Insert
   199             0000031E   VECINSRT7       .EQU    SOFTVEC+30              ;8th Vector Insert
   200                        ;
   201                        ;**************************************************************************************************
   202                        ;
   203                        ;Soft Config values below are loaded from ROM and are the default I/O setup Configuration data that
   204                        ; the INIT_x routines use. As a result, you can write a routine to change the I/O Configuration
   205                        ; data and use the standard ROM routines to initialize the I/O without restarting or changing ROM
   206                        ; A Reset (HW or coded) will reinitialize the I/O with the ROM default I/O Configuration.
   207                        ;
   208                        ;There are a total of 32 Bytes Configuration data reserved starting at $0320,
   209                        ; - 22 bytes are reserved for the NXP SC28L92 DUART.
   210                        ;
   211             00000320   SOFTCFG         .EQU    SOFTVEC+32              ;Start of hardware Config parameters
   212                        ;
   213             00000320   LOAD_28L92      .EQU    SOFTCFG+00              ;SC28L92 Soft Config Data
   214                        ;
   215                        ; The configuration for the DUART consists of 14 parameters/commands stored in the following
   216                        ; - memory locations. Note that these are sent in reverse, i.e., $32E thru $320.
   217                        ;
   218                        ;       $320    .DB     %00000011       $03     ;Enable OP0/1 for RTS control Port A/B
   219                        ;       $321    .DB     %00001010       $A0     ;Disable Receiver/Disable Transmitter B
   220                        ;       $322    .DB     %00001001       $09     ;Enable Receiver/Disable Transmitter A
   221                        ;       $323    .DB     %00001111       $0F     ;Interrupt Mask Register setup
   222                        ;       $324    .DB     %11100000       $E0     ;Aux Register setup for Counter/Timer
   223                        ;       $325    .DB     %01001000       $48     ;Counter/Timer Upper Preset (18432 decimal)
   224                        ;       $326    .DB     %00000000       $00     ;Counter/Timer Lower Preset
   225                        ;       $327    .DB     %11001100       $CC     ;Baud Rate clock for B Rcv/Xmt - 115.2K
   226                        ;       $328    .DB     %11001100       $CC     ;Baud Rate clock for A Rcv/Xmt - 115.2K
   227                        ;       $329    .DB     %00110000       $30     ;Reset Transmitter B
   228                        ;       $32A    .DB     %00100000       $20     ;Reset Receiver B
   229                        ;       $32B    .DB     %00110000       $30     ;Reset Transmitter A
   230                        ;       $32C    .DB     %00100000       $20     ;Reset Receiver A
   231                        ;       $32D    .DB     %00000000       $00     ;Interrupt Mask Register setup (clear)
   232                        ;       $32E    .DB     %11110000       $F0     ;Command Register A - Disable Power Down
   233                        ;       $32F    .DB     %11111111       $FF     ;Spare Byte
   234                        ;
   235                        ; The MR registers of the DUART also have soft config data loaded here, but is separate from the
   236                        ; - main register config data, as these are all accessed via a single I/O port (auto-indexed).
   237                        ; - These are also sent in reverse order as above.
   238                        ;
   239                        ;       $330    .DB     %00010111       $17     ;Mode Register 2 data
   240                        ;       $331    .DB     %11010011       $D3     ;Mode Register 1 Data
   241                        ;       $332    .DB     %11111001       $F9     ;Mode Register 0 Data
   242                        ;
   243                        ;       $333    .DB     %00010111       $17     ;Mode Register 2 data
   244                        ;       $334    .DB     %11010011       $D3     ;Mode Register 1 Data
   245                        ;       $335    .DB     %11000001       $C1     ;Mode Register 0 Data
   246                        ;
  Thu Mar 16 2023 11:47                                                                                                    Page 6


   247                        ;       10 additional bytes all reserved as $FF fill up the remaining soft configuration data.
   248                        ;
   249                        ; The Microdrive is initialized and the total LBA count is save here during startup.
   250                        ;  It is used by various utilities and allows drive capacity sensing without sending additional
   251                        ;  commands to the Microdrive. A total of 4 bytes are used for a 32-bit LBA count. These are saved
   252                        ;  at addresses $33C - $33F. Order is low-word/high-word. Each word is low-byte/high/byte.
   253                        ;
   254             0000033C   LOAD_IDE        .EQU    SOFTCFG+28              ;IDE/CF-Card Soft Config Data
   255                        ;
   256                        ;       $33C    .DW                             ;Low order LBA count
   257                        ;       $33E    .DW                             ;High order LBA count
   258                        ;
   259                        ;Search Buffer is 16 bytes in length. Used to hold search string for text or hex data
   260             00000340   SRCHBUFF        .EQU    SOFTCFG+32              ;Located in Page $03 following Hardware Config data
   261                        ;       $340                                    ;Start of search buffer (16 bytes)
   262                        ;
   263                        ;Xmodem/CRC Loader also provides Motorola S19 Record sense and load. Designed to handle the S19
   264                        ; records from the WDC Assembler/Linker package. This requires a 44 byte buffer to parse each valid
   265                        ; S1 record, located just before the 132 Byte Xmodem frame buffer. Total Buffer space for the
   266                        ; Xmodem/CRC Loader is 176 bytes
   267                        ;
   268                        ;Valid S-record headers are "S1" and "S9". For S1, the maximum length is "$19" hex. The last S1
   269                        ; record can be less. S9 record is always the last record with no data. WDC Linker also appends
   270                        ; a CR/LF to the end of each record for a total of 44 bytes.
   271                        ;
   272             00000350   SRBUFF          .EQU    SOFTCFG+48              ;S-Record buffer, up to 44 bytes in length
   273                        ;       $350                                    ;Start of S-Record buffer
   274                        ;
   275                        ;Xmodem frame buffer. The entire Xmodem frame is buffered here and then checked for proper header
   276                        ; and frame number, CRC-16 on the data, then moved to user RAM.
   277             0000037C   RBUFF           .EQU    SOFTCFG+92              ;Xmodem temp 132 byte receive buffer
   278                        ;       $37C                                    ;Start of Receive buffer for Xmodem
   279                        ;
   280                        ;Page $03 is completely allocated for Buffers, Config Data and Vector pointers.
   281                        ; Some of the buffer space can be used as needed, provided any required Monitor functions are NOT
   282                        ; being used concurrently.
   283                        ;
   284                        ;**************************************************************************************************
   285                        ;
   286                        ;Page $05 is used for the Realtime Clock NVRAM read and write routines
   287             00000500   NVRAM_DATA      .EQU    $0500                   ;NVRAM Data Buffer address
   288                        ;
   289                        ;**************************************************************************************************
   290                        ;
   291                        ;Pages $06 - $07 are used for the IDE device Block Buffer (512 bytes)
   292             00000600   LBA_BUFFER      .EQU    $0600                   ;Default IDE Block Buffer address
   293             00000800   BOOT_BUFFER     .EQU    $0800                   ;Default IDE Boot Buffer address
   294                        ; 
   295                        ;**************************************************************************************************
   296                        ;XMODEM Control Character Constants
   297             00000001   SOH             .EQU    $01                     ;Start of Block Header
   298             00000004   EOT             .EQU    $04                     ;End of Text marker
   299             00000006   ACK             .EQU    $06                     ;Good Block Acknowledge
   300             00000015   NAK             .EQU    $15                     ;Bad Block Acknowledged
   301             00000018   CAN             .EQU    $18                     ;Cancel character
   302                        ;
   303                        ;**************************************************************************************************
   304                        ;RAM location used for the EEPROM Byte Write routine
   305                        ; EEPROM is the address offset of the AT28BV256 in the hardware memory map and added to the
   306                        ; EEPROM address locations required to unlock the AT28BV256 for insitu programming. For more
   307                        ; information, refer to the AT28BV256 Datasheet.
   308                        ;
   309             00000070   BURN_BYTE       .EQU    $0070                   ;Page 0 RAM for EEPROM BYTE write routine
  Thu Mar 16 2023 11:47                                                                                                    Page 7


   310             00008000   EEPROM          .EQU    $8000                   ;Offset to EEPROM in hardware
   311                        ;**************************************************************************************************
   312                        ;DOS/65 can be called from the Monitor via the Ctrl-B command.
   313                        ;The start location is just added here for convenience, but should be changed if needed.
   314                        ;
   315             0000D630   DOS_65          .EQU    $D630                   ;Default location to Boot DOS/65 (optional)
   316                        ;**************************************************************************************************
   317             0000FE00   IOPAGE          .EQU    $FE00                   ;I/O Page Base Start Address
   318                        ;**************************************************************************************************
   319             0000FE80   SC28L92_BASE    .EQU    IOPAGE+$80              ;Beginning of Console UART address
   320                        ;
   321             0000FE80   UART_MODEREG_A  .EQU    SC28L92_BASE+$00        ;MR0/MR1/MR2 Port A sequential (Read/Write)
   322             0000FE81   UART_STATUS_A   .EQU    SC28L92_BASE+$01        ;UART Status Register Port A (READ)
   323             0000FE81   UART_CLKSEL_A   .EQU    SC28L92_BASE+$01        ;UART Clock Select Port A (WRITE)
   324             0000FE82   UART_RES_A      .EQU    SC28L92_BASE+$02        ;UART Reserved Port A (READ)
   325             0000FE82   UART_COMMAND_A  .EQU    SC28L92_BASE+$02        ;UART Command Register Port A (WRITE)
   326             0000FE83   UART_RECEIVE_A  .EQU    SC28L92_BASE+$03        ;UART Receive Register Port A (READ)
   327             0000FE83   UART_TRANSMIT_A .EQU    SC28L92_BASE+$03        ;UART Transmit Register Port A (WRITE)
   328                        ;
   329             0000FE84   UART_PORT_CHG   .EQU    SC28L92_BASE+$04        ;UART Input Port Change Register (READ)
   330             0000FE84   UART_AUXCR      .EQU    SC28L92_BASE+$04        ;UART Aux Command Register (WRITE)
   331             0000FE85   UART_ISR        .EQU    SC28L92_BASE+$05        ;UART Interrupt Status Register (READ)
   332             0000FE85   UART_IMR        .EQU    SC28L92_BASE+$05        ;UART Interrupt Mask Register (WRITE)
   333                        ;
   334             0000FE86   UART_CNTU       .EQU    SC28L92_BASE+$06        ;Counter/Timer Upper Register (READ)
   335             0000FE86   UART_CNTUP      .EQU    SC28L92_BASE+$06        ;Counter/Timer Upper Preset Register (WRITE)
   336             0000FE87   UART_CNTL       .EQU    SC28L92_BASE+$07        ;Counter/Timer Lower Register (READ)
   337             0000FE87   UART_CNTLP      .EQU    SC28L92_BASE+$07        ;Counter/Timer Lower Preset Register (WRITE)
   338                        ;
   339             0000FE88   UART_MODEREG_B  .EQU    SC28L92_BASE+$08        ;MR0/MR1/MR2 Port B sequential Read/Write
   340             0000FE89   UART_STATUS_B   .EQU    SC28L92_BASE+$09        ;UART Status Register Port B (READ)
   341             0000FE89   UART_CLKSEL_B   .EQU    SC28L92_BASE+$09        ;UART Clock Select Port B (WRITE)
   342             0000FE8A   UART_RES_B      .EQU    SC28L92_BASE+$0A        ;UART Reserved Port B (READ)
   343             0000FE8A   UART_COMMAND_B  .EQU    SC28L92_BASE+$0A        ;UART Command Register Port B (WRITE)
   344             0000FE8B   UART_RECEIVE_B  .EQU    SC28L92_BASE+$0B        ;UART Receive Register Port B (READ)
   345             0000FE8B   UART_TRANSMIT_B .EQU    SC28L92_BASE+$0B        ;UART Transmit Register Port B (WRITE)
   346                        ;
   347             0000FE8C   UART_MISC       .EQU    SC28L92_BASE+$0C        ;UART Miscellaneous Register Intel (Read/Write)
   348             0000FE8D   UART_INPUT_PORT .EQU    SC28L92_BASE+$0D        ;UART Input Port Register (READ)
   349             0000FE8D   UART_OUT_CFG    .EQU    SC28L92_BASE+$0D        ;UART Ouput Port Config Register (WRITE)
   350             0000FE8E   UART_START_CNT  .EQU    SC28L92_BASE+$0E        ;UART Start Counter Command (READ)
   351             0000FE8E   UART_SOPR_CMD   .EQU    SC28L92_BASE+$0E        ;UART Set Output Port Bits Register (WRITE)
   352             0000FE8F   UART_STOP_CNT   .EQU    SC28L92_BASE+$0F        ;UART Stop Counter Command (READ)
   353             0000FE8F   UART_ROPR_CMD   .EQU    SC28L92_BASE+$0F        ;UART Reset Output Port Bits Register (WRITE)
   354                        ;
   355                        ;Additional Hardware
   356                        ; Adding BIOS definitions for Realtime Clock chip - DS1511
   357                        ; uses the first 16 addresses for RTC registers and basic operation
   358                        ; uses two addresses for extended RAM of 256 bytes
   359                        ;
   360                        ; upper addresses are used for a 16-bit IDE interface (below)
   361                        ; NOTE: offset $11 and $12 are unused (reserved per the datasheet).
   362                        ;
   363             0000FE60   RTC_IDE_BASE    .EQU    IOPAGE+$60              ;Beginning of Realtime Clock address
   364                        ;
   365             0000FE60   RTC_SECONDS     .EQU    RTC_IDE_BASE+$00        ;Seconds in BCD 00-59
   366             0000FE61   RTC_MINUTES     .EQU    RTC_IDE_BASE+$01        ;Minutes in BCD 00-59
   367             0000FE62   RTC_HOURS       .EQU    RTC_IDE_BASE+$02        ;Hours in BCD 00-23
   368             0000FE63   RTC_DAY         .EQU    RTC_IDE_BASE+$03        ;Day in BCD 1-7
   369             0000FE64   RTC_DATE        .EQU    RTC_IDE_BASE+$04        ;Date in BCD 1-31
   370             0000FE65   RTC_MONTH       .EQU    RTC_IDE_BASE+$05        ;Month in BCD 1-12
   371             0000FE66   RTC_YEAR        .EQU    RTC_IDE_BASE+$06        ;Year in BCD 00-99
   372             0000FE67   RTC_CENTURY     .EQU    RTC_IDE_BASE+$07        ;Century in BCD 00-39
  Thu Mar 16 2023 11:47                                                                                                    Page 8


   373                        ;
   374             0000FE68   RTC_ALARM_SEC   .EQU    RTC_IDE_BASE+$08        ;Alarm Seconds in BCD 00-59
   375             0000FE69   RTC_ALARM_MIN   .EQU    RTC_IDE_BASE+$09        ;Alarm Minutes in BCD 00-59
   376             0000FE6A   RTC_ALARM_HRS   .EQU    RTC_IDE_BASE+$0A        ;Alarm Hours in BCD 00-23
   377             0000FE6B   RTC_ALARM_DYDT  .EQU    RTC_IDE_BASE+$0B        ;Alarm Day/Date in BCD 0-7 1-31
   378             0000FE6C   RTC_WTCHDOG_01  .EQU    RTC_IDE_BASE+$0C        ;Watchdog 0.1 / 0.01 Seconds in BCD 00-99
   379             0000FE6D   RTC_WTCHDOG_10  .EQU    RTC_IDE_BASE+$0D        ;Watchdog 10 / 1 Seconds in BCD 00-99
   380                        ;
   381             0000FE6E   RTC_CONTROL_A   .EQU    RTC_IDE_BASE+$0E        ;Control A
   382             0000FE6F   RTC_CONTROL_B   .EQU    RTC_IDE_BASE+$0F        ;Control B
   383             0000FE70   RTC_RAM_ADDR    .EQU    RTC_IDE_BASE+$10        ;Extended RAM address
   384             0000FE73   RTC_RAM_DATA    .EQU    RTC_IDE_BASE+$13        ;Extended RAM data
   385                        ;
   386                        ; Adding BIOS definitions for 16-bit IDE interface
   387                        ; uses two addresses for Upper Byte Latch read / write
   388                        ; uses eight addresses for Command Block Registers
   389                        ; uses two addresses for Control Block Registers
   390                        ;
   391             0000FE74   IDE_16_READ     .EQU    RTC_IDE_BASE+$14        ;Upper byte Read address
   392             0000FE75   IDE_16_WRITE    .EQU    RTC_IDE_BASE+$15        ;Upper byte Write address
   393                        ;
   394                        ; Adding BIOS definitions for IDE Controller (HARD DISK, Flash Module, etc.)
   395                        ; Hardware Adapter provides a 16-bit IDE Port per:
   396                        ;  Seagate ATA Interface Reference Manual 36111-001, Rev. C (21st May 1993)
   397                        ;
   398                        ; Control Block Registers
   399             0000FE76   IDE_ALT_STATUS  .EQU    RTC_IDE_BASE+$16        ;Alternate Status Register (READ)
   400             0000FE76   IDE_DEV_CTRL    .EQU    RTC_IDE_BASE+$16        ;Device Control Register (WRITE)
   401             0000FE77   IDE_DRV_ADDR    .EQU    RTC_IDE_BASE+$17        ;Drive Address Register (READ)
   402                        ;
   403                        ; Command Block Registers
   404             0000FE78   IDE_DATA        .EQU    RTC_IDE_BASE+$18        ;Data Register (R/W)
   405             0000FE79   IDE_ERROR       .EQU    RTC_IDE_BASE+$19        ;Error Register (READ)
   406             0000FE79   IDE_FEATURE     .EQU    RTC_IDE_BASE+$19        ;Feature Register (WRITE)
   407             0000FE7A   IDE_SCT_CNT     .EQU    RTC_IDE_BASE+$1A        ;Sector Count Register
   408             0000FE7B   IDE_SCT_NUM     .EQU    RTC_IDE_BASE+$1B        ;Sector Number Register
   409             0000FE7C   IDE_CYL_LOW     .EQU    RTC_IDE_BASE+$1C        ;Cylinder Low Register
   410             0000FE7D   IDE_CYL_HIGH    .EQU    RTC_IDE_BASE+$1D        ;Cylinder High Register
   411             0000FE7E   IDE_DRV_HEAD    .EQU    RTC_IDE_BASE+$1E        ;Drive/Head Register
   412             0000FE7F   IDE_STATUS      .EQU    RTC_IDE_BASE+$1F        ;Status Register (READ)
   413             0000FE7F   IDE_COMMAND     .EQU    RTC_IDE_BASE+$1F        ;Command Register (WRITE)
   414                        ;
   415                        ;**************************************************************************************************
   416                                .END
    64                        ;
    65                        ;**************************************************************************************************
    66                        ;       BIOS JUMP Table starts at $FF00
    67                        ;       - BIOS calls are listed below - total of 32
    68                        ;       - Reserved calls are for future hardware support
    69                        ;**************************************************************************************************
    70                        ;
    71                        ;The following 32 functions are provided by BIOS via the JMP Table below
    72                        ;
    73             0000FF00   B_IDE_RESET     .EQU    $FF00   ;Reset IDE and Run Diagnostics
    74             0000FF03   B_IDE_GET_STAT  .EQU    $FF03   ;Get IDE Status and Extended Error codes
    75             0000FF06   B_IDE_IDENTIFY  .EQU    $FF06   ;Get IDE Identification Block
    76             0000FF09   B_IDE_READ_LBA  .EQU    $FF09   ;Read a Block from IDE device
    77             0000FF0C   B_IDE_WRITE_LBA .EQU    $FF0C   ;Write a Block to IDE device
    78             0000FF0F   B_IDE_VERFY_LBA .EQU    $FF0F   ;Verify the last Block from IDE device
    79             0000FF12   B_IDE_SET_LBA   .EQU    $FF12   ;Set the LBA Block ID for Read/Write/Verify
    80             0000FF15   B_IDE_SET_ADDR  .EQU    $FF15   ;Set the Memory Address to transfer Block data to/from
    81             0000FF18   B_IDE_EN_CACHE  .EQU    $FF18   ;Enable Write Cache
    82             0000FF1B   B_IDE_DIS_CACHE .EQU    $FF1B   ;Disable Write Cache
  Thu Mar 16 2023 11:47                                                                                                    Page 9


    83                        ;
    84             0000FF1E   B_RTC_NVRD      .EQU    $FF1E   ;Read the NVRAM from the RTC
    85             0000FF21   B_RTC_NVWR      .EQU    $FF21   ;Write the NVRAM to the RTC
    86             0000FF24   B_RTC_INIT      .EQU    $FF24   ;Initialize the Software RTC from the hardware RTC
    87                        ;
    88             0000FF27   B_CHRIN2        .EQU    $FF27   ;Data Input from second serial port
    89             0000FF2A   B_CHROUT2       .EQU    $FF2A   ;Data Output from second serial port
    90                        ;
    91             0000FF2D   B_CNT_INIT      .EQU    $FF2D   ;Initialize/Start benchmark counter
    92             0000FF30   B_CNT_STRT      .EQU    $FF30   ;Reset/Start benchmark counter
    93             0000FF33   B_CNT_STOP      .EQU    $FF33   ;Stop benchmark counter
    94                        ;
    95             0000FF36   B_CHRIN_NW      .EQU    $FF36   ;Data input from console, no waiting, clear carry if none
    96             0000FF39   B_CHRIN         .EQU    $FF39   ;Data input from console, carry set if data
    97             0000FF3C   B_CHROUT        .EQU    $FF3C   ;Data output to console, sent data preserved
    98                        ;
    99             0000FF3F   B_SET_DLY       .EQU    $FF3F   ;Set delay value for milliseconds and 16-bit counter
   100             0000FF42   B_EXE_MSDLY     .EQU    $FF42   ;Execute millisecond delay 1-256 * 10 milliseconds
   101             0000FF45   B_EXE_LGDLY     .EQU    $FF45   ;Execute long delay; millisecond delay * 16-bit count
   102                        ;
   103             0000FF48   B_RESERVE       .EQU    $FF48   ;Reserved BIOS call, executes to a RTS
   104                        ;
   105             0000FF4B   B_INIT_VEC      .EQU    $FF4B   ;Initialize soft vectors at $0300 from ROM
   106             0000FF4E   B_INIT_CFG      .EQU    $FF4E   ;Initialize soft config values at $0320 from ROM
   107             0000FF51   B_INIT_2691     .EQU    $FF51   ;Initialize SCC2691 console 38.4K, 8-N-1 RTS/CTS
   108             0000FF54   B_RESET_2691    .EQU    $FF54   ;Reset SCC2691 - called before INIT_2691
   109                        ;
   110             0000FF57   B_WRMMNVEC0     .EQU    $FF57   ;Monitor warm start - jumps to page $03
   111             0000FF5A   B_CLDMNVEC0     .EQU    $FF5A   ;Monitor cold start - jumps to page $03
   112             0000FF5D   B_COLDSTRT      .EQU    $FF5D   ;System cold start - RESET vector for 65C02
   113                        ;
   114                        ;**************************************************************************************************
   115                        ;       Monitor JUMP table starts at $E000
   116                        ;       - Monitor calls are listed below - total of 32
   117                        ;       - Reserved calls are for future functions
   118                        ;**************************************************************************************************
   119                        ;
   120             0000E000   M_COLD_MON      .EQU    $E000   ;Monitor Cold start entry
   121             0000E003   M_WARM_MON      .EQU    $E003   ;Monitor Warm start entry
   122                        ;
   123             0000E006   M_RESERVE2      .EQU    $E006   ;Reserved function call
   124                        ;
   125             0000E009   M_MOVE_RAM      .EQU    $E009   ;Move RAM block
   126             0000E00C   M_FILL_LP       .EQU    $E00C   ;Fill Memory Block
   127                        ;
   128             0000E00F   M_BSOUT         .EQU    $E00F   ;Send a Backspace to console
   129             0000E012   M_XMDM_SAVE     .EQU    $E012   ;Xmodem Save - entry point for external use
   130             0000E015   M_XMDM_LOAD     .EQU    $E015   ;Xmodem Load - entry point for external use
   131             0000E018   M_BENCH         .EQU    $E018   ;Start Benchmark Timer (resets count)
   132             0000E01B   M_QUITB         .EQU    $E01B   ;Quits Benchmark Timer (displays elapsed time)
   133             0000E01E   M_UPTIME        .EQU    $E01E   ;Displays SW-RTC Date/Time
   134             0000E021   M_PRSTAT1       .EQU    $E021   ;Displays Processor Status
   135             0000E024   M_DIS_LINE      .EQU    $E024   ;Disassembles a line of code (Mnemonic/Operand)
   136             0000E027   M_INCINDEX      .EQU    $E027   ;Increments 16-bit Index pointer
   137             0000E02A   M_DECINDEX      .EQU    $E02A   ;Decrements 16-bit Index pointer
   138             0000E02D   M_RDLINE        .EQU    $E02D   ;Read a Line of Data from console
   139             0000E030   M_RDCHAR        .EQU    $E030   ;Read a Character from console
   140             0000E033   M_HEXIN2        .EQU    $E033   ;Get two Hex digits from console entry (1-byte)
   141             0000E036   M_HEXIN4        .EQU    $E036   ;Get four Hex digits from console entry (2-bytes)
   142             0000E039   M_HEX2ASC       .EQU    $E039   ;Converts Hex into ASCII (1-byte to 2-ASCII digits)
   143             0000E03C   M_BIN2ASC       .EQU    $E03C   ;Converts Binary to ASCII
   144             0000E03F   M_ASC2BIN       .EQU    $E03F   ;Converts two ASCII digits to one byte
   145             0000E042   M_BEEP          .EQU    $E042   ;Send a Bell character to console
  Thu Mar 16 2023 11:47                                                                                                    Page 10


   146             0000E045   M_DOLLAR        .EQU    $E045   ;Send a $ character to console
   147             0000E048   M_CROUT         .EQU    $E048   ;Send a CR/LF sequence to console
   148             0000E04B   M_SPC           .EQU    $E04B   ;Send a Space character to console
   149             0000E04E   M_PRBYTE        .EQU    $E04E   ;Print a byte as two ASCII digits to console
   150             0000E051   M_PRWORD        .EQU    $E051   ;Print a word as four ASCII digits to console
   151             0000E054   M_PRASC         .EQU    $E054   ;Print ASCII character to console
   152             0000E057   M_PROMPT        .EQU    $E057   ;Print a Message number to console
   153             0000E05A   M_PROMPTR       .EQU    $E05A   ;Print a String to console (via 16-bit address)
   154             0000E05D   M_CONTINUE      .EQU    $E05D   ;Prompt to continue, else pull return address from stack and return
   155                        ;
   156             00000103   PEM             .EQU    $0103   ;PEM Entry
   157                        ;**************************************************************************************************
   158                        ;
   159                        ;       User program code can start here. Default to $0800, can be chaged as required
   160                        ;
   161                        ;**************************************************************************************************
   162                        ;
   163                                .ORG    $0800                           ;Start of User RAM for programs
   164                        ;
   165                        ; First, send an intro message to the console, Utility name and version.
   166                        ; Second, send the User Menu to the console, then enter Command mode.
   167                        ;
   168                        START
   169 00:0800: A9 07                        LDA     #<INTRO_MSG             ;Load Message address
   170 00:0802: A0 11                        LDY     #>INTRO_MSG             ;into A/Y Regs
   171 00:0804: 20 5A E0                     JSR     M_PROMPTR               ;Call Monitor routine
   172                        MENU_LOOP
   173 00:0807: A9 8F                        LDA     #<MENU_MSG              ;Load Menu address
   174 00:0809: A0 11                        LDY     #>MENU_MSG              ;into A/Y Regs
   175 00:080B: 20 5A E0                     JSR     M_PROMPTR               ;Call Monitor routine
   176                        ;
   177                        MAIN_LOOP
   178 00:080E: 20 30 E0                     JSR     M_RDCHAR                ;Wait for keystroke (converts to upper-case)
   179 00:0811: A2 0B                        LDX     #MONTAB-MONCMD-1        ;Get command list count
   180 00:0813: DD 2D 08     CMD_LP          CMP     MONCMD,X                ;Compare to command list
   181 00:0816: D0 0D                        BNE     CMD_DEC                 ;Check for next command and loop
   182 00:0818: 48                           PHA                             ;Save keystroke
   183 00:0819: 8A                           TXA                             ;Xfer Command index to A reg
   184 00:081A: 0A                           ASL     A                       ;Multiply keystroke value by 2 (command offset)
   185 00:081B: AA                           TAX                             ;Xfer Command offsett address to table MONTAB
   186 00:081C: 68                           PLA                             ;Restore keystroke (some commands send to terminal)
   187 00:081D: 20 22 08                     JSR     DOCMD                   ;Call Monitor command processor as a subroutine
   188 00:0820: 80 E5                        BRA     MENU_LOOP               ;Command processed, branch/wait for next command
   189 00:0822: 7C 39 08     DOCMD           JMP     (MONTAB,X)              ;Execute command from Table
   190                        ;
   191 00:0825: CA           CMD_DEC         DEX                             ;Decrement index count
   192 00:0826: 10 EB                        BPL     CMD_LP                  ;If more to check, loop back
   193 00:0828: 20 42 E0                     JSR     M_BEEP                  ;Beep for error, not valid command character
   194 00:082B: 80 E1                        BRA     MAIN_LOOP               ;Branch back and re-enter Monitor
   195                        ;
   196                        ; Command Code List
   197                        ;
   198                        MONCMD
   199 00:082D: 31                   .DB     "1"                             ;Set Date and Time to RTC
   200 00:082E: 32                   .DB     "2"                             ;Read NVRAM and Display
   201 00:082F: 33                   .DB     "3"                             ;Write NVRAM and Display
   202                        ;
   203 00:0830: 34                   .DB     "4"                             ;Identify MicroDrive and display
   204 00:0831: 35                   .DB     "5"                             ;Read LBA and display
   205 00:0832: 36                   .DB     "6"                             ;Write LBA and verify
   206 00:0833: 37                   .DB     "7"                             ;Sequential Read of all LBA
   207 00:0834: 38                   .DB     "8"                             ;Sequential Write of all LBA
   208 00:0835: 39                   .DB     "9"                             ;Benchmark MicroDrive Read/Write
  Thu Mar 16 2023 11:47                                                                                                    Page 11


   209 00:0836: 4D                   .DB     "M"                             ;Menu display
   210 00:0837: 53                   .DB     "S"                             ;System Transfer RAM to Disc
   211 00:0838: 51                   .DB     "Q"                             ;Quit Utility
   212                        MONTAB
   213 00:0839: 51 08                .DW     RTC_TD                          ;Address of RTC Date and Time routine
   214 00:083B: A2 09                .DW     NVRAM_RD                        ;Address of RTC NVRAM Read
   215 00:083D: B4 09                .DW     NVRAM_WR                        ;Address of RTC NVRAM Write
   216 00:083F: A5 0A                .DW     IDE_IDENTIFY                    ;Address of IDE Identify routine
   217 00:0841: 1D 0B                .DW     IDE_READ_LBA                    ;Address of IDE Read/Display LBA
   218 00:0843: A2 0B                .DW     IDE_WRITE_LBA                   ;Address of IDE Write/Verify LBA
   219 00:0845: E2 0B                .DW     IDE_SEQ_READ                    ;Address of Sequential LBA Read
   220 00:0847: C4 0C                .DW     IDE_SEQ_WRITE                   ;Address of Sequential LBA Write
   221 00:0849: 81 0D                .DW     IDE_BENCHMARK                   ;Address of IDE Benchmark
   222 00:084B: 07 08                .DW     MENU_LOOP                       ;Address of Main Menu
   223 00:084D: 28 0F                .DW     SYS_XFER                        ;Address of System Transfer
   224 00:084F: 5F 0E                .DW     QUIT                            ;Address of Quit Utility
   225                        ;
   226                        ; Realtime Clock Routines
   227                        ;
   228                        RTC_TD
   229                        ; This routine will allow the Alarm and Interrupt functions to be cleared and
   230                        ; - allow the currend Date and Time to be set. Once these have been completed,
   231                        ; - a signature will be added to the last two bytes of the NVRAM.
   232                        ;
   233                        ; The format for the current date and time:
   234                        ; - Year: 1900 - 2100 (not checked for range)
   235                        ; - Month: 1 - 12 (not checked for range)
   236                        ; - Day: 1 - 31 (not checked for number per month, common sense for input)
   237                        ; - Day of week: 1 - 7 (Saturday is 1.... Friday is 7)
   238                        ;
   239                        ; - Hours: 0 - 23 (24 hour default)
   240                        ; - Minutes: 0 - 59
   241                        ; - Seconds: 0 - 59
   242                        ;
   243                        ; - Once confirmed, the RTC data will be updated, followed by the SW RTC
   244                        ;   being setup via the BIOS call.
   245                        ;
   246                        ; Now prompt the user to reset the Alarm functions of the DS15x1
   247                        ; - In some cases, an errant program might write the registers of the RTC chip and
   248                        ; - enable one or more of the interrupts. As the current BIOS does not handle these
   249                        ; - interrupts, it's possible the RTC will generate an interrupt and thereby lock up
   250                        ; - the system. An IRQ jumper on the board alleviates this.
   251                        ;
   252 00:0851: A9 33                        LDA     #<ALARM_CLEAR           ;Load Message address
   253 00:0853: A0 19                        LDY     #>ALARM_CLEAR           ;into A/Y regs
   254 00:0855: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   255                        ;
   256                        ALARM_PROMPT
   257 00:0858: 20 30 E0                     JSR     M_RDCHAR                ;Get character from user
   258 00:085B: 20 3C FF                     JSR     B_CHROUT                ;Send to console
   259 00:085E: C9 59                        CMP     #$59                    ;Test for yes
   260 00:0860: F0 09                        BEQ     ALARM_RESET             ;If yes, go reset alarm functions
   261 00:0862: C9 4E                        CMP     #$4E                    ;Test for no
   262 00:0864: F0 35                        BEQ     ALARM_END               ;If no, skip reset alarm functions
   263 00:0866: 20 42 E0                     JSR     M_BEEP                  ;Else, error, send beep
   264 00:0869: 80 ED                        BRA     ALARM_PROMPT            ;Branch back and try again
   265                        ;
   266                        ALARM_RESET
   267 00:086B: AD 68 FE                     LDA     RTC_ALARM_SEC           ;Get Alarm Seconds
   268 00:086E: 29 7F                        AND     #%01111111              ;Mask off Alarm bit
   269 00:0870: 8D 68 FE                     STA     RTC_ALARM_SEC           ;Save it back
   270                        ;
   271 00:0873: AD 69 FE                     LDA     RTC_ALARM_MIN           ;Get Alarm Minutes
  Thu Mar 16 2023 11:47                                                                                                    Page 12


   272 00:0876: 29 7F                        AND     #%01111111              ;Mask off Alarm bit
   273 00:0878: 8D 69 FE                     STA     RTC_ALARM_MIN           ;Save it back
   274                        ;
   275 00:087B: AD 6A FE                     LDA     RTC_ALARM_HRS           ;Get Alarm Hours
   276 00:087E: 29 7F                        AND     #%01111111              ;Mask off Alarm bit
   277 00:0880: 8D 6A FE                     STA     RTC_ALARM_HRS           ;Save it back
   278                        ;
   279 00:0883: AD 6B FE                     LDA     RTC_ALARM_DYDT          ;Get Alarm Day/Date
   280 00:0886: 29 7F                        AND     #%01111111              ;Mask off Alarm bit
   281 00:0888: 8D 6B FE                     STA     RTC_ALARM_DYDT          ;Save it back
   282                        ;
   283                        ; Now clear the Control Register bits that enable all interrupts
   284                        ;
   285 00:088B: AD 6E FE                     LDA     RTC_CONTROL_A           ;Get Control A register
   286 00:088E: 29 F0                        AND     #%11110000              ;Mask off all Alarm IRQ bits
   287 00:0890: 8D 6E FE                     STA     RTC_CONTROL_A           ;Save it back to disable alarms
   288                        ;
   289 00:0893: AD 6F FE                     LDA     RTC_CONTROL_B           ;Get Control B register
   290 00:0896: 29 E1                        AND     #%11100001              ;Mask off TPE, TIE, KIE, WDE bits
   291 00:0898: 8D 6F FE                     STA     RTC_CONTROL_B           ;Save it back to disable alarms
   292                        ;
   293                        ALARM_END
   294                        ;
   295 00:089B: A9 BD                        LDA     #<RTC_INTRO             ;Load Message address
   296 00:089D: A0 17                        LDY     #>RTC_INTRO             ;into A/Y regs
   297 00:089F: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   298                        ;
   299                        ;User prompts for RTC data, i.e., year, month, date, day, etc.
   300                        ; Note: Entry values are NOT checked for proper range!
   301                        ;
   302 00:08A2: A9 6F                        LDA     #<RTC_YEAR_M            ;Load Message address
   303 00:08A4: A0 18                        LDY     #>RTC_YEAR_M            ;into A/Y regs
   304 00:08A6: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   305                        ;
   306 00:08A9: A2 04                        LDX     #$04                    ; X-REGISTER = maximum number of digits allowed
   307 00:08AB: 20 C3 10                     JSR     RDLINE                  ;Request ASCII DECIMAL digit(s) input from terminal
   308                        ;
   309 00:08AE: 20 84 10                     JSR     ASCTODEC                ;Convert ASCII DECIMAL digits to BCD
   310 00:08B1: A5 18                        LDA     DEC6AND7                ;Get Decimal for Century (19-21)
   311 00:08B3: 85 40                        STA     RTC_LOAD+0              ;Save into Data space
   312 00:08B5: A5 19                        LDA     DEC8AND9                ;Get Decimal for Year (00-99)
   313 00:08B7: 85 41                        STA     RTC_LOAD+1              ;Save into Data space
   314                        ;
   315 00:08B9: A9 80                        LDA     #<RTC_MONTH_M           ;Load Message address
   316 00:08BB: A0 18                        LDY     #>RTC_MONTH_M           ;into A/Y regs
   317 00:08BD: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   318                        ;
   319 00:08C0: A2 02                        LDX     #$02                    ; X-REGISTER = maximum number of digits allowed
   320 00:08C2: 20 C3 10                     JSR     RDLINE                  ;Request ASCII DECIMAL digit(s) input from terminal
   321                        ;
   322 00:08C5: 20 84 10                     JSR     ASCTODEC                ;Convert ASCII DECIMAL digits to BCD
   323 00:08C8: A5 19                        LDA     DEC8AND9                ;Get Decimal for Month (1-12)
   324 00:08CA: 85 42                        STA     RTC_LOAD+2              ;Save into Data space
   325                        ;
   326 00:08CC: A9 92                        LDA     #<RTC_DATE_M            ;Load Message address
   327 00:08CE: A0 18                        LDY     #>RTC_DATE_M            ;into A/Y regs
   328 00:08D0: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   329                        ;
   330 00:08D3: A2 02                        LDX     #$02                    ; X-REGISTER = maximum number of digits allowed
   331 00:08D5: 20 C3 10                     JSR     RDLINE                  ;Request ASCII DECIMAL digit(s) input from terminal
   332                        ;
   333 00:08D8: 20 84 10                     JSR     ASCTODEC                ;Convert ASCII DECIMAL digits to BCD
   334 00:08DB: A5 19                        LDA     DEC8AND9                ;Get Decimal for Date (1-31)
  Thu Mar 16 2023 11:47                                                                                                    Page 13


   335 00:08DD: 85 43                        STA     RTC_LOAD+3              ;Save into Data space
   336                        ;
   337 00:08DF: A9 A3                        LDA     #<RTC_DAY_M             ;Load Message address
   338 00:08E1: A0 18                        LDY     #>RTC_DAY_M             ;into A/Y regs
   339 00:08E3: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   340                        ;
   341 00:08E6: A2 02                        LDX     #$02                    ; X-REGISTER = maximum number of digits allowed
   342 00:08E8: 20 C3 10                     JSR     RDLINE                  ;Request ASCII DECIMAL digit(s) input from terminal
   343                        ;
   344 00:08EB: 20 84 10                     JSR     ASCTODEC                ;Convert ASCII DECIMAL digits to BCD
   345 00:08EE: A5 19                        LDA     DEC8AND9                ;Get Decimal for Day of week (1-7)
   346 00:08F0: 85 44                        STA     RTC_LOAD+4              ;Save into Data space
   347                        ;
   348 00:08F2: A9 B3                        LDA     #<RTC_HOURS_M           ;Load Message address
   349 00:08F4: A0 18                        LDY     #>RTC_HOURS_M           ;into A/Y regs
   350 00:08F6: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   351                        ;
   352 00:08F9: A2 02                        LDX     #$02                    ; X-REGISTER = maximum number of digits allowed
   353 00:08FB: 20 C3 10                     JSR     RDLINE                  ;Request ASCII DECIMAL digit(s) input from terminal
   354                        ;
   355 00:08FE: 20 84 10                     JSR     ASCTODEC                ;Convert ASCII DECIMAL digits to BCD
   356 00:0901: A5 19                        LDA     DEC8AND9                ;Get Decimal for Hours (00-23)
   357 00:0903: 85 45                        STA     RTC_LOAD+5              ;Save into Data space
   358                        ;
   359 00:0905: A9 C5                        LDA     #<RTC_MINUTES_M         ;Load Message address
   360 00:0907: A0 18                        LDY     #>RTC_MINUTES_M         ;into A/Y regs
   361 00:0909: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   362                        ;
   363 00:090C: A2 02                        LDX     #$02                    ; X-REGISTER = maximum number of digits allowed
   364 00:090E: 20 C3 10                     JSR     RDLINE                  ;Request ASCII DECIMAL digit(s) input from terminal
   365                        ;
   366 00:0911: 20 84 10                     JSR     ASCTODEC                ;Convert ASCII DECIMAL digits to BCD
   367 00:0914: A5 19                        LDA     DEC8AND9                ;Get Decimal for Minutes (00-59)
   368 00:0916: 85 46                        STA     RTC_LOAD+6              ;Save into Data space
   369                        ;
   370 00:0918: A9 D9                        LDA     #<RTC_SECONDS_M         ;Load Message address
   371 00:091A: A0 18                        LDY     #>RTC_SECONDS_M         ;into A/Y regs
   372 00:091C: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   373                        ;
   374 00:091F: A2 02                        LDX     #$02                    ; X-REGISTER = maximum number of digits allowed
   375 00:0921: 20 C3 10                     JSR     RDLINE                  ;Request ASCII DECIMAL digit(s) input from terminal
   376                        ;
   377 00:0924: 20 84 10                     JSR     ASCTODEC                ;Convert ASCII DECIMAL digits to BCD
   378 00:0927: A5 19                        LDA     DEC8AND9                ;Get Decimal for Seconds (00-59)
   379 00:0929: 85 47                        STA     RTC_LOAD+7              ;Save into Data space
   380                        ;
   381 00:092B: A9 ED                        LDA     #<RTC_WRITE             ;Load Message address
   382 00:092D: A0 18                        LDY     #>RTC_WRITE             ;into A/Y regs
   383 00:092F: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   384                        ;
   385                        RTC_PROMPT
   386 00:0932: 20 30 E0                     JSR     M_RDCHAR                ;Get character from user
   387 00:0935: 20 3C FF                     JSR     B_CHROUT                ;Send to console
   388 00:0938: C9 59                        CMP     #$59                    ;Test for yes
   389 00:093A: F0 09                        BEQ     RTC_TIME_SYNC           ;If yes, go set RTC
   390 00:093C: C9 4E                        CMP     #$4E                    ;Test for no
   391 00:093E: F0 4A                        BEQ     RTC_END                 ;If no, skip RTC set
   392 00:0940: 20 42 E0                     JSR     M_BEEP                  ;Else, error, send beep
   393 00:0943: 80 ED                        BRA     RTC_PROMPT              ;Branch back and try again
   394                        ;
   395                        RTC_TIME_SYNC
   396 00:0945: 20 30 E0                     JSR     M_RDCHAR                ;Get character from user
   397 00:0948: C9 0D                        CMP     #$0D                    ;Check for C/R
  Thu Mar 16 2023 11:47                                                                                                    Page 14


   398 00:094A: D0 F9                        BNE     RTC_TIME_SYNC           ;Loop until C/R entered
   399                        ;
   400                        RTC_TIME_SET
   401 00:094C: A9 80                        LDA     #%10000000              ;Get TE Bit mask
   402 00:094E: 1C 6F FE                     TRB     RTC_CONTROL_B           ;Turn off TE Bit for update
   403                        ;
   404 00:0951: A5 47                        LDA     RTC_LOAD+7              ;Get Seconds
   405 00:0953: 8D 60 FE                     STA     RTC_SECONDS             ;Set Seconds
   406                        ;
   407 00:0956: A5 46                        LDA     RTC_LOAD+6              ;Get Minutes
   408 00:0958: 8D 61 FE                     STA     RTC_MINUTES             ;Set Minutes
   409                        ;
   410 00:095B: A5 45                        LDA     RTC_LOAD+5              ;Get Hours
   411 00:095D: 8D 62 FE                     STA     RTC_HOURS               ;Set Hours
   412                        ;
   413 00:0960: A5 44                        LDA     RTC_LOAD+4              ;Get Day
   414 00:0962: 8D 63 FE                     STA     RTC_DAY                 ;Set Day
   415                        ;
   416 00:0965: A5 43                        LDA     RTC_LOAD+3              ;Get Date
   417 00:0967: 8D 64 FE                     STA     RTC_DATE                ;Set Date
   418                        ;
   419 00:096A: AD 65 FE                     LDA     RTC_MONTH               ;Get RTC Month data
   420 00:096D: 29 00                        AND     #$11100000              ;Mask off old Month (save upper 3 bits)
   421 00:096F: 05 42                        ORA     RTC_LOAD+2              ;OR in new Month
   422 00:0971: 8D 65 FE                     STA     RTC_MONTH               ;Set Month
   423                        ;
   424 00:0974: A5 41                        LDA     RTC_LOAD+1              ;Get Year
   425 00:0976: 8D 66 FE                     STA     RTC_YEAR                ;Set Year
   426                        ;
   427 00:0979: A5 40                        LDA     RTC_LOAD+0              ;Get Century
   428 00:097B: 8D 67 FE                     STA     RTC_CENTURY             :Set Century
   429                        ;
   430 00:097E: A9 80                        LDA     #%10000000              ;Get TE Bit mask
   431 00:0980: 0C 6F FE                     TSB     RTC_CONTROL_B           ;Turn on TE Bit to update
   432                        ;
   433 00:0983: A9 1B                        LDA     #<RTC_CONFIRM           ;Load Message address
   434 00:0985: A0 19                        LDY     #>RTC_CONFIRM           ;into A/Y regs
   435 00:0987: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   436                        RTC_END
   437                        ;
   438                        ; Now write the signature to NVRAM
   439                        ; - A signature of "KM" is used by BIOS to test for the presence of the RTC chip.
   440                        ; - if this siganture is found as the last two bytes ($FE and $FF), then the software
   441                        ; - RTC routine variables will be loaded from the RTC and become the active Date and
   442                        ; - Time. If not, the start of Epoch Date will be loaded as the default.
   443                        ;
   444 00:098A: A2 FE                        LDX     #$FE                    ;Load NVRAM Offset
   445 00:098C: 8E 70 FE                     STX     RTC_RAM_ADDR            ;Set index to start of signature
   446 00:098F: A9 4B                        LDA     #"K"                    ;Get first signature byte
   447 00:0991: 8D 73 FE                     STA     RTC_RAM_DATA            ;Store in NVRAM
   448 00:0994: E8                           INX                             ;Increment Offset
   449 00:0995: 8E 70 FE                     STX     RTC_RAM_ADDR            ;Set index to start of signature
   450 00:0998: A9 4D                        LDA     #"M"                    ;Get second signature byte
   451 00:099A: 8D 73 FE                     STA     RTC_RAM_DATA            ;Store in NVRAM
   452                        ;
   453 00:099D: 20 24 FF                     JSR     B_RTC_INIT              ;Init software RTC from hardware RTC
   454 00:09A0: 80 5D                        BRA     JUI_0                   ;Prompt User to return or continue
   455                        ;
   456                        NVRAM_RD
   457                        ; This routine will use the BIOS function to read the contents of NVRAM into memory
   458                        ;  The contents will be displayed in Hex and ASCII.
   459                        ;
   460 00:09A2: A9 00                        LDA     #<NVRAM_DATA            ;Load NVRAM Data address
  Thu Mar 16 2023 11:47                                                                                                    Page 15


   461 00:09A4: A0 05                        LDY     #>NVRAM_DATA            ;into A/Y regs
   462 00:09A6: 85 B0                        STA     INDEXL                  ;And same into
   463 00:09A8: 84 B1                        STY     INDEXH                  ;Index for display
   464 00:09AA: 20 1E FF                     JSR     B_RTC_NVRD              ;Call BIOS to load NVRAM
   465 00:09AD: A2 10                        LDX     #$10                    ;Set index for 16 rows (256 bytes)
   466 00:09AF: 20 02 0A                     JSR     DUMP                    ;Display NVRAM data
   467                        ;
   468 00:09B2: 80 4B                        BRA     JUI_0                   ;Prompt user for what to do
   469                        ;
   470                        NVRAM_WR
   471                        ; This routine will use the BIOS function to write the contents of NVRAM from memory
   472                        ;  The contents are written from the NVRAM Data area, normally $0500 or from a user
   473                        ;  entered address. The user can edit the memory before invoking the MDUTIL program.
   474                        ;  Note that the signature to validate the presence of the RTC is not checked before
   475                        ;  it is written. This allows the RTC to be removed from the BIOS detection by changing
   476                        ;  the signature to an invalid 2-bytes.
   477                        ;
   478                        ; First, present a message to warn the user, then request an address for the block of
   479                        ;  data to be written to the NVRAM. If no input from the user is received, the default
   480                        ;  NVRAM_DATA location ($0500) will be used. Once this is done, the user is prompted to
   481                        ;  confirm the NVRAM write.
   482                        ;
   483 00:09B4: A9 7B                        LDA     #<NVRAM_WRMSG           ;Load Message address
   484 00:09B6: A0 19                        LDY     #>NVRAM_WRMSG           ;into A/Y regs
   485 00:09B8: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   486                        ;
   487 00:09BB: 20 36 E0                     JSR     M_HEXIN4                ;Get load address from user
   488 00:09BE: D0 04                        BNE     SET_NVRAM               ;If data entered, use it
   489                        ;
   490 00:09C0: A9 00                        LDA     #<NVRAM_DATA            ;Else, load NVRAM Data address
   491 00:09C2: A0 05                        LDY     #>NVRAM_DATA            ;into A/Y regs
   492                        SET_NVRAM
   493 00:09C4: 85 B0                        STA     INDEXL                  ;Else, save user entered
   494 00:09C6: 84 B1                        STY     INDEXH                  ; address for NVRAM write
   495 00:09C8: 48                           PHA                             ;Save address to stack
   496 00:09C9: 5A                           PHY                             ;to confirm write later
   497                        NV_SHOW
   498 00:09CA: A2 10                        LDX     #$10                    ;Set index for display page
   499 00:09CC: 20 02 0A                     JSR     DUMP                    ;Show data to be written to NVRAM
   500                        ;
   501 00:09CF: A9 CC                        LDA     #<NVRAM_CONF            ;Load Confirm message address
   502 00:09D1: A0 19                        LDY     #>NVRAM_CONF            ;into A/Y regs
   503 00:09D3: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   504                        ;
   505                        NVRAM_PROMPT
   506 00:09D6: 20 30 E0                     JSR     M_RDCHAR                ;Get character from user
   507 00:09D9: 20 3C FF                     JSR     B_CHROUT                ;Send to console
   508 00:09DC: C9 59                        CMP     #$59                    ;Test for yes
   509 00:09DE: F0 09                        BEQ     NV_WRITE_DATA           ;If yes, go reset alarm functions
   510 00:09E0: C9 4E                        CMP     #$4E                    ;Test for no
   511 00:09E2: F0 16                        BEQ     NV_NO_WRITE             ;If no, skip RTC set
   512 00:09E4: 20 42 E0                     JSR     M_BEEP                  ;Else, error, send beep
   513 00:09E7: 80 ED                        BRA     NVRAM_PROMPT            ;Branch back and try again
   514                        ;
   515                        NV_WRITE_DATA
   516 00:09E9: 20 48 E0                     JSR     M_CROUT                 ;Send C/R to console
   517 00:09EC: 7A                           PLY                             ;Restore address from stack
   518 00:09ED: 68                           PLA                             ;for NVRAM write
   519 00:09EE: 20 21 FF                     JSR     B_RTC_NVWR              ;Call BIOS to write NVRAM
   520 00:09F1: A9 FA                        LDA     #<NVRAM_DONE            ;Load Complete message address
   521 00:09F3: A0 19                        LDY     #>NVRAM_DONE            ;into A/Y regs
   522 00:09F5: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   523 00:09F8: 80 05                        BRA     JUI_0                   ;Prompt User
  Thu Mar 16 2023 11:47                                                                                                    Page 16


   524                        ;
   525                        NV_NO_WRITE
   526 00:09FA: 7A                           PLY                             ;Restore address from stack
   527 00:09FB: 68                           PLA                             ;for NVRAM write
   528 00:09FC: 20 48 E0                     JSR     M_CROUT                 ;Send C/R to console
   529 00:09FF: 4C 77 0E     JUI_0           JMP     USER_INPUT              ;Prompt User
   530                        ;
   531                        ;[D] HEX/TEXT DUMP command:
   532                        ; Display in HEX followed by TEXT, the contents of 256 consecutive memory addresses
   533                        ;
   534                        DUMP
   535 00:0A02: 8E A9 21                     STX     ROWS                    ;Save Row count
   536 00:0A05: 64 B2                        STZ     TEMP1L                  ;Clear Offset to data
   537 00:0A07: 64 B3                        STZ     TEMP1H                  ;used for showing loaded data from device
   538                        ;
   539 00:0A09: 20 5B 0A     LINED           JSR     DMPGR                   ;Send address offsets to terminal
   540 00:0A0C: 20 89 0A                     JSR     GLINE                   ;Send horizontal line to terminal
   541 00:0A0F: 20 48 E0                     JSR     M_CROUT                 ;Send CR,LF to terminal
   542 00:0A12: AE A9 21                     LDX     ROWS                    ;Set line count for rows displayed
   543 00:0A15: 20 4B E0     DLINE           JSR     M_SPC                   ;Send 4 Spaces to terminal
   544 00:0A18: 20 4B E0                     JSR     M_SPC
   545 00:0A1B: 20 4B E0                     JSR     M_SPC
   546 00:0A1E: 20 4B E0                     JSR     M_SPC
   547 00:0A21: 20 94 0A                     JSR     PROFFSET                ;Print INDEX value
   548 00:0A24: 20 4B E0                     JSR     M_SPC                   ;Send 2 Spaces to terminal
   549 00:0A27: 20 4B E0                     JSR     M_SPC
   550 00:0A2A: A0 00                        LDY     #$00                    ;Initialize line byte counter
   551                        GETBYT
   552 00:0A2C: B2 B0                        LDA     (INDEXL)
   553 00:0A2E: 99 40 03                     STA     SRCHBUFF,Y              ;Save in Search buffer (16 bytes)
   554 00:0A31: 20 4E E0                     JSR     M_PRBYTE                ;Display byte as a HEX value
   555 00:0A34: 20 4B E0                     JSR     M_SPC                   ;Send Space to terminal
   556 00:0A37: 20 27 E0                     JSR     M_INCINDEX              ;Increment Index to next byte location
   557 00:0A3A: 20 9E 0A                     JSR     INCOFFSET               ;Increment Offset address
   558 00:0A3D: C8                           INY                             ;Increment index
   559 00:0A3E: C0 10                        CPY     #$10                    ;Check for all 16
   560 00:0A40: D0 EA                        BNE     GETBYT                  ;Loop back until 16 bytes have been displayed
   561 00:0A42: 20 4B E0                     JSR     M_SPC                   ;Send a space
   562 00:0A45: A0 00                        LDY     #$00                    ;Reset index for SRCHBUFF
   563 00:0A47: B9 40 03     GETBYT2         LDA     SRCHBUFF,Y              ;Get buffered line (16 bytes)
   564 00:0A4A: 20 54 E0                     JSR     M_PRASC                 ;Print ASCII character
   565 00:0A4D: C8                           INY                             ;Increment index to next byte
   566 00:0A4E: C0 10                        CPY     #$10                    ;Check for 16 bytes
   567 00:0A50: D0 F5                        BNE     GETBYT2                 ;Loop back until 16 bytes have been displayed
   568 00:0A52: 20 48 E0                     JSR     M_CROUT                 ;Else, send CR,LF to terminal
   569 00:0A55: CA                           DEX                             ;Decrement line count
   570 00:0A56: D0 BD                        BNE     DLINE                   ;Branch back until all rows done
   571 00:0A58: 20 89 0A                     JSR     GLINE                   ;Send horizontal line to terminal
   572                        ;
   573                        ;DMPGR subroutine: Send address offsets to terminal
   574                        ;
   575 00:0A5B: A9 02        DMPGR           LDA     #$02                    ;Get msg for "addr:" to terminal
   576 00:0A5D: 20 57 E0                     JSR     M_PROMPT                ;Send to terminal
   577 00:0A60: 20 4B E0                     JSR     M_SPC                   ;Add two additional spaces
   578 00:0A63: 20 4B E0                     JSR     M_SPC
   579 00:0A66: A2 00                        LDX     #$00                    ;Zero index count
   580 00:0A68: 8A           MDLOOP          TXA                             ;Send "00" - "0F", separated by 1 Space to terminal
   581 00:0A69: 20 4E E0                     JSR     M_PRBYTE                ;Print byte value
   582 00:0A6C: 20 4B E0                     JSR     M_SPC                   ;Add a space
   583 00:0A6F: E8                           INX                             ;Increment the count
   584 00:0A70: E0 10                        CPX     #$10                    ;Check for 16
   585 00:0A72: D0 F4                        BNE     MDLOOP                  ;Loop back until done
   586                        ;
  Thu Mar 16 2023 11:47                                                                                                    Page 17


   587                        ;Print the ASCII text header "0123456789ABCDEF"
   588                        ;
   589 00:0A74: 20 4B E0                     JSR     M_SPC                   ;Send a space
   590 00:0A77: A2 00                        LDX     #$00                    ;Zero X reg for "0"
   591 00:0A79: 8A           MTLOOP          TXA                             ;Xfer to A reg
   592 00:0A7A: 20 3C E0                     JSR     M_BIN2ASC               ;Convert Byte to two ASCII digits
   593 00:0A7D: 98                           TYA                             ;Xfer the low nibble character to A reg
   594 00:0A7E: 20 3C FF                     JSR     B_CHROUT                ;Send least significant HEX to terminal
   595 00:0A81: E8                           INX                             ;Increment to next HEX character
   596 00:0A82: E0 10                        CPX     #$10                    ;Check for 16
   597 00:0A84: D0 F3                        BNE     MTLOOP                  ;Branch back till done
   598 00:0A86: 4C 48 E0                     JMP     M_CROUT                 ;Do a CR/LF and return
   599                        ;
   600                        ;GLINE subroutine: Send a horizontal line to console used by memory display only.
   601                        ;
   602 00:0A89: A2 4F        GLINE           LDX     #$4F                    ;Load index for 79 decimal
   603 00:0A8B: A9 7E                        LDA     #$7E                    ;Get "~" character
   604 00:0A8D: 20 3C FF     GLINEL          JSR     B_CHROUT                ;Send to terminal (draw a line)
   605 00:0A90: CA                           DEX                             ;Decrement count
   606 00:0A91: D0 FA                        BNE     GLINEL                  ;Branch back until done
   607 00:0A93: 60                           RTS                             ;Return to caller
   608                        ;
   609                        ;PRINT Offset subroutine: Prints a $ sign followed by TEMP1L/H
   610                        ;
   611 00:0A94: 20 45 E0     PROFFSET        JSR     M_DOLLAR                ;Print a $ sign
   612 00:0A97: A5 B2                        LDA     TEMP1L                  ;Get Index Low byte
   613 00:0A99: A4 B3                        LDY     TEMP1H                  ;Get Index High byte
   614 00:0A9B: 4C 51 E0                     JMP     M_PRWORD                ;Print Word, return
   615                        ;
   616                        ;Increment Data offset to display
   617                        ;
   618                        INCOFFSET
   619 00:0A9E: E6 B2                        INC     TEMP1L                  ;Increment low byte
   620 00:0AA0: D0 02                        BNE     SK_HIOFF                ;If not equal, skip high byte
   621 00:0AA2: E6 B3                        INC     TEMP1H                  ;Increment high byte
   622 00:0AA4: 60           SK_HIOFF        RTS                             ;Return to caller
   623                        ;
   624                        ; MicroDrive Routines
   625                        ;
   626                        IDE_IDENTIFY
   627                        ; Uses the BIOS call to load drive identity information.
   628                        ; This routine will display the following information from the ID block:
   629                        ;
   630                        ;       Bytes $36 - $5D       Model Number:
   631                        ;       Bytes $14 - $27       Serial Number:
   632                        ;       Bytes $2E - $35       Firmware Revision:
   633                        ;       Bytes $62 - $63       LBA Mode Support:
   634                        ;       Bytes $78 - $7B       Total LBA Count:
   635                        ;
   636                        ; The above data is in Big Endian format or ASCII format
   637                        ;
   638 00:0AA5: 20 06 FF                     JSR     B_IDE_IDENTIFY          ;Call BIOS routine
   639 00:0AA8: 20 02 0F                     JSR     SWAP_BYTE               ;Swap High/Low Bytes
   640                        ;
   641 00:0AAB: A9 34                        LDA     #<DRIVE_IDENTITY        ;Get low order offset
   642 00:0AAD: A0 1A                        LDY     #>DRIVE_IDENTITY        ;Get high order offset
   643 00:0AAF: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   644                        ;
   645                        ;ID Block now loaded into buffer
   646                        ; Next, print the description message, then print the offset to the ID block
   647                        ; for ASCII text, but will need to do some transforms for Mode Support and
   648                        ; LBA block count.
   649                        ;
  Thu Mar 16 2023 11:47                                                                                                    Page 18


   650 00:0AB2: A9 52                        LDA     #<MODEL_NUM             ;Get low order offset
   651 00:0AB4: A0 1A                        LDY     #>MODEL_NUM             ;Get high order offset
   652 00:0AB6: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   653                        ;
   654 00:0AB9: A9 36                        LDA     #<LBA_BUFFER+$36        ;Get low order offset
   655 00:0ABB: A0 06                        LDY     #>LBA_BUFFER+$36        ;Get high order offset
   656 00:0ABD: A2 28                        LDX     #40                     ;Byte count to display
   657 00:0ABF: 20 8D 0E                     JSR     STRING_OUT              ;Use string out routine
   658                        ;
   659 00:0AC2: A9 64                        LDA     #<SERIAL_NUM            ;Get low order offset
   660 00:0AC4: A0 1A                        LDY     #>SERIAL_NUM            ;Get high order offset
   661 00:0AC6: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   662                        ;
   663 00:0AC9: A9 14                        LDA     #<LBA_BUFFER+$14        ;Get low order offset
   664 00:0ACB: A0 06                        LDY     #>LBA_BUFFER+$14        ;Get high order offset
   665 00:0ACD: A2 14                        LDX     #20                     ;Byte count to display
   666 00:0ACF: 20 8D 0E                     JSR     STRING_OUT              ;Use string out routine
   667                        ;
   668 00:0AD2: A9 77                        LDA     #<FIRM_REV              ;Get low order offset
   669 00:0AD4: A0 1A                        LDY     #>FIRM_REV              ;Get high order offset
   670 00:0AD6: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   671                        ;
   672 00:0AD9: A9 2E                        LDA     #<LBA_BUFFER+$2E        ;Get low order offset
   673 00:0ADB: A0 06                        LDY     #>LBA_BUFFER+$2E        ;Get high order offset
   674 00:0ADD: A2 08                        LDX     #8                      ;Byte count to display
   675 00:0ADF: 20 8D 0E                     JSR     STRING_OUT              ;Use string out routine
   676                        ;
   677 00:0AE2: A9 8E                        LDA     #<MODE_SUPPORT          ;Get low order offset
   678 00:0AE4: A0 1A                        LDY     #>MODE_SUPPORT          ;Get high order offset
   679 00:0AE6: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   680                        ;
   681 00:0AE9: AD 62 06                     LDA     LBA_BUFFER+$62          ;Get Capabilities data (bit 9 of Word 49)
   682 00:0AEC: 4A                           LSR     A                       ;Shift DMA bit to Carry (dont't care)
   683 00:0AED: 4A                           LSR     A                       ;Shift LBA bit to Carry (do care)
   684 00:0AEE: B0 04                        BCS     LBA_MODE_Y              ;If active, finish setup
   685                        ;
   686 00:0AF0: A9 4E                        LDA     #$4E                    ;Get "N"
   687 00:0AF2: 80 02                        BRA     LBA_MODE_N              ;Finish sending to console
   688                        LBA_MODE_Y
   689 00:0AF4: A9 59                        LDA     #$59                    ;Get "Y"
   690                        LBA_MODE_N
   691 00:0AF6: 20 3C FF                     JSR     B_CHROUT                ;Send to console
   692                        ;
   693 00:0AF9: A9 A6                        LDA     #<TOTAL_LBA             ;Get low order offset
   694 00:0AFB: A0 1A                        LDY     #>TOTAL_LBA             ;Get high order offset
   695 00:0AFD: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   696                        ;
   697 00:0B00: AD 78 06                     LDA     LBA_BUFFER+$78          ;Get LBA count data
   698 00:0B03: 85 13                        STA     HEX4AND5                ;Store in Page Zero work area
   699 00:0B05: AD 79 06                     LDA     LBA_BUFFER+$79          ;Get LBA count data
   700 00:0B08: 85 14                        STA     HEX6AND7                ;Store in Page Zero work area
   701 00:0B0A: AD 7A 06                     LDA     LBA_BUFFER+$7A          ;Get LBA count data
   702 00:0B0D: 85 11                        STA     HEX0AND1                ;Store in Page Zero work area
   703 00:0B0F: AD 7B 06                     LDA     LBA_BUFFER+$7B          ;Get LBA count data
   704 00:0B12: 85 12                        STA     HEX2AND3                ;Store in Page Zero work area
   705                        ;
   706 00:0B14: 20 93 0F                     JSR     HEXTOBCD                ;Convert 32-bit Hex to ASCII BCD
   707 00:0B17: 20 F6 0F                     JSR     BCDOUT                  ;Print BCD count to console
   708 00:0B1A: 4C 77 0E     NO_NEXT_LBA     JMP     USER_INPUT              ;Prompt user for next command
   709                        ;
   710                        IDE_READ_LBA
   711                        ; This routine will read a User requested LBA and display as Hex/ASCII
   712                        ; - The "N" key will show the next in sequence
  Thu Mar 16 2023 11:47                                                                                                    Page 19


   713                        ; - Hitting Return will end the LBA Read/Display sequence
   714                        ;
   715 00:0B1D: 9C AA 21                     STZ     LBA_LOW_WORD            ;Zero out LBA count
   716 00:0B20: 9C AB 21                     STZ     LBA_LOW_WORD+1
   717 00:0B23: 9C AC 21                     STZ     LBA_HIGH_WORD
   718 00:0B26: 9C AD 21                     STZ     LBA_HIGH_WORD+1
   719                        ;
   720 00:0B29: A9 BB                        LDA     #<LBA_INPUT             ;Get LBA Input message
   721 00:0B2B: A0 1A                        LDY     #>LBA_INPUT
   722 00:0B2D: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
   723 00:0B30: 20 81 0E                     JSR     GET_LBA_NUM             ;Get LBA number to read
   724                        ;
   725 00:0B33: 8D AA 21                     STA     LBA_LOW_WORD            ;Save Current LBA number
   726 00:0B36: 8C AB 21                     STY     LBA_LOW_WORD+1          ;to local variables
   727 00:0B39: 8E AC 21                     STX     LBA_HIGH_WORD
   728                        READ_NEXT_LBA
   729 00:0B3C: A9 00                        LDA     #<LBA_BUFFER            ;Setup LBA Buffer
   730 00:0B3E: A0 06                        LDY     #>LBA_BUFFER            ; address
   731 00:0B40: A2 01                        LDX     #$01                    ;LBA count = 1
   732 00:0B42: 85 B0                        STA     INDEXL                  ;Save Index L
   733 00:0B44: 84 B1                        STY     INDEXH                  ;Save Index H
   734 00:0B46: 20 15 FF                     JSR     B_IDE_SET_ADDR          ;Set Buffer address
   735                        ;
   736 00:0B49: 20 09 FF                     JSR     B_IDE_READ_LBA          ;Read LBA into Buffer
   737 00:0B4C: A5 FC                        LDA     IDE_STATUS_RAM          ;Get IDE Status
   738 00:0B4E: 4A                           LSR     A                       ;Shift error bit into carry
   739 00:0B4F: B0 4E                        BCS     IDE_RW_ERR              ;If carry set, handle read error
   740                        ;
   741 00:0B51: A2 20                        LDX     #$20                    ;Set display range for 32 rows
   742 00:0B53: 20 02 0A                     JSR     DUMP                    ;Display data to console
   743                        ;
   744                        ; Prompt user: either display the next LBA or not.
   745                        ;
   746 00:0B56: A9 7E                        LDA     #<NEXT_LBA              ;Get LBA Output message
   747 00:0B58: A0 1B                        LDY     #>NEXT_LBA
   748 00:0B5A: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
   749                        ;
   750                        LBA_TRY_AGAIN
   751 00:0B5D: 20 30 E0                     JSR     M_RDCHAR                ;Get input from console
   752 00:0B60: C9 0D                        CMP     #$0D                    ;Check for C/R
   753 00:0B62: F0 B6                        BEQ     NO_NEXT_LBA             ;If yes, exit
   754 00:0B64: C9 4E                        CMP     #"N"                    ;Check for "N" for next
   755 00:0B66: D0 32                        BNE     BAD_ENTRY               ;Bad entry, branch
   756                        ;
   757                        ; Need to increase the current LBA number, then loop back and re-display
   758                        ;
   759 00:0B68: 20 8D 0C                     JSR     LBA_BLK_UPDATE          ;Update LBA Block to read
   760                        ;
   761 00:0B6B: AD AA 21                     LDA     LBA_LOW_WORD            ;Get variables
   762 00:0B6E: AC AB 21                     LDY     LBA_LOW_WORD+1
   763 00:0B71: AE AC 21                     LDX     LBA_HIGH_WORD
   764 00:0B74: 20 12 FF                     JSR     B_IDE_SET_LBA           ;Set LBA to read
   765                        ;
   766 00:0B77: AD AB 21                     LDA     LBA_LOW_WORD+1          ;Get LBA count data
   767 00:0B7A: 85 13                        STA     HEX4AND5                ;Store in Page Zero work area
   768 00:0B7C: AD AA 21                     LDA     LBA_LOW_WORD            ;Get LBA count data
   769 00:0B7F: 85 14                        STA     HEX6AND7                ;Store in Page Zero work area
   770 00:0B81: AD AD 21                     LDA     LBA_HIGH_WORD+1         ;Get LBA count data
   771 00:0B84: 85 11                        STA     HEX0AND1                ;Store in Page Zero work area
   772 00:0B86: AD AC 21                     LDA     LBA_HIGH_WORD           ;Get LBA count data
   773 00:0B89: 85 12                        STA     HEX2AND3                ;Store in Page Zero work area
   774                        ;
   775 00:0B8B: 20 93 0F                     JSR     HEXTOBCD                ;Convert and print to ASCII BCD
  Thu Mar 16 2023 11:47                                                                                                    Page 20


   776 00:0B8E: A9 A1                        LDA     #<SHOW_NEXT_LBA         ;Get LBA Output message
   777 00:0B90: A0 1B                        LDY     #>SHOW_NEXT_LBA
   778 00:0B92: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
   779                        ;
   780 00:0B95: 20 F6 0F                     JSR     BCDOUT                  ;Print BCD count to console
   781 00:0B98: 80 A2                        BRA     READ_NEXT_LBA           ;Branch back to show next LBA
   782                        ;
   783                        BAD_ENTRY
   784 00:0B9A: 20 42 E0                     JSR     M_BEEP                  ;Send error beep
   785 00:0B9D: 80 BE                        BRA     LBA_TRY_AGAIN           ;Branch and try again
   786                        ;
   787                        IDE_RW_ERR
   788 00:0B9F: 4C A1 0E                     JMP     IDE_ERROR_HANDLER       ;Jump to error handler
   789                        ;
   790                        IDE_WRITE_LBA
   791                        ; This routine will write a User requested LBA from the LBA_BUFFER
   792                        ; - The Buffer data will be displayed first and then prompted for writing
   793                        ;
   794 00:0BA2: A9 DE                        LDA     #<LBA_OUTPUT            ;Get LBA Output message
   795 00:0BA4: A0 1A                        LDY     #>LBA_OUTPUT
   796 00:0BA6: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
   797 00:0BA9: 20 81 0E                     JSR     GET_LBA_NUM             ;Get LBA number to write
   798 00:0BAC: A9 00                        LDA     #<LBA_BUFFER            ;Setup LBA Buffer
   799 00:0BAE: A0 06                        LDY     #>LBA_BUFFER            ; address
   800 00:0BB0: A2 01                        LDX     #$01                    ;LBA count = 1
   801 00:0BB2: 85 B0                        STA     INDEXL                  ;Save Index L
   802 00:0BB4: 84 B1                        STY     INDEXH                  ;Save Index H
   803 00:0BB6: 20 15 FF                     JSR     B_IDE_SET_ADDR          ;Set Buffer address
   804                        ;
   805 00:0BB9: A9 1F                        LDA     #<LBA_WR_DATA           ;Get LBA Write message
   806 00:0BBB: A0 1B                        LDY     #>LBA_WR_DATA
   807 00:0BBD: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
   808                        ;
   809 00:0BC0: A2 20                        LDX     #$20                    ;Set display range for 32 rows
   810 00:0BC2: 20 02 0A                     JSR     DUMP                    ;Display data to console
   811                        ;
   812 00:0BC5: A9 4F                        LDA     #<LBA_WR_CNFM           ;Get LBA Confirm Write message
   813 00:0BC7: A0 1B                        LDY     #>LBA_WR_CNFM
   814 00:0BC9: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
   815                        ;
   816 00:0BCC: 20 5D E0                     JSR     M_CONTINUE              ;Prompt to confirm LBA write
   817                        ;
   818 00:0BCF: 20 0C FF                     JSR     B_IDE_WRITE_LBA         ;Write LBA from Buffer
   819 00:0BD2: A5 FC                        LDA     IDE_STATUS_RAM          ;Get IDE Status
   820 00:0BD4: 4A                           LSR     A                       ;Shift error bit into carry
   821 00:0BD5: B0 C8                        BCS     IDE_RW_ERR              ;If carry set, handle write error
   822                        ;
   823 00:0BD7: 20 0F FF                     JSR     B_IDE_VERFY_LBA         ;Verify LBA
   824 00:0BDA: A5 FC                        LDA     IDE_STATUS_RAM          ;Get IDE Status
   825 00:0BDC: 4A                           LSR     A                       ;Shift error bit into carry
   826 00:0BDD: B0 C0                        BCS     IDE_RW_ERR              ;If carry set, handle write error
   827                        ;
   828 00:0BDF: 4C 77 0E                     JMP     USER_INPUT              ;Get user input
   829                        ;
   830                        IDE_SEQ_READ
   831                        ; This routine will read the entire disk data one block at a time,
   832                        ; - This can take a long time as the current LBA count is displayed.
   833                        ;
   834 00:0BE2: A9 BF                        LDA     #<LBA_SEQ_RD_MSG        ;Get Seq Read Message address
   835 00:0BE4: A0 1B                        LDY     #>LBA_SEQ_RD_MSG
   836 00:0BE6: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
   837                        ;
   838 00:0BE9: A9 1A                        LDA     #<LBA_SEQ_TM_MSG        ;Get Time Message address
  Thu Mar 16 2023 11:47                                                                                                    Page 21


   839 00:0BEB: A0 1C                        LDY     #>LBA_SEQ_TM_MSG
   840 00:0BED: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
   841                        ;
   842 00:0BF0: 20 06 FF                     JSR     B_IDE_IDENTIFY          ;Call BIOS routine
   843 00:0BF3: 20 02 0F                     JSR     SWAP_BYTE               ;Swap high/low bytes
   844                        ;
   845 00:0BF6: A9 A6                        LDA     #<TOTAL_LBA             ;Get low order offset
   846 00:0BF8: A0 1A                        LDY     #>TOTAL_LBA             ;Get high order offset
   847 00:0BFA: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   848                        ;
   849 00:0BFD: AD 78 06                     LDA     LBA_BUFFER+$78          ;Get LBA count data
   850 00:0C00: 85 13                        STA     HEX4AND5                ;Store in Page Zero work area
   851 00:0C02: AD 79 06                     LDA     LBA_BUFFER+$79          ;Get LBA count data
   852 00:0C05: 85 14                        STA     HEX6AND7                ;Store in Page Zero work area
   853 00:0C07: AD 7A 06                     LDA     LBA_BUFFER+$7A          ;Get LBA count data
   854 00:0C0A: 85 11                        STA     HEX0AND1                ;Store in Page Zero work area
   855 00:0C0C: AD 7B 06                     LDA     LBA_BUFFER+$7B          ;Get LBA count data
   856 00:0C0F: 85 12                        STA     HEX2AND3                ;Store in Page Zero work area
   857                        ;
   858 00:0C11: 20 93 0F                     JSR     HEXTOBCD                ;Convert and print to ASCII BCD
   859 00:0C14: 20 F6 0F                     JSR     BCDOUT                  ;Print BCD count to console
   860                        ;
   861 00:0C17: A9 46                        LDA     #<LBA_SEQ_CFM           ;Get Message address
   862 00:0C19: A0 1C                        LDY     #>LBA_SEQ_CFM
   863 00:0C1B: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
   864                        ;
   865 00:0C1E: 20 5D E0                     JSR     M_CONTINUE              ;Prompt user to continue
   866 00:0C21: 20 48 E0                     JSR     M_CROUT                 ;Send CR/LF
   867                        ;
   868 00:0C24: A9 00                        LDA     #<BENCH_BUFFER          ;Setup LBA Buffer
   869 00:0C26: A0 23                        LDY     #>BENCH_BUFFER          ; address
   870 00:0C28: A2 01                        LDX     #$01                    ;LBA count = 1
   871 00:0C2A: 20 15 FF                     JSR     B_IDE_SET_ADDR          ;Set Buffer address
   872                        ;
   873 00:0C2D: 9C AA 21                     STZ     LBA_LOW_WORD            ;Zero out LBA count
   874 00:0C30: 9C AB 21                     STZ     LBA_LOW_WORD+1
   875 00:0C33: 9C AC 21                     STZ     LBA_HIGH_WORD
   876 00:0C36: 9C AD 21                     STZ     LBA_HIGH_WORD+1
   877                        ;
   878 00:0C39: A9 85                        LDA     #<LBA_BLKS_RD           ;Get Blocks read msg
   879 00:0C3B: A0 1C                        LDY     #>LBA_BLKS_RD
   880 00:0C3D: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
   881                        ;
   882                        SEQ_LBA_READ
   883 00:0C40: AD AA 21                     LDA     LBA_LOW_WORD            ;Get variables
   884 00:0C43: AC AB 21                     LDY     LBA_LOW_WORD+1
   885 00:0C46: AE AC 21                     LDX     LBA_HIGH_WORD
   886 00:0C49: 20 12 FF                     JSR     B_IDE_SET_LBA           ;Set LBA to read
   887                        ;
   888 00:0C4C: A9 0D                        LDA     #$0D                    ;Get C/R
   889 00:0C4E: 20 3C FF                     JSR     B_CHROUT                ;Send to console
   890                        ;
   891 00:0C51: AD AB 21                     LDA     LBA_LOW_WORD+1          ;Get LBA count data
   892 00:0C54: 85 13                        STA     HEX4AND5                ;Store in Page Zero work area
   893 00:0C56: AD AA 21                     LDA     LBA_LOW_WORD            ;Get LBA count data
   894 00:0C59: 85 14                        STA     HEX6AND7                ;Store in Page Zero work area
   895 00:0C5B: AD AD 21                     LDA     LBA_HIGH_WORD+1         ;Get LBA count data
   896 00:0C5E: 85 11                        STA     HEX0AND1                ;Store in Page Zero work area
   897 00:0C60: AD AC 21                     LDA     LBA_HIGH_WORD           ;Get LBA count data
   898 00:0C63: 85 12                        STA     HEX2AND3                ;Store in Page Zero work area
   899                        ;
   900 00:0C65: 20 93 0F                     JSR     HEXTOBCD                ;Convert and print to ASCII BCD
   901 00:0C68: 20 F6 0F                     JSR     BCDOUT                  ;Print BCD count to console
  Thu Mar 16 2023 11:47                                                                                                    Page 22


   902                        ;
   903 00:0C6B: A5 DA        OC_LOOP         LDA     OCNT_A                  ;Check output buffer count
   904 00:0C6D: D0 FC                        BNE     OC_LOOP                 ;Loop back until buffer sent
   905                        ;
   906 00:0C6F: 20 09 FF                     JSR     B_IDE_READ_LBA          ;Read selected LBA from IDE
   907 00:0C72: A5 FC                        LDA     IDE_STATUS_RAM          ;Get IDE Status
   908 00:0C74: C9 51                        CMP     #$51                    ;Check for error
   909 00:0C76: D0 03                        BNE     NO_RD_ERR               ;Branch if no error
   910                        ;
   911 00:0C78: 4C A1 0E                     JMP     IDE_ERROR_HANDLER       ;Jump to error handler
   912                        ;
   913                        NO_RD_ERR
   914 00:0C7B: 20 8D 0C                     JSR     LBA_BLK_UPDATE          ;Update LBA Block to read
   915                        ;
   916 00:0C7E: 20 A0 0C                     JSR     LBA_LIMIT_CHK           ;Check LBA limit
   917 00:0C81: 90 BD                        BCC     SEQ_LBA_READ            ;Loop back to continue (Carry clear)
   918                        ;
   919 00:0C83: A9 AA                        LDA     #<LBA_BLKS_RD_CMP       ;Get Blocks read msg
   920 00:0C85: A0 1C                        LDY     #>LBA_BLKS_RD_CMP
   921 00:0C87: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
   922 00:0C8A: 4C 77 0E                     JMP     USER_INPUT              ;Prompt User
   923                        ;
   924                        LBA_BLK_UPDATE
   925                        ; This routine updates the LBA block number being read or written
   926                        ; - This routine is only used for the full read or write
   927                        ;
   928 00:0C8D: EE AA 21                     INC     LBA_LOW_WORD            ;Increment 32-bit word
   929 00:0C90: D0 0D                        BNE     SKIP_BLK_UPDATE
   930 00:0C92: EE AB 21                     INC     LBA_LOW_WORD+1
   931 00:0C95: D0 08                        BNE     SKIP_BLK_UPDATE
   932 00:0C97: EE AC 21                     INC     LBA_HIGH_WORD
   933 00:0C9A: D0 03                        BNE     SKIP_BLK_UPDATE
   934 00:0C9C: EE AD 21                     INC     LBA_HIGH_WORD+1
   935 00:0C9F: 60           SKIP_BLK_UPDATE RTS                             ;Return to caller
   936                        ;
   937                        LBA_LIMIT_CHK
   938 00:0CA0: AD AD 21                     LDA     LBA_HIGH_WORD+1         ;Get high order word
   939 00:0CA3: CD 3F 03                     CMP     $033F                   ;Compare to Limit
   940 00:0CA6: D0 1A                        BNE     LIMIT_GOOD              ;If not, exit
   941 00:0CA8: AD AC 21                     LDA     LBA_HIGH_WORD           ;Get high order word
   942 00:0CAB: CD 3E 03                     CMP     $033E                   ;Compare to limit
   943 00:0CAE: D0 12                        BNE     LIMIT_GOOD              ;If not, exit
   944 00:0CB0: AD AB 21                     LDA     LBA_LOW_WORD+1          ;Get low order word
   945 00:0CB3: CD 3D 03                     CMP     $033D                   ;Compare to limit
   946 00:0CB6: D0 0A                        BNE     LIMIT_GOOD              ;If not, exit
   947 00:0CB8: AD AA 21                     LDA     LBA_LOW_WORD            ;Get low order word
   948 00:0CBB: CD 3C 03                     CMP     $033C                   ;Compare to limit
   949 00:0CBE: D0 02                        BNE     LIMIT_GOOD
   950 00:0CC0: 38                           SEC                             ;Set carry for limit reached
   951 00:0CC1: 60                           RTS
   952 00:0CC2: 18           LIMIT_GOOD      CLC                             ;Clear carry for limit good
   953 00:0CC3: 60                           RTS                             ;Return to caller
   954                        ;
   955                        IDE_SEQ_WRITE
   956                        ; This routine will write the entire data on the drive!!
   957                        ; - A 16-bit data pattern is requested from user.
   958                        ; - This routine can take a long time as the current LBA count is displayed!!
   959                        ;
   960 00:0CC4: A9 ED                        LDA     #<LBA_SEQ_WR_MSG        ;Get Seq Write Message address
   961 00:0CC6: A0 1B                        LDY     #>LBA_SEQ_WR_MSG
   962 00:0CC8: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
   963                        ;
   964 00:0CCB: A9 1A                        LDA     #<LBA_SEQ_TM_MSG        ;Get time address
  Thu Mar 16 2023 11:47                                                                                                    Page 23


   965 00:0CCD: A0 1C                        LDY     #>LBA_SEQ_TM_MSG
   966 00:0CCF: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
   967                        ;
   968 00:0CD2: 20 06 FF                     JSR     B_IDE_IDENTIFY          ;Call BIOS routine
   969 00:0CD5: 20 02 0F                     JSR     SWAP_BYTE               ;Swap high/low bytes
   970                        ;
   971 00:0CD8: A9 A6                        LDA     #<TOTAL_LBA             ;Get low order offset
   972 00:0CDA: A0 1A                        LDY     #>TOTAL_LBA             ;Get high order offset
   973 00:0CDC: 20 5A E0                     JSR     M_PROMPTR               ;Send message to console
   974                        ;
   975 00:0CDF: AD 78 06                     LDA     LBA_BUFFER+$78          ;Get LBA count data
   976 00:0CE2: 85 13                        STA     HEX4AND5                ;Store in Page Zero work area
   977 00:0CE4: AD 79 06                     LDA     LBA_BUFFER+$79          ;Get LBA count data
   978 00:0CE7: 85 14                        STA     HEX6AND7                ;Store in Page Zero work area
   979 00:0CE9: AD 7A 06                     LDA     LBA_BUFFER+$7A          ;Get LBA count data
   980 00:0CEC: 85 11                        STA     HEX0AND1                ;Store in Page Zero work area
   981 00:0CEE: AD 7B 06                     LDA     LBA_BUFFER+$7B          ;Get LBA count data
   982 00:0CF1: 85 12                        STA     HEX2AND3                ;Store in Page Zero work area
   983                        ;
   984 00:0CF3: 20 93 0F                     JSR     HEXTOBCD                ;Convert Hex to ASCII BCD
   985 00:0CF6: 20 F6 0F                     JSR     BCDOUT                  ;Print BCD count to console
   986                        ;
   987 00:0CF9: A9 46                        LDA     #<LBA_SEQ_CFM           ;Get 1st Message address
   988 00:0CFB: A0 1C                        LDY     #>LBA_SEQ_CFM
   989 00:0CFD: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
   990                        ;
   991 00:0D00: 20 5D E0                     JSR     M_CONTINUE              ;Prompt user to continue
   992 00:0D03: 20 48 E0                     JSR     M_CROUT                 ;Send CR/LF
   993                        ;
   994 00:0D06: A9 62                        LDA     #<LBA_SEQ_CFM2          ;Get 2nd Message address
   995 00:0D08: A0 1C                        LDY     #>LBA_SEQ_CFM2
   996 00:0D0A: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
   997                        ;
   998 00:0D0D: 20 5D E0                     JSR     M_CONTINUE              ;Prompt user to continue
   999 00:0D10: 20 48 E0                     JSR     M_CROUT                 ;Send CR/LF
  1000                        ;
  1001 00:0D13: 20 CE 0E                     JSR     GET_PATTERN             ;Prompt for two-byte Hex pattern
  1002                        ;
  1003                        ;                LDA     #$AA                    ;Get Fill Pattern default
  1004                        ;                LDY     #$55                    ; of $AA55
  1005                        ;                STA     INDEXL                  ;Save to Index pointer
  1006                        ;                STY     INDEXH                  ; High/Low
  1007                        ;
  1008 00:0D16: 20 DB 0E                     JSR     FILL_PATTERN            ;Fill buffer with pattern
  1009                        ;
  1010 00:0D19: A9 00                        LDA     #<BENCH_BUFFER          ;Setup LBA Buffer
  1011 00:0D1B: A0 23                        LDY     #>BENCH_BUFFER          ; address
  1012 00:0D1D: A2 01                        LDX     #$01                    ;LBA count = 1
  1013 00:0D1F: 20 15 FF                     JSR     B_IDE_SET_ADDR          ;Set Buffer address
  1014                        ;
  1015 00:0D22: 9C AA 21                     STZ     LBA_LOW_WORD            ;Zero out LBA count
  1016 00:0D25: 9C AB 21                     STZ     LBA_LOW_WORD+1
  1017 00:0D28: 9C AC 21                     STZ     LBA_HIGH_WORD
  1018 00:0D2B: 9C AD 21                     STZ     LBA_HIGH_WORD+1
  1019                        ;
  1020 00:0D2E: A9 96                        LDA     #<LBA_BLKS_WR           ;Get Blocks written msg
  1021 00:0D30: A0 1C                        LDY     #>LBA_BLKS_WR
  1022 00:0D32: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
  1023                        ;
  1024                        SEQ_LBA_WRITE
  1025 00:0D35: AD AA 21                     LDA     LBA_LOW_WORD            ;Get variables
  1026 00:0D38: AC AB 21                     LDY     LBA_LOW_WORD+1
  1027 00:0D3B: AE AC 21                     LDX     LBA_HIGH_WORD
  Thu Mar 16 2023 11:47                                                                                                    Page 24


  1028 00:0D3E: 20 12 FF                     JSR     B_IDE_SET_LBA           ;Set LBA to write
  1029                        ;
  1030 00:0D41: A9 0D                        LDA     #$0D                    ;Get C/R
  1031 00:0D43: 20 3C FF                     JSR     B_CHROUT                ;Send to console
  1032                        ;
  1033 00:0D46: AD AB 21                     LDA     LBA_LOW_WORD+1          ;Get LBA count data
  1034 00:0D49: 85 13                        STA     HEX4AND5                ;Store in Page Zero work area
  1035 00:0D4B: AD AA 21                     LDA     LBA_LOW_WORD            ;Get LBA count data
  1036 00:0D4E: 85 14                        STA     HEX6AND7                ;Store in Page Zero work area
  1037 00:0D50: AD AD 21                     LDA     LBA_HIGH_WORD+1         ;Get LBA count data
  1038 00:0D53: 85 11                        STA     HEX0AND1                ;Store in Page Zero work area
  1039 00:0D55: AD AC 21                     LDA     LBA_HIGH_WORD           ;Get LBA count data
  1040 00:0D58: 85 12                        STA     HEX2AND3                ;Store in Page Zero work area
  1041                        ;
  1042 00:0D5A: 20 93 0F                     JSR     HEXTOBCD                ;Convert Hex to ASCII BCD
  1043 00:0D5D: 20 F6 0F                     JSR     BCDOUT                  ;Print BCD count to console
  1044                        
  1045 00:0D60: A5 DA        OC_LOOP2        LDA     OCNT_A                  ;Check output buffer count
  1046 00:0D62: D0 FC                        BNE     OC_LOOP2                ;Loop back until buffer sent
  1047                        ;
  1048 00:0D64: 20 0C FF                     JSR     B_IDE_WRITE_LBA         ;Write selected LBA from buffer
  1049 00:0D67: A5 FC                        LDA     IDE_STATUS_RAM          ;Get IDE Status
  1050 00:0D69: C9 51                        CMP     #$51                    ;Check for error
  1051 00:0D6B: D0 02                        BNE     NO_WR_ERR               ;Branch if no error
  1052                        ;
  1053 00:0D6D: 80 77                        BRA     RD_WR_ERR               ;Branch to handle error
  1054                        ;
  1055                        NO_WR_ERR
  1056 00:0D6F: 20 8D 0C                     JSR     LBA_BLK_UPDATE          ;Update LBA Block to write
  1057                        ;
  1058 00:0D72: 20 A0 0C                     JSR     LBA_LIMIT_CHK           ;Check LBA limit
  1059 00:0D75: 90 BE                        BCC     SEQ_LBA_WRITE           ;Loop back to continue (Carry clear)
  1060                        ;
  1061 00:0D77: A9 D5                        LDA     #<LBA_BLKS_WR_CMP       ;Get Blocks written msg
  1062 00:0D79: A0 1C                        LDY     #>LBA_BLKS_WR_CMP
  1063 00:0D7B: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
  1064 00:0D7E: 4C 77 0E                     JMP     USER_INPUT              ;Prompt User
  1065                        ;
  1066                        IDE_BENCHMARK
  1067                        ;
  1068                        ; The Benchmark will read or write a 16MB contiguous block of data.
  1069                        ;  The starting LBA is entered by the user.
  1070                        ;
  1071                        ; - The Benchmark timer in the C02 BIOS/Monitor is used to time the data transfer and shows
  1072                        ; - the number of seconds and hundredths of a second that it takes to complete the transfer.
  1073                        ; -  Note that the benchmark routines use a multiple block transfer of 32 blocks (16KB).
  1074                        ;
  1075                        ; The User is prompted for the Write function, as this overwrites a 16MB block of data on the
  1076                        ; - IDE device, which results in a loss of data. When executing the Write benchmark, the
  1077                        ; - LBA Buffer will be filled with a "55AA" pattern for a 512-byte block.
  1078                        ;
  1079                        ; Error checking is done after each LBA Read or Write function and any error will be
  1080                        ; - displayed and the test aborted after that.
  1081                        ;
  1082 00:0D81: A9 36                        LDA     #<LBA_BENCH_INTRO       ;Get LBA Bench Intro Msg
  1083 00:0D83: A0 1D                        LDY     #>LBA_BENCH_INTRO
  1084 00:0D85: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
  1085                        BENCH_IN_LP
  1086 00:0D88: 20 30 E0                     JSR     M_RDCHAR                ;Get character from user
  1087 00:0D8B: 20 3C FF                     JSR     B_CHROUT                ;Send to console
  1088 00:0D8E: C9 52                        CMP     #"R"                    ;Test for Read
  1089 00:0D90: F0 09                        BEQ     IDE_BENCH_READ          ;If yes, go set RTC
  1090 00:0D92: C9 57                        CMP     #"W"                    ;Test for Write
  Thu Mar 16 2023 11:47                                                                                                    Page 25


  1091 00:0D94: F0 53                        BEQ     IDE_BENCH_WRITE         ;If no, skip RTC set
  1092 00:0D96: 20 42 E0                     JSR     M_BEEP                  ;Else, error, send beep
  1093 00:0D99: 80 ED                        BRA     BENCH_IN_LP             ;Branch back and try again
  1094                        ;
  1095                        IDE_BENCH_READ
  1096                        ;
  1097                        ; Simple test program to transfer multiple sectors - READ
  1098                        ;
  1099 00:0D9B: A9 00                        LDA     #<LBA_START             ;Get LBA starting # Msg
  1100 00:0D9D: A0 1B                        LDY     #>LBA_START
  1101 00:0D9F: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
  1102                        ;
  1103 00:0DA2: 20 81 0E                     JSR     GET_LBA_NUM             ;Get starting LBA # from user
  1104                        ;
  1105 00:0DA5: A9 9C                        LDA     #<LBA_RD_BENCH          ;Get LBA Read Bench Msg
  1106 00:0DA7: A0 1E                        LDY     #>LBA_RD_BENCH
  1107 00:0DA9: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
  1108                        ;
  1109 00:0DAC: A5 DA        OC_LOOP3        LDA     OCNT_A                  ;Check output buffer count
  1110 00:0DAE: D0 FC                        BNE     OC_LOOP3                ;Loop back until buffer sent
  1111                        ;
  1112 00:0DB0: A9 00                        LDA     #<BENCH_BUFFER          ;Setup LBA Buffer
  1113 00:0DB2: A0 23                        LDY     #>BENCH_BUFFER          ; address
  1114 00:0DB4: A2 20                        LDX     #$20                    ;Sector count of 32 (16KB)
  1115 00:0DB6: 20 15 FF                     JSR     B_IDE_SET_ADDR          ;Call BIOS routine to set it
  1116                        ;
  1117                        ; Setup 1024 transfers at 32 blocks per transfer = 16MB
  1118                        ;
  1119 00:0DB9: A2 00                        LDX     #$00                    ;Set for 256 blocks (128KB)
  1120 00:0DBB: A0 04                        LDY     #$04                    ;Set multiplier of 4 (* 256)
  1121 00:0DBD: 20 2D FF                     JSR     B_CNT_INIT              ;Reset and start benchmark counter
  1122                        ;
  1123                        LBA_RBLK
  1124 00:0DC0: 20 09 FF                     JSR     B_IDE_READ_LBA          ;Call BIOS Read Block
  1125 00:0DC3: A5 FC                        LDA     IDE_STATUS_RAM          ;Get IDE Status (RAM)
  1126 00:0DC5: 4A                           LSR     A                       ;Shift error bit into carry
  1127 00:0DC6: B0 1E                        BCS     RD_WR_ERR               ;Branch if error
  1128                        ;
  1129 00:0DC8: A5 F6                        LDA     LBA_LOW_BYTE            ;Get LBA low byte (Carry is clear)
  1130 00:0DCA: 65 F5                        ADC     LBA_XFER_CNT            ;Add 32 decimal
  1131 00:0DCC: 85 F6                        STA     LBA_LOW_BYTE            ;Save it back
  1132                        ;
  1133 00:0DCE: A5 F7                        LDA     LBA_HIGH_BYTE           ;Get LBA high byte
  1134 00:0DD0: 69 00                        ADC     #$00                    ;Add carry
  1135 00:0DD2: 85 F7                        STA     LBA_HIGH_BYTE           ;Save it back
  1136                        ;
  1137 00:0DD4: A5 F8                        LDA     LBA_EXT_BYTE            ;Get LBA ext byte
  1138 00:0DD6: 69 00                        ADC     #$00                    ;Add carry
  1139 00:0DD8: 85 F8                        STA     LBA_EXT_BYTE            ;Save it back
  1140                        ;
  1141 00:0DDA: CA                           DEX                             ;Decrement low index
  1142 00:0DDB: D0 E3                        BNE     LBA_RBLK                ;Loop back until zero
  1143 00:0DDD: 88                           DEY                             ;Decrement multiplier index
  1144 00:0DDE: D0 E0                        BNE     LBA_RBLK                ;Loop back until done
  1145 00:0DE0: 20 1B E0                     JSR     M_QUITB                 ;Quit Benchmark counter, print results
  1146 00:0DE3: 4C 77 0E                     JMP     USER_INPUT              ;Prompt User
  1147                        ;
  1148                        RD_WR_ERR
  1149 00:0DE6: 4C A1 0E                     JMP     IDE_ERROR_HANDLER       ;Jump to error handler, then return
  1150                        ;
  1151                        IDE_BENCH_WRITE
  1152                        ;
  1153                        ; Simple test program to transfer multiple sectors - WRITE
  Thu Mar 16 2023 11:47                                                                                                    Page 26


  1154                        ;
  1155 00:0DE9: 20 CE 0E                     JSR     GET_PATTERN             ;Prompt for two-byte Hex pattern
  1156 00:0DEC: 20 DB 0E                     JSR     FILL_PATTERN            ;Fill 16KB buffer with pattern
  1157                        ;
  1158 00:0DEF: A9 00                        LDA     #<LBA_START             ;Get LBA starting # Msg
  1159 00:0DF1: A0 1B                        LDY     #>LBA_START
  1160 00:0DF3: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
  1161                        ;
  1162 00:0DF6: 20 81 0E                     JSR     GET_LBA_NUM             ;Get starting LBA # from user
  1163                        ;
  1164 00:0DF9: A9 E0                        LDA     #<LBA_BENCH_WARN        ;Get LBA Write Bench msg
  1165 00:0DFB: A0 1E                        LDY     #>LBA_BENCH_WARN
  1166 00:0DFD: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
  1167                        BENCH_WARN_LP
  1168 00:0E00: 20 30 E0                     JSR     M_RDCHAR                ;Get character from user
  1169 00:0E03: 20 3C FF                     JSR     B_CHROUT                ;Send to console
  1170 00:0E06: C9 59                        CMP     #"Y"                    ;Test for yes
  1171 00:0E08: F0 09                        BEQ     BENCH_WRITE_Y           ;If yes, do write benchmark
  1172 00:0E0A: C9 4E                        CMP     #"N"                    ;Test for no
  1173 00:0E0C: F0 47                        BEQ     BENCH_WRITE_N           ;If no, skip write benchmark
  1174 00:0E0E: 20 42 E0                     JSR     M_BEEP                  ;Else, error, send beep
  1175 00:0E11: 80 ED                        BRA     BENCH_WARN_LP           ;Branch back and try again
  1176                        BENCH_WRITE_Y
  1177 00:0E13: A9 BE                        LDA     #<LBA_WR_BENCH          ;Get LBA Write Bench msg
  1178 00:0E15: A0 1E                        LDY     #>LBA_WR_BENCH
  1179 00:0E17: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
  1180                        ;
  1181 00:0E1A: A5 DA        OC_LOOP4        LDA     OCNT_A                  ;Check output buffer count
  1182 00:0E1C: D0 FC                        BNE     OC_LOOP4                ;Loop back until buffer sent
  1183                        ;
  1184 00:0E1E: A9 00                        LDA     #<BENCH_BUFFER          ;Setup LBA Buffer
  1185 00:0E20: A0 23                        LDY     #>BENCH_BUFFER          ; address
  1186 00:0E22: A2 20                        LDX     #$20                    ;Sector count of 32
  1187 00:0E24: 20 15 FF                     JSR     B_IDE_SET_ADDR          ;Call BIOS routine to set it
  1188                        ;
  1189                        ; Setup 1024 transfers at 32 blocks per transfer = 16MB
  1190                        ;
  1191 00:0E27: A2 00                        LDX     #$00                    ;Set for 256 blocks (128KB)
  1192 00:0E29: A0 04                        LDY     #$04                    ;Set multiplier of 4 (* 256)
  1193 00:0E2B: 20 2D FF                     JSR     B_CNT_INIT              ;Reset and start benchmark counter
  1194                        LBA_WBLK
  1195 00:0E2E: 20 0C FF                     JSR     B_IDE_WRITE_LBA         ;Write Block
  1196 00:0E31: A5 FC                        LDA     IDE_STATUS_RAM          ;Get IDE Status
  1197 00:0E33: 4A                           LSR     A                       ;Shift error bit into carry
  1198 00:0E34: B0 B0                        BCS     RD_WR_ERR               ;Branch if error
  1199                        ;
  1200 00:0E36: 18                           CLC                             ;Clear Carry for add
  1201 00:0E37: A5 F6                        LDA     LBA_LOW_BYTE            ;Get LBA low byte
  1202 00:0E39: 65 F5                        ADC     LBA_XFER_CNT            ;Add 32 decimal
  1203 00:0E3B: 85 F6                        STA     LBA_LOW_BYTE            ;Save it back
  1204                        ;
  1205 00:0E3D: A5 F7                        LDA     LBA_HIGH_BYTE           ;Get LBA high byte
  1206 00:0E3F: 69 00                        ADC     #$00                    ;Add carry
  1207 00:0E41: 85 F7                        STA     LBA_HIGH_BYTE           ;Save it back
  1208                        ;
  1209 00:0E43: A5 F8                        LDA     LBA_EXT_BYTE            ;Get LBA ext byte
  1210 00:0E45: 69 00                        ADC     #$00                    ;Add carry
  1211 00:0E47: 85 F8                        STA     LBA_EXT_BYTE            ;Save it back
  1212                        ;
  1213                        SKP_HI_WR
  1214 00:0E49: CA                           DEX                             ;Decrement index
  1215 00:0E4A: D0 E2                        BNE     LBA_WBLK                ;Loop until done
  1216 00:0E4C: 88                           DEY                             ;Decrement index high
  Thu Mar 16 2023 11:47                                                                                                    Page 27


  1217 00:0E4D: D0 DF                        BNE     LBA_WBLK                ;Loop back until done
  1218 00:0E4F: 20 1B E0                     JSR     M_QUITB                 ;Quit Benchmark counter
  1219 00:0E52: 4C 77 0E                     JMP     USER_INPUT              ;Prompt User
  1220                        ;
  1221                        BENCH_WRITE_N
  1222 00:0E55: A9 67                        LDA     #<LBA_BENCH_ABORT       ;Get LBA Write Bench msg
  1223 00:0E57: A0 1F                        LDY     #>LBA_BENCH_ABORT
  1224 00:0E59: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
  1225                        ;
  1226 00:0E5C: 4C 77 0E                     JMP     USER_INPUT
  1227                        ;
  1228                        QUIT
  1229 00:0E5F: A9 60                        LDA     #<QUIT_MSG              ;Load Message address
  1230 00:0E61: A0 19                        LDY     #>QUIT_MSG              ;into A/Y regs
  1231 00:0E63: 20 5A E0                     JSR     M_PROMPTR               ;Send to console/return
  1232                        ;
  1233 00:0E66: A9 00                        LDA     #<LBA_BUFFER            ;Setup LBA Buffer
  1234 00:0E68: A0 06                        LDY     #>LBA_BUFFER            ; address
  1235 00:0E6A: A2 01                        LDX     #$01                    ;LBA count = 1
  1236 00:0E6C: 20 15 FF                     JSR     B_IDE_SET_ADDR          ;Set Buffer address
  1237 00:0E6F: 20 00 FF                     JSR     B_IDE_RESET             ;Reset MicroDrive
  1238                        ;
  1239 00:0E72: A2 00                        LDX     #$00                    ;Get warm boot function
  1240 00:0E74: 4C 03 01                     JMP     PEM                     ;Jump to PEM to warm boot
  1241                        ;
  1242                        ;Prompt User for what's next
  1243                        ; As we're outputting to a remote console, displaying the menu again could scroll the displayed
  1244                        ; data off the screen, so this routine pauses the program execution and let's the user decide
  1245                        ; on going to the menu display or just continuing on with another function.
  1246                        ;
  1247                        USER_INPUT
  1248 00:0E77: A9 11                        LDA     #<USER_INMSG            ;Load message address
  1249 00:0E79: A0 1A                        LDY     #>USER_INMSG            ;into A/Y reg
  1250 00:0E7B: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
  1251 00:0E7E: 4C 0E 08                     JMP     MAIN_LOOP               ;Goto main input loop
  1252                        ;
  1253                        GET_LBA_NUM
  1254                        ;Get LBA number from user
  1255 00:0E81: 20 B8 10                     JSR     DECIN                   ;Get Decimal input, convert to BCD, then to HEX
  1256                        ;
  1257 00:0E84: A5 14                        LDA     HEX6AND7                ;Low byte
  1258 00:0E86: A4 13                        LDY     HEX4AND5
  1259 00:0E88: A6 12                        LDX     HEX2AND3
  1260 00:0E8A: 4C 12 FF                     JMP     B_IDE_SET_LBA           ;Set LBA number
  1261                        ;
  1262                        STRING_OUT
  1263                        ; String out prints a string based on the A/Y register pointing to the start of the string
  1264                        ; and the X reg containing how many characters to print (not a null terminated string)
  1265                        ;
  1266 00:0E8D: 85 B6                        STA     PROMPTL                 ;Set low byte address
  1267 00:0E8F: 84 B7                        STY     PROMPTH                 ;Set high byte address
  1268 00:0E91: A0 00                        LDY     #$00                    ;Zero offet index
  1269                        STRING_LOOP
  1270 00:0E93: B1 B6                        LDA     (PROMPTL),Y             ;Get string data
  1271 00:0E95: C9 20                        CMP     #$20                    ;Check for ASCII space
  1272 00:0E97: F0 03                        BEQ     SKIP_SPC                ;If yes, skip printing it
  1273 00:0E99: 20 3C FF                     JSR     B_CHROUT                ;Send to terminal
  1274                        SKIP_SPC
  1275 00:0E9C: C8                           INY                             ;Increment index to string
  1276 00:0E9D: CA                           DEX                             ;Decrement character count
  1277 00:0E9E: D0 F3                        BNE     STRING_LOOP             ;Branch back until done
  1278 00:0EA0: 60                           RTS                             ;Return to caller
  1279                        ;
  Thu Mar 16 2023 11:47                                                                                                    Page 28


  1280                        IDE_ERROR_HANDLER
  1281                        ; This routine gets the error code anytime a command returns with the error
  1282                        ; bit on in the status register. It uses the BIOS routine to get the error register
  1283                        ; and returns with the error code in the X register.
  1284                        ;
  1285                        ; the error code is matched to the list of possible codes per the Hitachi
  1286                        ; MicroDrive documentation, then the matching error message is sent to the console.
  1287                        ; After this, the IDE controller is reset and the User is prompted for the next
  1288                        ; action to be taken.
  1289                        ;
  1290 00:0EA1: A9 8A                        LDA     #<IDE_CONTROLLER_ERROR  ;Get Base IDE error msg
  1291 00:0EA3: A0 1F                        LDY     #>IDE_CONTROLLER_ERROR
  1292 00:0EA5: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
  1293                        ;
  1294 00:0EA8: 20 03 FF                     JSR     B_IDE_GET_STAT          ;Get Status from BIOS
  1295 00:0EAB: 8A                           TXA                             ;Xfer error code to A reg
  1296                        ;
  1297 00:0EAC: A2 05                        LDX     #IDE_ERROR_ADDRESS-IDE_ERROR_CODES-1    ;Get error list count
  1298 00:0EAE: DD AE 21     ERROR_LP        CMP     IDE_ERROR_CODES,X       ;Compare to command list
  1299 00:0EB1: D0 0B                        BNE     ERROR_DEC               ;Check for next error and loop
  1300                        ;
  1301                        ; X Reg now contains error index
  1302                        ;
  1303 00:0EB3: 8A                           TXA                             ;Xfer Error code index to A reg
  1304 00:0EB4: 0A                           ASL     A                       ;Multiply error index value by 2
  1305 00:0EB5: AA                           TAX                             ;Xfer Error offset address to message table
  1306                        ;
  1307 00:0EB6: BD B4 21                     LDA     IDE_ERROR_ADDRESS,X     ;Get message address
  1308 00:0EB9: BC B5 21                     LDY     IDE_ERROR_ADDRESS+1,X
  1309 00:0EBC: 80 07                        BRA     ERROR_MSG               ;Branch below to output message and continue
  1310                        ;
  1311 00:0EBE: CA           ERROR_DEC       DEX                             ;Decrement index count
  1312 00:0EBF: 10 ED                        BPL     ERROR_LP                ;If more to check, loop back
  1313                        ;
  1314                        ; No more error codes, so it must be something unknown. So print the unknown message
  1315                        ; to the console and return to the User prompt.
  1316                        ;
  1317 00:0EC1: A9 44                        LDA     #<IDE_ERROR_06          ;Get Error message address
  1318 00:0EC3: A0 22                        LDY     #>IDE_ERROR_06
  1319                        ERROR_MSG
  1320 00:0EC5: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
  1321 00:0EC8: 20 00 FF                     JSR     B_IDE_RESET             ;Reset IDE Controller
  1322 00:0ECB: 4C 77 0E                     JMP     USER_INPUT              ;Prompt User
  1323                        ;
  1324                        GET_PATTERN
  1325                        ; Get Pattern: This prompts the User for a 2-byte Hexadecimal fill pattern.
  1326                        ; - This will be used by FILL_PATTERN to load the BENCH_BUFFER.
  1327 00:0ECE: A9 03                        LDA     #<PATTERN_MSG           ;Get write pattern msg
  1328 00:0ED0: A0 1D                        LDY     #>PATTERN_MSG
  1329 00:0ED2: 20 5A E0                     JSR     M_PROMPTR               ;Send to console
  1330                        ;
  1331                        ; Monitor routine will get User input and return in A/Y regs
  1332                        ; - Data also saved in INDEXH/INDEXL
  1333 00:0ED5: 20 36 E0                     JSR     M_HEXIN4                ;Use Monitor to get input
  1334 00:0ED8: 4C 48 E0                     JMP     M_CROUT                 ;Send C/R to console and return
  1335                        ;
  1336                        FILL_PATTERN
  1337                        ;
  1338                        ; Fill Pattern: This fills the LBA buffer with a user specified data pattern.
  1339                        ; - The buffer address is specified by BENCH_BUFFER (at the end of our code).
  1340                        ; - For ease of coding, we default to a 16KB fill buffer.
  1341                        ; - The 16KB buffer is used by the Read and Write Benchmark routines only.
  1342                        ;
  Thu Mar 16 2023 11:47                                                                                                    Page 29


  1343 00:0EDB: A9 00                        LDA     #<BENCH_BUFFER          ;Setup LBA Buffer
  1344 00:0EDD: A0 23                        LDY     #>BENCH_BUFFER          ; address
  1345 00:0EDF: 85 BA                        STA     TGTL                    ;Setup Page Zero pointer lo
  1346 00:0EE1: 84 BB                        STY     TGTH                    ;Setup Page Zero pointer hi
  1347                        ;
  1348 00:0EE3: A2 00                        LDX     #$00                    ;Set Index for count
  1349 00:0EE5: A0 20                        LDY     #$20                    ; of 16KB (8K of words)
  1350                        FILL_P_LOOP
  1351 00:0EE7: A5 B1                        LDA     INDEXH                  ;Get High byte fill
  1352 00:0EE9: 92 BA                        STA     (TGTL)                  ;Save it
  1353 00:0EEB: E6 BA                        INC     TGTL                    ;Increment pointer
  1354 00:0EED: D0 02                        BNE     SK_FILL_1               ;Skip if no rollover
  1355 00:0EEF: E6 BB                        INC     TGTH                    ;Increment pointer
  1356                        SK_FILL_1
  1357 00:0EF1: A5 B0                        LDA     INDEXL                  ;Get Low byte fill
  1358 00:0EF3: 92 BA                        STA     (TGTL)                  ;Save it
  1359 00:0EF5: E6 BA                        INC     TGTL                    ;Increment pointer
  1360 00:0EF7: D0 02                        BNE     SK_FILL_2               ;Skip if no rollover
  1361 00:0EF9: E6 BB                        INC     TGTH                    ;Increment pointer
  1362                        SK_FILL_2
  1363 00:0EFB: CA                           DEX                             ;Decrement low count
  1364 00:0EFC: D0 E9                        BNE     FILL_P_LOOP             ;Loop back till done
  1365 00:0EFE: 88                           DEY                             ;Decrement high count
  1366 00:0EFF: D0 E6                        BNE     FILL_P_LOOP             'Loop back until done
  1367 00:0F01: 60                           RTS                             ;Return to caller
  1368                        ;
  1369                        ; Routine to swap high and low bytes in the block space
  1370                        ; - used for Identity Data, as the bytes are swapped high and low
  1371                        ;
  1372                        SWAP_BYTE
  1373 00:0F02: A9 00                        LDA     #<LBA_BUFFER            ;Setup LBA Buffer
  1374 00:0F04: A0 06                        LDY     #>LBA_BUFFER            ; address
  1375 00:0F06: 85 F9                        STA     BIOS_XFERL              ;Save it to page zero
  1376 00:0F08: 84 FA                        STY     BIOS_XFERH              ;variable
  1377                        ;
  1378 00:0F0A: A2 00                        LDX     #$00                    ;Set Index for count of 256
  1379 00:0F0C: A0 01                        LDY     #$01                    ;Load Y reg for 1-byte offset
  1380                        ;
  1381                        SWAP_LOOP
  1382 00:0F0E: B2 F9                        LDA     (BIOS_XFERL)            ;Get first byte
  1383 00:0F10: 48                           PHA                             ;Save to stack
  1384 00:0F11: B1 F9                        LDA     (BIOS_XFERL),Y          ;Get second byte
  1385 00:0F13: 92 F9                        STA     (BIOS_XFERL)            ;Save it
  1386 00:0F15: 68                           PLA                             ;Get second byte back
  1387 00:0F16: 91 F9                        STA     (BIOS_XFERL),Y          ;Save it to first byte
  1388                        ;
  1389 00:0F18: E6 F9                        INC     BIOS_XFERL              ;Increment index
  1390 00:0F1A: D0 02                        BNE     SWAP_SKP1               ;Branch if non-zero
  1391 00:0F1C: E6 FA                        INC     BIOS_XFERH              ;Increment index
  1392                        SWAP_SKP1
  1393 00:0F1E: E6 F9                        INC     BIOS_XFERL              ;Increment index
  1394 00:0F20: D0 02                        BNE     SWAP_SKP2               ;Branch if non-zero
  1395 00:0F22: E6 FA                        INC     BIOS_XFERH              ;Increment index
  1396                        SWAP_SKP2
  1397 00:0F24: CA                           DEX                             ;Decrement index
  1398 00:0F25: D0 E7                        BNE     SWAP_LOOP               ;Loop back till done
  1399 00:0F27: 60                           RTS                             ;Return to caller
  1400                        ;
  1401                        SYS_XFER
  1402                        ;
  1403                        ;System Transfer routine.
  1404                        ; This routine is used to write a section of memory to a defined set of contiguous blocks
  1405                        ; on the Microdrive. The purpose being to transfer the bootable image from RAM to the disc.
  Thu Mar 16 2023 11:47                                                                                                    Page 30


  1406                        ;
  1407                        ; The user is prompted for a few inputs as:
  1408                        ; - Starting LBA on the Microdrive
  1409                        ; - Starting memory address used as the source
  1410                        ; - Number of blocks to be transferred
  1411                        ;
  1412                        ; Once this is entered, the user is prompted to either continue or abort.
  1413                        ; if confirmed, the write executed and the blocks on the disc are overwritten with the
  1414                        ; contens of memory.
  1415                        ;
  1416 00:0F28: A9 C0                        LDA     #<SYS_INTRO_MSG         ;Get System Xfer Message
  1417 00:0F2A: A0 1F                        LDY     #>SYS_INTRO_MSG         ;
  1418 00:0F2C: 20 5A E0                     JSR     M_PROMPTR               ;Send to Console
  1419                        ;
  1420 00:0F2F: A9 38                        LDA     #<SYS_LBA_MSG           ;Get Starting LBA for xfer
  1421 00:0F31: A0 20                        LDY     #>SYS_LBA_MSG           ;
  1422 00:0F33: 20 5A E0                     JSR     M_PROMPTR               ;Send to Console
  1423 00:0F36: 20 81 0E                     JSR     GET_LBA_NUM             ;Get starting LBA from User
  1424                        ;
  1425                        ; Use C02 Monitor routine to get a 16-bit hex address returned in A/Y
  1426                        ; and stored in INDEXH/INDEXL
  1427                        ;
  1428 00:0F39: A9 BA                        LDA     #<RAM_START_MSG         ;Get Starting RAM for xfer
  1429 00:0F3B: A0 20                        LDY     #>RAM_START_MSG         ;
  1430 00:0F3D: 20 5A E0                     JSR     M_PROMPTR               ;Send to Console
  1431 00:0F40: 20 36 E0                     JSR     M_HEXIN4                ;Call Monitor routine
  1432                        ;
  1433 00:0F43: A9 7B                        LDA     #<BLK_SIZE_MSG          ;Get LBA count for xfer
  1434 00:0F45: A0 20                        LDY     #>BLK_SIZE_MSG          ;
  1435 00:0F47: 20 5A E0                     JSR     M_PROMPTR               ;Send to Console
  1436                        ;
  1437 00:0F4A: 20 B8 10                     JSR     DECIN                   ;Get Decimal input, convert to BCD, then to HEX
  1438                        ;
  1439 00:0F4D: A6 14                        LDX     HEX6AND7                ;Get low byte (number of blocks)
  1440 00:0F4F: A5 B0                        LDA     INDEXL                  ;Get RAM address to start from
  1441 00:0F51: A4 B1                        LDY     INDEXH                  ;
  1442 00:0F53: 20 15 FF                     JSR     B_IDE_SET_ADDR          ;Call BIOS to set address and block count
  1443                        ;
  1444 00:0F56: A9 E5                        LDA     #<SYS_CONFIRM_MSG       ;Get Confirm Message for xfer
  1445 00:0F58: A0 20                        LDY     #>SYS_CONFIRM_MSG       ;
  1446 00:0F5A: 20 5A E0                     JSR     M_PROMPTR               ;Send to Console
  1447                        ;
  1448                        SYS_WRT_WARN_LP
  1449 00:0F5D: 20 30 E0                     JSR     M_RDCHAR                ;Get character from user
  1450 00:0F60: 20 3C FF                     JSR     B_CHROUT                ;Send to console
  1451 00:0F63: C9 59                        CMP     #"Y"                    ;Test for yes
  1452 00:0F65: F0 09                        BEQ     SYS_WRITE_GO            ;If yes, do write benchmark
  1453 00:0F67: C9 4E                        CMP     #"N"                    ;Test for no
  1454 00:0F69: F0 25                        BEQ     SYS_WRITE_ABORT         ;If no, skip write benchmark
  1455 00:0F6B: 20 42 E0                     JSR     M_BEEP                  ;Else, error, send beep
  1456 00:0F6E: 80 ED                        BRA     SYS_WRT_WARN_LP         ;Branch back and try again
  1457                        ;
  1458                        SYS_WRITE_GO
  1459 00:0F70: A9 1B                        LDA     #<SYS_WRITE_MSG         ;Get Confirm Message for xfer
  1460 00:0F72: A0 21                        LDY     #>SYS_WRITE_MSG         ;
  1461 00:0F74: 20 5A E0                     JSR     M_PROMPTR               ;Send to Console
  1462                        ;
  1463                        WAIT_SYS
  1464 00:0F77: A5 DA                        LDA     OCNT_A                  ;Get output count for console
  1465 00:0F79: D0 FC                        BNE     WAIT_SYS                ;Wait until done
  1466                        ;
  1467 00:0F7B: 20 0C FF                     JSR     B_IDE_WRITE_LBA         ;Call BIOS to write image
  1468 00:0F7E: A5 FC                        LDA     IDE_STATUS_RAM          ;Get IDE Status (RAM)
  Thu Mar 16 2023 11:47                                                                                                    Page 31


  1469 00:0F80: 4A                           LSR     A                       ;Shift error bit into carry
  1470 00:0F81: B0 0A                        BCS     IMG_WR_ERR              ;Branch if error
  1471                        ;
  1472 00:0F83: A9 36                        LDA     #<SYS_COMPLETE_MSG      ;Get Confirm Message for xfer
  1473 00:0F85: A0 21                        LDY     #>SYS_COMPLETE_MSG      ;
  1474 00:0F87: 20 5A E0                     JSR     M_PROMPTR               ;Send to Console
  1475 00:0F8A: 4C 77 0E                     JMP     USER_INPUT              ;Exit to main
  1476                        ;
  1477                        IMG_WR_ERR
  1478 00:0F8D: 20 A1 0E                     JSR     IDE_ERROR_HANDLER       ;Handle Disc error
  1479                        SYS_WRITE_ABORT
  1480 00:0F90: 4C 77 0E                     JMP     USER_INPUT              ;Exit to main
  1481                        ;
  1482                        ;
  1483                        ; The following routines are borrowed from Brian Phelps' SyMON monitor.
  1484                        ; - HEXTOBCD, BCDOUT, BCDTOASC, BCDTOHEX, ASCTODEC
  1485                        ; - I made some coding changes to use CMOS instructions, etc.
  1486                        ;
  1487                        ;HEXTOBCD subroutine: convert a 1-8 digit HEX value to a 1-10 digit BCD value.
  1488                        ; Call with 8 digit (4 byte) HEX value in HEX0AND1(MSB) through HEX6AND7(LSB).
  1489                        ; Returns with 10 digit (5 byte) BCD result in DEC0AND1(MSB) through DEC8AND9(LSB)
  1490                        ;HPHANTOM is a 16 bit address used to reference an 8 bit zero-page address.
  1491                        ; (HEXTOBCD needs LDA $hh,Y (an invalid instruction) so we use LDA $00hh,Y instead)
  1492                        ; This address is not written-to nor read-from in the HEXTOBCD subroutine.
  1493                        ; The address is the zero-page memory location immediatly below the HEX0AND1 variable
  1494                        ;HEX value input buffer:
  1495                        ;HEX0AND1 Two most significant HEX digits
  1496                        ;HEX2AND3
  1497                        ;HEX4AND5
  1498                        ;HEX6AND7 Two least significant HEX digits
  1499                        ;BCD value output buffer (BCD accumulator):
  1500                        ;DEC0AND1 ;Two most significant BCD digits
  1501                        ;DEC2AND3
  1502                        ;DEC4AND5
  1503                        ;DEC6AND7
  1504                        ;DEC8AND9 ;Two least significant BCD digits
  1505                        ;
  1506 00:0F93: 64 15        HEXTOBCD        STZ     DEC0AND1                ;Init (zero) buffer
  1507 00:0F95: 64 16                        STZ     DEC2AND3
  1508 00:0F97: 64 17                        STZ     DEC4AND5
  1509 00:0F99: 64 18                        STZ     DEC6AND7
  1510 00:0F9B: 64 19                        STZ     DEC8AND9
  1511 00:0F9D: A0 04                        LDY     #$04                    ;Initialize HEX input buffer byte index: point to addre
                    ss minus 1 of LSB
  1512 00:0F9F: A2 04                        LDX     #$04                    ;Initialize multiplicand table index: point to LSB of l
                    owest multiplicand
  1513 00:0FA1: B9 10 00     DECLOOP         LDA     HPHANTOM,Y              ;Read indexed byte from input buffer: Y REGISTER index 
                    always > 0 here
  1514 00:0FA4: 29 0F                        AND     #$0F                    ;Zero the high digit
  1515 00:0FA6: 20 C1 0F                     JSR     MULTIPLY                ;Multiply low digit
  1516 00:0FA9: E8                           INX                             ;Add 5 to multiplicand table index: point to LSB of nex
                    t higher multiplicand
  1517 00:0FAA: E8                           INX
  1518 00:0FAB: E8                           INX
  1519 00:0FAC: E8                           INX
  1520 00:0FAD: E8                           INX
  1521 00:0FAE: B9 10 00                     LDA     HPHANTOM,Y              ;Read indexed byte from input buffer: Y REGISTER index 
                    always > 0 here
  1522 00:0FB1: 4A                           LSR     A                       ;Shift high digit to low digit, zero high digit
  1523 00:0FB2: 4A                           LSR     A
  1524 00:0FB3: 4A                           LSR     A
  1525 00:0FB4: 4A                           LSR     A
  1526 00:0FB5: 20 C1 0F                     JSR     MULTIPLY                ;Multiply digit
  Thu Mar 16 2023 11:47                                                                                                    Page 32


  1527 00:0FB8: E8                           INX                             ;Add 5 to multiplicand table index: point to LSB of nex
                    t higher multiplicand
  1528 00:0FB9: E8                           INX
  1529 00:0FBA: E8                           INX
  1530 00:0FBB: E8                           INX
  1531 00:0FBC: E8                           INX
  1532 00:0FBD: 88                           DEY                             ;Decrement HEX input buffer byte index
  1533 00:0FBE: D0 E1                        BNE     DECLOOP                 ;LOOP back to DECLOOP IF byte index <> 0: there are mor
                    e bytes to process
  1534 00:0FC0: 60                           RTS                             ; ELSE, done HEXTOBCD subroutine, RETURN
  1535                        ;
  1536                        ;Multiply indexed multiplicand by digit in ACCUMULATOR
  1537                        ;
  1538 00:0FC1: 48           MULTIPLY        PHA
  1539 00:0FC2: DA                           PHX
  1540 00:0FC3: 5A                           PHY
  1541 00:0FC4: F8                           SED                             ;Switch processor to BCD arithmatic mode
  1542 00:0FC5: A8                           TAY                             ;Copy digit to Y REGISTER: multiplier loop counter
  1543 00:0FC6: C0 00        HMLTLOOP        CPY     #$00
  1544 00:0FC8: D0 05                        BNE     HDOADD                  ;GOTO HDOADD IF multiplier loop counter <> 0
  1545 00:0FCA: D8                           CLD                             ; ELSE, switch processor to BINARY arithmatic mode
  1546 00:0FCB: 7A                           PLY
  1547 00:0FCC: FA                           PLX
  1548 00:0FCD: 68                           PLA
  1549 00:0FCE: 60           BCD_DONE        RTS                             ;Done MULTIPLY subroutine, RETURN
  1550                        ;
  1551                        ;Add indexed multiplicand to BCD accumulator (output buffer)
  1552                        ;
  1553 00:0FCF: 18           HDOADD          CLC
  1554 00:0FD0: BD 59 21                     LDA     HMULTAB,X               ;Least significant byte of indexed multiplicand
  1555 00:0FD3: 65 19                        ADC     DEC8AND9                ;Least significant byte of BCD accumulator
  1556 00:0FD5: 85 19                        STA     DEC8AND9
  1557 00:0FD7: BD 58 21                     LDA     HMULTAB-1,X
  1558 00:0FDA: 65 18                        ADC     DEC6AND7
  1559 00:0FDC: 85 18                        STA     DEC6AND7
  1560 00:0FDE: BD 57 21                     LDA     HMULTAB-2,X
  1561 00:0FE1: 65 17                        ADC     DEC4AND5
  1562 00:0FE3: 85 17                        STA     DEC4AND5
  1563 00:0FE5: BD 56 21                     LDA     HMULTAB-3,X
  1564 00:0FE8: 65 16                        ADC     DEC2AND3
  1565 00:0FEA: 85 16                        STA     DEC2AND3
  1566 00:0FEC: BD 55 21                     LDA     HMULTAB-4,X             ;Most significant byte of indexed multiplicand
  1567 00:0FEF: 65 15                        ADC     DEC0AND1                ;Most significant byte of BCD accumulator
  1568 00:0FF1: 85 15                        STA     DEC0AND1
  1569 00:0FF3: 88                           DEY                             ;Decrement multiplier loop counter
  1570 00:0FF4: 80 D0                        BRA     HMLTLOOP                ;LOOP back to HMLTLOOP
  1571                        ;
  1572                        ;BCDOUT subroutine: convert 10 BCD digits to ASCII DECIMAL digits then send result to terminal.
  1573                        ;Leading zeros are supressed in the displayed result.
  1574                        ;Call with 10 digit (5 byte) BCD value contained in variables DEC0AND1 through DEC8AND9:
  1575                        ;DEC0AND1 ($15) Two most significant BCD digits
  1576                        ;DEC2AND3 ($16)
  1577                        ;DEC4AND5 ($17)
  1578                        ;DEC6AND7 ($18)
  1579                        ;DEC8AND9 ($19) Two least significant BCD digits
  1580                        ;
  1581 00:0FF6: A2 00        BCDOUT          LDX     #$00                    ;Initialize BCD output buffer index: point to MSB
  1582 00:0FF8: A0 00                        LDY     #$00                    ;Initialize leading zero flag: no non-zero digits have 
                    been processed
  1583 00:0FFA: B5 15        BCDOUTL         LDA     DEC0AND1,X              ;Read indexed byte from BCD output buffer
  1584 00:0FFC: 4A                           LSR     A                       ;Shift high digit to low digit, zero high digit
  1585 00:0FFD: 4A                           LSR     A
  1586 00:0FFE: 4A                           LSR     A
  Thu Mar 16 2023 11:47                                                                                                    Page 33


  1587 00:0FFF: 4A                           LSR     A
  1588 00:1000: 20 18 10                     JSR     BCDTOASC                ;Convert BCD digit to ASCII DECIMAL digit, send digit t
                    o terminal
  1589 00:1003: B5 15                        LDA     DEC0AND1,X              ;Read indexed byte from BCD output buffer
  1590 00:1005: 29 0F                        AND     #$0F                    ;Zero the high digit
  1591 00:1007: 20 18 10                     JSR     BCDTOASC                ;Convert BCD digit to ASCII DECIMAL digit, send digit t
                    o terminal
  1592 00:100A: E8                           INX                             ;Increment BCD output buffer index
  1593 00:100B: E0 05                        CPX     #$05
  1594 00:100D: D0 EB                        BNE     BCDOUTL                 ;LOOP back to BCDOUTL IF output buffer index <> 5
  1595 00:100F: C0 00                        CPY     #$00
  1596 00:1011: D0 BB                        BNE     BCD_DONE                ; ELSE, GOTO BCDOUTDN IF any non-zero digits were proce
                    ssed
  1597 00:1013: A9 30                        LDA     #$30                    ; ELSE, send "0" to terminal
  1598 00:1015: 4C 3C FF                     JMP     B_CHROUT                ;Send to console
  1599                        ;
  1600                        ;BCDTOASC subroutine:
  1601                        ; convert BCD digit to ASCII DECIMAL digit, send digit to terminal IF it's not a leading zero
  1602                        ;
  1603 00:1018: D0 04        BCDTOASC        BNE     NONZERO                 ;GOTO NONZERO IF BCD digit <> 0
  1604 00:101A: C0 00                        CPY     #$00                    ; ELSE, GOTO BTADONE IF no non-zero digits have been pr
                    ocessed
  1605 00:101C: F0 B0                        BEQ     BCD_DONE                ;  (supress output of leading zeros)
  1606 00:101E: C8           NONZERO         INY                             ; ELSE, indicate that a non-zero digit has been process
                    ed (Y REGISTER <> 0)
  1607 00:101F: 18                           CLC                             ;Add ASCII "0" to digit: convert BCD digit to ASCII DEC
                    IMAL digit
  1608 00:1020: 69 30                        ADC     #$30
  1609 00:1022: 4C 3C FF                     JMP     B_CHROUT                ;Send converted digit to terminal
  1610                        ;
  1611                        ;BCDTOHEX subroutine: convert a 1-10 digit BCD value to a 1-8 digit HEX value.
  1612                        ; Call with 10 digit (5 byte) DECIMAL value in DEC0AND1(MSB) through DEC8AND9(LSB).
  1613                        ; Returns with 8 digit (4 byte) HEX result in HEX0AND1(MSB) through HEX6AND7(LSB)
  1614                        ;DPHANTOM is a 16 bit address used to reference an 8 bit zero-page address.
  1615                        ; (BCDTOHEX needs LDA $hh,Y (an invalid instruction) so we use LDA $00hh,Y instead)
  1616                        ; This address is not written-to nor read-from in the BCDTOHEX subroutine.
  1617                        ; The address is the zero-page memory location immediatly below the DEC0AND1 variable
  1618                        ;BCD value input buffer:
  1619                        ;DEC0AND1 ;Two most significant BCD digits
  1620                        ;DEC2AND3
  1621                        ;DEC4AND5
  1622                        ;DEC6AND7
  1623                        ;DEC8AND9 ;Two least significant BCD digits
  1624                        ;HEX value output buffer (HEX accumulator):
  1625                        ;HEX0AND1 Two most significant HEX digits
  1626                        ;HEX2AND3
  1627                        ;HEX4AND5
  1628                        ;HEX6AND7 Two least significant HEX digits
  1629                        ;
  1630 00:1025: 64 11        BCDTOHEX        STZ     HEX0AND1                ;Init (zero) buffer
  1631 00:1027: 64 12                        STZ     HEX2AND3
  1632 00:1029: 64 13                        STZ     HEX4AND5
  1633 00:102B: 64 14                        STZ     HEX6AND7
  1634 00:102D: A0 05                        LDY     #$05                    ;Initialize DECIMAL input buffer byte index: point to (
                    address - 1) of LSB
  1635 00:102F: A2 03                        LDX     #$03                    ;Initialize multiplicand table index: point to LSB of l
                    owest multiplicand
  1636 00:1031: B9 14 00     BCDLOOP         LDA     DPHANTOM,Y              ;Read indexed byte from input buffer: Y REGISTER index 
                    always > 0 here
  1637 00:1034: 29 0F                        AND     #$0F                    ;Zero the high digit
  1638 00:1036: 20 4F 10                     JSR     MULTPLI                 ;Multiply low digit
  1639 00:1039: E8                           INX                             ;Add 4 to multiplicand table index: point to LSB of nex
                    t higher multiplicand
  Thu Mar 16 2023 11:47                                                                                                    Page 34


  1640 00:103A: E8                           INX
  1641 00:103B: E8                           INX
  1642 00:103C: E8                           INX
  1643 00:103D: B9 14 00                     LDA     DPHANTOM,Y              ;Read indexed byte from input buffer: Y REGISTER index 
                    always > 0 here
  1644 00:1040: 4A                           LSR     A                       ;Shift high digit to low digit, zero high digit
  1645 00:1041: 4A                           LSR     A
  1646 00:1042: 4A                           LSR     A
  1647 00:1043: 4A                           LSR     A
  1648 00:1044: 20 4F 10                     JSR     MULTPLI                 ;Multiply digit
  1649 00:1047: E8                           INX                             ;Add 4 to multiplicand table index: point to LSB of nex
                    t higher multiplicand
  1650 00:1048: E8                           INX
  1651 00:1049: E8                           INX
  1652 00:104A: E8                           INX
  1653 00:104B: 88                           DEY                             ;Decrement DECIMAL input buffer byte index
  1654 00:104C: D0 E3                        BNE     BCDLOOP                 ;LOOP back to BCDLOOP IF byte index <> 0: there are mor
                    e bytes to process
  1655 00:104E: 60                           RTS                             ; ELSE, done BCDTOHEX subroutine, RETURN
  1656                        ;
  1657                        ;Multiply indexed multiplicand by digit in ACCUMULATOR
  1658                        ;
  1659 00:104F: 48           MULTPLI         PHA                             ;Save registers
  1660 00:1050: DA                           PHX
  1661 00:1051: 5A                           PHY
  1662 00:1052: A8                           TAY                             ;Copy digit to Y REGISTER: multiplier loop counter
  1663 00:1053: C0 00        DMLTLOOP        CPY     #$00
  1664 00:1055: D0 04                        BNE     DDOADD                  ;GOTO DDOADD IF multiplier loop counter <> 0
  1665 00:1057: 7A                           PLY                             ;Restore registers
  1666 00:1058: FA                           PLX
  1667 00:1059: 68                           PLA
  1668 00:105A: 60                           RTS                             ;Done MULTIPLI subroutine, RETURN
  1669                        ;
  1670                        ;Add indexed multiplicand to HEX accumulator (output buffer)
  1671                        ;
  1672 00:105B: 18           DDOADD          CLC
  1673 00:105C: BD 81 21                     LDA     DMULTAB,X               ;Least significant byte of indexed multiplicand
  1674 00:105F: 65 14                        ADC     HEX6AND7                ;Least significant byte of HEX accumulator
  1675 00:1061: 85 14                        STA     HEX6AND7
  1676 00:1063: BD 80 21                     LDA     DMULTAB-1,X
  1677 00:1066: 65 13                        ADC     HEX4AND5
  1678 00:1068: 85 13                        STA     HEX4AND5
  1679 00:106A: BD 7F 21                     LDA     DMULTAB-2,X
  1680 00:106D: 65 12                        ADC     HEX2AND3
  1681 00:106F: 85 12                        STA     HEX2AND3
  1682 00:1071: BD 7E 21                     LDA     DMULTAB-3,X             ;Most significant byte of indexed multiplicand
  1683 00:1074: 65 11                        ADC     HEX0AND1                ;Most significant byte of HEX accumulator
  1684 00:1076: 85 11                        STA     HEX0AND1
  1685 00:1078: 88                           DEY                             ;Decrement multiplier loop counter
  1686 00:1079: B0 02                        BCS     OVERFLOW                ;GOTO OVERFLOW IF the last add produced a CARRY: HEX ou
                    tput buffer has overflowed
  1687 00:107B: 90 D6                        BCC     DMLTLOOP                ; ELSE, LOOP back to DMLTLOOP (always branch)
  1688 00:107D: A9 2A        OVERFLOW        LDA     #$2A                    ;Send "*" to terminal: indicate that an overflow has oc
                    cured
  1689 00:107F: 20 3C FF                     JSR     B_CHROUT
  1690 00:1082: 80 CF                        BRA     DMLTLOOP                ;LOOP back to DMLTLOOP
  1691                        ;
  1692                        ;ASCTODEC subroutine: convert ASCII DECIMAL digits to BCD
  1693                        ;
  1694 00:1084: 64 15        ASCTODEC        STZ     DEC0AND1                ;Init (zero) buffer two most significant BCD digits
  1695 00:1086: 64 16                        STZ     DEC2AND3
  1696 00:1088: 64 17                        STZ     DEC4AND5
  1697 00:108A: 64 18                        STZ     DEC6AND7
  Thu Mar 16 2023 11:47                                                                                                    Page 35


  1698 00:108C: 64 19                        STZ     DEC8AND9                ; two least significant BCD digits
  1699 00:108E: A6 BE                        LDX     BUFIDX                  ;Read number of digits entered: ASCII digit buffer inde
                    x
  1700 00:1090: F0 18                        BEQ     A2DDONE                 ;GOTO A2DDONE IF BUFIDX = 0: no digits were entered
  1701 00:1092: A0 05                        LDY     #$05                    ; ELSE, Initialize BCD input buffer index: process up t
                    o 5 BCD bytes (10 digits)
  1702 00:1094: 20 AB 10     ATODLOOP        JSR     A2DSUB                  ;Read ASCII digit then convert to BCD
  1703 00:1097: 99 14 00                     STA     DPHANTOM,Y              ;Write BCD digit to indexed buffer location (index alwa
                    ys > 0)
  1704 00:109A: 20 AB 10                     JSR     A2DSUB                  ;Read ASCII digit then convert to BCD
  1705 00:109D: 0A                           ASL     A                       ;Make this BCD digit the more significant in the BCD by
                    te
  1706 00:109E: 0A                           ASL     A
  1707 00:109F: 0A                           ASL     A
  1708 00:10A0: 0A                           ASL     A
  1709 00:10A1: 19 14 00                     ORA     DPHANTOM,Y              ;OR with the less significant digit
  1710 00:10A4: 99 14 00                     STA     DPHANTOM,Y              ;Write BCD byte to indexed buffer location (index alway
                    s > 0)
  1711 00:10A7: 88                           DEY                             ;Decrement BCD input buffer index
  1712 00:10A8: D0 EA                        BNE     ATODLOOP                ;GOTO ATODLOOP IF buffer index <> 0: there is room to p
                    rocess another digit
  1713 00:10AA: 60           A2DDONE         RTS                             ; ELSE, done ASCTODEC, RETURN
  1714                        ;
  1715                        ;Read indexed ASCII DECIMAL digit from text buffer then convert digit to 4 bit BCD
  1716                        ;
  1717 00:10AB: 8A           A2DSUB          TXA                             ;GOTO A2DCONV IF digit buffer index <> 0: there are mor
                    e digits to process
  1718 00:10AC: D0 03                        BNE     A2DCONV
  1719 00:10AE: 68                           PLA                             ; ELSE, pull return address from STACK
  1720 00:10AF: 68                           PLA
  1721 00:10B0: 60                           RTS                             ;Done ASCTODEC, RETURN
  1722 00:10B1: B5 2F        A2DCONV         LDA     IBUFF-1,X               ;Read indexed ASCII DECIMAL digit
  1723 00:10B3: 38                           SEC                             ;Subtract ASCII "0" from ASCII DECIMAL digit: convert d
                    igit to BCD
  1724 00:10B4: E9 30                        SBC     #$30
  1725 00:10B6: CA                           DEX                             ;Decrement ASCII digit buffer index
  1726 00:10B7: 60                           RTS                             ;A2DSUB done, RETURN
  1727                        ;
  1728                        ;DECIN subroutine: request 1 - 10 DECIMAL digit input from terminal, followed by [RETURN].
  1729                        ; [ESCAPE] aborts, [BACKSPACE] erases last keystroke.
  1730                        ; Convert input to BCD and HEX then store both results as follows:
  1731                        ; Converted 10 digit (5 byte) BCD value will be contained in variables DEC0AND1 through DEC8AND9:
  1732                        ;  DEC0AND1 ($E5) Two most significant BCD digits
  1733                        ;  DEC2AND3 ($E6)
  1734                        ;  DEC4AND5 ($E7)
  1735                        ;  DEC6AND7 ($E8)
  1736                        ;  DEC8AND9 ($E9) Two least significant BCD digits
  1737                        ; Converted 8 digit (4 byte) HEX value will be contained in variables HEX0AND1 through HEX6AND7:
  1738                        ;  HEX0AND1 ($E1) Two most significant HEX digits
  1739                        ;  HEX2AND3 ($E2)
  1740                        ;  HEX4AND5 ($E3)
  1741                        ;  HEX6AND7 ($E4) Two least significant HEX digits
  1742                        ; NOTE1: If a DECIMAL value greater than 4,294,967,295 ($FFFFFFFF) is entered,
  1743                        ;  1 or 2 asterisks (*) will be sent to the terminal following the inputted digits.
  1744                        ;  This is to indicate that an overflow in the HEX accumulator has occured.
  1745                        ;  (the BCDTOHEX subroutine's HEX accumulator "rolls over" to zero when that value is exceeded)
  1746                        ;  An overflow condition does NOT affect the BCD value stored.
  1747                        ; NOTE2: This subroutine is not used by SyMon; it is here for user purposes, if needed.
  1748                        ;
  1749 00:10B8: 20 C1 10     DECIN           JSR     DECINPUT                ;Request 1 - 8 DECIMAL digit input from terminal
  1750 00:10BB: 20 84 10                     JSR     ASCTODEC                ;Convert ASCII DECIMAL digits to BCD
  1751 00:10BE: 4C 25 10                     JMP     BCDTOHEX                ;Convert 1-8 digit BCD to a 1-8 digit HEX value
  1752                        ;
  Thu Mar 16 2023 11:47                                                                                                    Page 36


  1753                        ;DECINPUT subroutine: request 1 to 8 DECIMAL digits from terminal. Result is
  1754                        ; stored in zero-page address IBUFF through (IBUFF + $08)
  1755                        ;Setup RDLINE subroutine parameters:
  1756                        ;
  1757                        DECINPUT
  1758 00:10C1: A2 08                        LDX     #$08                    ;  X-REGISTER = maximum number of digits allowed
  1759                        ; Drop into RDLINE routine
  1760                        ;
  1761                        ;RDLINE subroutine: Store keystrokes into buffer until [RETURN] key is struck
  1762                        ; Used for Decimal entry, so only (0-9) are accepted entries.
  1763                        ; On entry, X Reg = buffer length. On exit, X Reg = buffer count
  1764                        ; [BACKSPACE] key removes keystrokes from buffer.
  1765                        ; [ESCAPE] key aborts then returns.
  1766 00:10C3: 86 BF        RDLINE          STX     BUFLEN          ;Store buffer length
  1767 00:10C5: 64 BE                        STZ     BUFIDX          ;Zero buffer index
  1768 00:10C7: 20 30 E0     RDLOOP          JSR     M_RDCHAR        ;Get character from terminal, convert LC2UC
  1769 00:10CA: C9 1B                        CMP     #$1B            ;Check for ESC key
  1770 00:10CC: F0 33                        BEQ     RDNULL          ;If yes, exit back to Monitor
  1771 00:10CE: C9 0D        NOTESC          CMP     #$0D            ;Check for C/R
  1772 00:10D0: F0 2B                        BEQ     EXITRD          ;Exit if yes
  1773 00:10D2: C9 08                        CMP     #$08            ;Check for Backspace
  1774 00:10D4: F0 1C                        BEQ     RDBKSP          ;If yes handle backspace
  1775 00:10D6: C9 30                        CMP     #$30            ;Check for '0' or higher
  1776 00:10D8: 90 0A                        BCC     INPERR          ;Branch to error if less than '0'
  1777 00:10DA: C9 3A                        CMP     #$3A            ;Check for higher than '9'
  1778 00:10DC: B0 06                        BCS     INPERR          ;Branch to error if more than '9'
  1779 00:10DE: A6 BE                        LDX     BUFIDX          ;Get the current buffer index
  1780 00:10E0: E4 BF                        CPX     BUFLEN          ;Compare to length for space
  1781 00:10E2: 90 05                        BCC     STRCHR          ;Branch to store in buffer
  1782 00:10E4: 20 42 E0     INPERR          JSR     M_BEEP          ;Else, error, send Bell to terminal
  1783 00:10E7: 80 DE                        BRA     RDLOOP          ;Branch back to RDLOOP
  1784 00:10E9: 95 30        STRCHR          STA     IBUFF,X         ;Store keystroke in buffer
  1785 00:10EB: 20 3C FF                     JSR     B_CHROUT        ;Send keystroke to terminal
  1786 00:10EE: E6 BE                        INC     BUFIDX          ;Increment buffer index
  1787 00:10F0: 80 D5                        BRA     RDLOOP          ;Branch back to RDLOOP
  1788 00:10F2: A5 BE        RDBKSP          LDA     BUFIDX          ;Check if buffer is empty
  1789 00:10F4: F0 EE                        BEQ     INPERR          ;Branch if yes
  1790 00:10F6: C6 BE                        DEC     BUFIDX          ;Else, decrement buffer index
  1791 00:10F8: 20 0F E0                     JSR     M_BSOUT         ;Send Backspace to terminal
  1792 00:10FB: 80 CA                        BRA     RDLOOP          ;Loop back and continue
  1793 00:10FD: A6 BE        EXITRD          LDX     BUFIDX          ;Get keystroke count (set Z flag)
  1794 00:10FF: D0 05                        BNE     RDL_OK          ;If data entered, normal exit
  1795 00:1101: 68           RDNULL          PLA                     ;Pull return address
  1796 00:1102: 68                           PLA                     ; from stack
  1797 00:1103: 4C 77 0E                     JMP     USER_INPUT      ;Go to main menu
  1798 00:1106: 60           RDL_OK          RTS                     ;Return to caller
  1799                        ; Utility Messages are defined here:
  1800                        ;
  1801                        INTRO_MSG
  1802 00:1107: 0D 0A                .DB     $0D,$0A
  1803 00:1109: 20 53 65 74          .DB     " Setup and Diagnostic Utility for:",$0D,$0A
       00:110D: 75 70 20 61 
       00:1111: 6E 64 20 44 
       00:1115: 69 61 67 6E 
       00:1119: 6F 73 74 69 
       00:111D: 63 20 55 74 
       00:1121: 69 6C 69 74 
       00:1125: 79 20 66 6F 
       00:1129: 72 3A 0D 0A 
  1804 00:112D: 20 44 53 31          .DB     " DS15x1 Realtime Clock and MicroDrive PATA Adapter, Version 0.83",$0D,$0A
       00:1131: 35 78 31 20 
       00:1135: 52 65 61 6C 
       00:1139: 74 69 6D 65 
  Thu Mar 16 2023 11:47                                                                                                    Page 37


       00:113D: 20 43 6C 6F 
       00:1141: 63 6B 20 61 
       00:1145: 6E 64 20 4D 
       00:1149: 69 63 72 6F 
       00:114D: 44 72 69 76 
       00:1151: 65 20 50 41 
       00:1155: 54 41 20 41 
       00:1159: 64 61 70 74 
       00:115D: 65 72 2C 20 
       00:1161: 56 65 72 73 
       00:1165: 69 6F 6E 20 
       00:1169: 30 2E 38 33 
       00:116D: 0D 0A 
  1805 00:116F: 20 43 6F 70          .DB     " Copyright 2022 by K.E. Maier",$0D,$0A
       00:1173: 79 72 69 67 
       00:1177: 68 74 20 32 
       00:117B: 30 32 32 20 
       00:117F: 62 79 20 4B 
       00:1183: 2E 45 2E 20 
       00:1187: 4D 61 69 65 
       00:118B: 72 0D 0A 
  1806 00:118E: 00                   .DB     $00
  1807                        ;
  1808                        MENU_MSG
  1809 00:118F: 0D 0A                .DB     $0D,$0A
  1810 00:1191: 20 2A 2A 2A          .DB     " ***************************************************************************** ",$0D,$
                    0A
       00:1195: 2A 2A 2A 2A 
       00:1199: 2A 2A 2A 2A 
       00:119D: 2A 2A 2A 2A 
       00:11A1: 2A 2A 2A 2A 
       00:11A5: 2A 2A 2A 2A 
       00:11A9: 2A 2A 2A 2A 
       00:11AD: 2A 2A 2A 2A 
       00:11B1: 2A 2A 2A 2A 
       00:11B5: 2A 2A 2A 2A 
       00:11B9: 2A 2A 2A 2A 
       00:11BD: 2A 2A 2A 2A 
       00:11C1: 2A 2A 2A 2A 
       00:11C5: 2A 2A 2A 2A 
       00:11C9: 2A 2A 2A 2A 
       00:11CD: 2A 2A 2A 2A 
       00:11D1: 2A 2A 2A 2A 
       00:11D5: 2A 2A 2A 2A 
       00:11D9: 2A 2A 2A 2A 
       00:11DD: 2A 2A 20 0D 
       00:11E1: 0A 
  1811 00:11E2: 20 2A 20 20          .DB     " *                                                                           * ",$0D,$
                    0A
       00:11E6: 20 20 20 20 
       00:11EA: 20 20 20 20 
       00:11EE: 20 20 20 20 
       00:11F2: 20 20 20 20 
       00:11F6: 20 20 20 20 
       00:11FA: 20 20 20 20 
       00:11FE: 20 20 20 20 
       00:1202: 20 20 20 20 
       00:1206: 20 20 20 20 
       00:120A: 20 20 20 20 
       00:120E: 20 20 20 20 
       00:1212: 20 20 20 20 
       00:1216: 20 20 20 20 
       00:121A: 20 20 20 20 
  Thu Mar 16 2023 11:47                                                                                                    Page 38


       00:121E: 20 20 20 20 
       00:1222: 20 20 20 20 
       00:1226: 20 20 20 20 
       00:122A: 20 20 20 20 
       00:122E: 20 2A 20 0D 
       00:1232: 0A 
  1812 00:1233: 20 2A 20 20          .DB     " *          DS15x1 Realtime Clock Functions:                                 * ",$0D,$
                    0A
       00:1237: 20 20 20 20 
       00:123B: 20 20 20 20 
       00:123F: 44 53 31 35 
       00:1243: 78 31 20 52 
       00:1247: 65 61 6C 74 
       00:124B: 69 6D 65 20 
       00:124F: 43 6C 6F 63 
       00:1253: 6B 20 46 75 
       00:1257: 6E 63 74 69 
       00:125B: 6F 6E 73 3A 
       00:125F: 20 20 20 20 
       00:1263: 20 20 20 20 
       00:1267: 20 20 20 20 
       00:126B: 20 20 20 20 
       00:126F: 20 20 20 20 
       00:1273: 20 20 20 20 
       00:1277: 20 20 20 20 
       00:127B: 20 20 20 20 
       00:127F: 20 2A 20 0D 
       00:1283: 0A 
  1813 00:1284: 20 2A 20 20          .DB     " *             1- Set Date and Time (with signature)                         * ",$0D,$
                    0A
       00:1288: 20 20 20 20 
       00:128C: 20 20 20 20 
       00:1290: 20 20 20 31 
       00:1294: 2D 20 53 65 
       00:1298: 74 20 44 61 
       00:129C: 74 65 20 61 
       00:12A0: 6E 64 20 54 
       00:12A4: 69 6D 65 20 
       00:12A8: 28 77 69 74 
       00:12AC: 68 20 73 69 
       00:12B0: 67 6E 61 74 
       00:12B4: 75 72 65 29 
       00:12B8: 20 20 20 20 
       00:12BC: 20 20 20 20 
       00:12C0: 20 20 20 20 
       00:12C4: 20 20 20 20 
       00:12C8: 20 20 20 20 
       00:12CC: 20 20 20 20 
       00:12D0: 20 2A 20 0D 
       00:12D4: 0A 
  1814 00:12D5: 20 2A 20 20          .DB     " *             2- Read NVRAM Data and Display                                * ",$0D,$
                    0A
       00:12D9: 20 20 20 20 
       00:12DD: 20 20 20 20 
       00:12E1: 20 20 20 32 
       00:12E5: 2D 20 52 65 
       00:12E9: 61 64 20 4E 
       00:12ED: 56 52 41 4D 
       00:12F1: 20 44 61 74 
       00:12F5: 61 20 61 6E 
       00:12F9: 64 20 44 69 
       00:12FD: 73 70 6C 61 
       00:1301: 79 20 20 20 
  Thu Mar 16 2023 11:47                                                                                                    Page 39


       00:1305: 20 20 20 20 
       00:1309: 20 20 20 20 
       00:130D: 20 20 20 20 
       00:1311: 20 20 20 20 
       00:1315: 20 20 20 20 
       00:1319: 20 20 20 20 
       00:131D: 20 20 20 20 
       00:1321: 20 2A 20 0D 
       00:1325: 0A 
  1815 00:1326: 20 2A 20 20          .DB     " *             3- Save NVRAM Data (without signature)                        * ",$0D,$
                    0A
       00:132A: 20 20 20 20 
       00:132E: 20 20 20 20 
       00:1332: 20 20 20 33 
       00:1336: 2D 20 53 61 
       00:133A: 76 65 20 4E 
       00:133E: 56 52 41 4D 
       00:1342: 20 44 61 74 
       00:1346: 61 20 28 77 
       00:134A: 69 74 68 6F 
       00:134E: 75 74 20 73 
       00:1352: 69 67 6E 61 
       00:1356: 74 75 72 65 
       00:135A: 29 20 20 20 
       00:135E: 20 20 20 20 
       00:1362: 20 20 20 20 
       00:1366: 20 20 20 20 
       00:136A: 20 20 20 20 
       00:136E: 20 20 20 20 
       00:1372: 20 2A 20 0D 
       00:1376: 0A 
  1816 00:1377: 20 2A 20 20          .DB     " *                                                                           * ",$0D,$
                    0A
       00:137B: 20 20 20 20 
       00:137F: 20 20 20 20 
       00:1383: 20 20 20 20 
       00:1387: 20 20 20 20 
       00:138B: 20 20 20 20 
       00:138F: 20 20 20 20 
       00:1393: 20 20 20 20 
       00:1397: 20 20 20 20 
       00:139B: 20 20 20 20 
       00:139F: 20 20 20 20 
       00:13A3: 20 20 20 20 
       00:13A7: 20 20 20 20 
       00:13AB: 20 20 20 20 
       00:13AF: 20 20 20 20 
       00:13B3: 20 20 20 20 
       00:13B7: 20 20 20 20 
       00:13BB: 20 20 20 20 
       00:13BF: 20 20 20 20 
       00:13C3: 20 2A 20 0D 
       00:13C7: 0A 
  1817 00:13C8: 20 2A 20 20          .DB     " *          MicroDrive (IDE) Functions:                                      * ",$0D,$
                    0A
       00:13CC: 20 20 20 20 
       00:13D0: 20 20 20 20 
       00:13D4: 4D 69 63 72 
       00:13D8: 6F 44 72 69 
       00:13DC: 76 65 20 28 
       00:13E0: 49 44 45 29 
       00:13E4: 20 46 75 6E 
       00:13E8: 63 74 69 6F 
  Thu Mar 16 2023 11:47                                                                                                    Page 40


       00:13EC: 6E 73 3A 20 
       00:13F0: 20 20 20 20 
       00:13F4: 20 20 20 20 
       00:13F8: 20 20 20 20 
       00:13FC: 20 20 20 20 
       00:1400: 20 20 20 20 
       00:1404: 20 20 20 20 
       00:1408: 20 20 20 20 
       00:140C: 20 20 20 20 
       00:1410: 20 20 20 20 
       00:1414: 20 2A 20 0D 
       00:1418: 0A 
  1818 00:1419: 20 2A 20 20          .DB     " *             4- Identify Vendor information                                * ",$0D,$
                    0A
       00:141D: 20 20 20 20 
       00:1421: 20 20 20 20 
       00:1425: 20 20 20 34 
       00:1429: 2D 20 49 64 
       00:142D: 65 6E 74 69 
       00:1431: 66 79 20 56 
       00:1435: 65 6E 64 6F 
       00:1439: 72 20 69 6E 
       00:143D: 66 6F 72 6D 
       00:1441: 61 74 69 6F 
       00:1445: 6E 20 20 20 
       00:1449: 20 20 20 20 
       00:144D: 20 20 20 20 
       00:1451: 20 20 20 20 
       00:1455: 20 20 20 20 
       00:1459: 20 20 20 20 
       00:145D: 20 20 20 20 
       00:1461: 20 20 20 20 
       00:1465: 20 2A 20 0D 
       00:1469: 0A 
  1819 00:146A: 20 2A 20 20          .DB     " *             5- Read a LBA to Memory and Display                           * ",$0D,$
                    0A
       00:146E: 20 20 20 20 
       00:1472: 20 20 20 20 
       00:1476: 20 20 20 35 
       00:147A: 2D 20 52 65 
       00:147E: 61 64 20 61 
       00:1482: 20 4C 42 41 
       00:1486: 20 74 6F 20 
       00:148A: 4D 65 6D 6F 
       00:148E: 72 79 20 61 
       00:1492: 6E 64 20 44 
       00:1496: 69 73 70 6C 
       00:149A: 61 79 20 20 
       00:149E: 20 20 20 20 
       00:14A2: 20 20 20 20 
       00:14A6: 20 20 20 20 
       00:14AA: 20 20 20 20 
       00:14AE: 20 20 20 20 
       00:14B2: 20 20 20 20 
       00:14B6: 20 2A 20 0D 
       00:14BA: 0A 
  1820 00:14BB: 20 2A 20 20          .DB     " *             6- Write a LBA from Memory and Verify                         * ",$0D,$
                    0A
       00:14BF: 20 20 20 20 
       00:14C3: 20 20 20 20 
       00:14C7: 20 20 20 36 
       00:14CB: 2D 20 57 72 
       00:14CF: 69 74 65 20 
  Thu Mar 16 2023 11:47                                                                                                    Page 41


       00:14D3: 61 20 4C 42 
       00:14D7: 41 20 66 72 
       00:14DB: 6F 6D 20 4D 
       00:14DF: 65 6D 6F 72 
       00:14E3: 79 20 61 6E 
       00:14E7: 64 20 56 65 
       00:14EB: 72 69 66 79 
       00:14EF: 20 20 20 20 
       00:14F3: 20 20 20 20 
       00:14F7: 20 20 20 20 
       00:14FB: 20 20 20 20 
       00:14FF: 20 20 20 20 
       00:1503: 20 20 20 20 
       00:1507: 20 2A 20 0D 
       00:150B: 0A 
  1821 00:150C: 20 2A 20 20          .DB     " *             7- Sequential Read all LBA                                    * ",$0D,$
                    0A
       00:1510: 20 20 20 20 
       00:1514: 20 20 20 20 
       00:1518: 20 20 20 37 
       00:151C: 2D 20 53 65 
       00:1520: 71 75 65 6E 
       00:1524: 74 69 61 6C 
       00:1528: 20 52 65 61 
       00:152C: 64 20 61 6C 
       00:1530: 6C 20 4C 42 
       00:1534: 41 20 20 20 
       00:1538: 20 20 20 20 
       00:153C: 20 20 20 20 
       00:1540: 20 20 20 20 
       00:1544: 20 20 20 20 
       00:1548: 20 20 20 20 
       00:154C: 20 20 20 20 
       00:1550: 20 20 20 20 
       00:1554: 20 20 20 20 
       00:1558: 20 2A 20 0D 
       00:155C: 0A 
  1822 00:155D: 20 2A 20 20          .DB     " *             8- Sequential Write all LBA                                   * ",$0D,$
                    0A
       00:1561: 20 20 20 20 
       00:1565: 20 20 20 20 
       00:1569: 20 20 20 38 
       00:156D: 2D 20 53 65 
       00:1571: 71 75 65 6E 
       00:1575: 74 69 61 6C 
       00:1579: 20 57 72 69 
       00:157D: 74 65 20 61 
       00:1581: 6C 6C 20 4C 
       00:1585: 42 41 20 20 
       00:1589: 20 20 20 20 
       00:158D: 20 20 20 20 
       00:1591: 20 20 20 20 
       00:1595: 20 20 20 20 
       00:1599: 20 20 20 20 
       00:159D: 20 20 20 20 
       00:15A1: 20 20 20 20 
       00:15A5: 20 20 20 20 
       00:15A9: 20 2A 20 0D 
       00:15AD: 0A 
  1823 00:15AE: 20 2A 20 20          .DB     " *             9- Benchmark for LBA Read or Write                            * ",$0D,$
                    0A
       00:15B2: 20 20 20 20 
       00:15B6: 20 20 20 20 
  Thu Mar 16 2023 11:47                                                                                                    Page 42


       00:15BA: 20 20 20 39 
       00:15BE: 2D 20 42 65 
       00:15C2: 6E 63 68 6D 
       00:15C6: 61 72 6B 20 
       00:15CA: 66 6F 72 20 
       00:15CE: 4C 42 41 20 
       00:15D2: 52 65 61 64 
       00:15D6: 20 6F 72 20 
       00:15DA: 57 72 69 74 
       00:15DE: 65 20 20 20 
       00:15E2: 20 20 20 20 
       00:15E6: 20 20 20 20 
       00:15EA: 20 20 20 20 
       00:15EE: 20 20 20 20 
       00:15F2: 20 20 20 20 
       00:15F6: 20 20 20 20 
       00:15FA: 20 2A 20 0D 
       00:15FE: 0A 
  1824 00:15FF: 20 2A 20 20          .DB     " *             S- System Transfer (Memory to Disc)                           * ",$0D,$
                    0A
       00:1603: 20 20 20 20 
       00:1607: 20 20 20 20 
       00:160B: 20 20 20 53 
       00:160F: 2D 20 53 79 
       00:1613: 73 74 65 6D 
       00:1617: 20 54 72 61 
       00:161B: 6E 73 66 65 
       00:161F: 72 20 28 4D 
       00:1623: 65 6D 6F 72 
       00:1627: 79 20 74 6F 
       00:162B: 20 44 69 73 
       00:162F: 63 29 20 20 
       00:1633: 20 20 20 20 
       00:1637: 20 20 20 20 
       00:163B: 20 20 20 20 
       00:163F: 20 20 20 20 
       00:1643: 20 20 20 20 
       00:1647: 20 20 20 20 
       00:164B: 20 2A 20 0D 
       00:164F: 0A 
  1825 00:1650: 20 2A 20 20          .DB     " *                                                                           * ",$0D,$
                    0A
       00:1654: 20 20 20 20 
       00:1658: 20 20 20 20 
       00:165C: 20 20 20 20 
       00:1660: 20 20 20 20 
       00:1664: 20 20 20 20 
       00:1668: 20 20 20 20 
       00:166C: 20 20 20 20 
       00:1670: 20 20 20 20 
       00:1674: 20 20 20 20 
       00:1678: 20 20 20 20 
       00:167C: 20 20 20 20 
       00:1680: 20 20 20 20 
       00:1684: 20 20 20 20 
       00:1688: 20 20 20 20 
       00:168C: 20 20 20 20 
       00:1690: 20 20 20 20 
       00:1694: 20 20 20 20 
       00:1698: 20 20 20 20 
       00:169C: 20 2A 20 0D 
       00:16A0: 0A 
  1826 00:16A1: 20 2A 20 20          .DB     " *             Q- Quit, return to Monitor                                    * ",$0D,$
  Thu Mar 16 2023 11:47                                                                                                    Page 43


                    0A
       00:16A5: 20 20 20 20 
       00:16A9: 20 20 20 20 
       00:16AD: 20 20 20 51 
       00:16B1: 2D 20 51 75 
       00:16B5: 69 74 2C 20 
       00:16B9: 72 65 74 75 
       00:16BD: 72 6E 20 74 
       00:16C1: 6F 20 4D 6F 
       00:16C5: 6E 69 74 6F 
       00:16C9: 72 20 20 20 
       00:16CD: 20 20 20 20 
       00:16D1: 20 20 20 20 
       00:16D5: 20 20 20 20 
       00:16D9: 20 20 20 20 
       00:16DD: 20 20 20 20 
       00:16E1: 20 20 20 20 
       00:16E5: 20 20 20 20 
       00:16E9: 20 20 20 20 
       00:16ED: 20 2A 20 0D 
       00:16F1: 0A 
  1827 00:16F2: 20 2A 20 20          .DB     " *                                                                           * ",$0D,$
                    0A
       00:16F6: 20 20 20 20 
       00:16FA: 20 20 20 20 
       00:16FE: 20 20 20 20 
       00:1702: 20 20 20 20 
       00:1706: 20 20 20 20 
       00:170A: 20 20 20 20 
       00:170E: 20 20 20 20 
       00:1712: 20 20 20 20 
       00:1716: 20 20 20 20 
       00:171A: 20 20 20 20 
       00:171E: 20 20 20 20 
       00:1722: 20 20 20 20 
       00:1726: 20 20 20 20 
       00:172A: 20 20 20 20 
       00:172E: 20 20 20 20 
       00:1732: 20 20 20 20 
       00:1736: 20 20 20 20 
       00:173A: 20 20 20 20 
       00:173E: 20 2A 20 0D 
       00:1742: 0A 
  1828 00:1743: 20 2A 2A 2A          .DB     " ***************************************************************************** ",$0D,$
                    0A,$0A
       00:1747: 2A 2A 2A 2A 
       00:174B: 2A 2A 2A 2A 
       00:174F: 2A 2A 2A 2A 
       00:1753: 2A 2A 2A 2A 
       00:1757: 2A 2A 2A 2A 
       00:175B: 2A 2A 2A 2A 
       00:175F: 2A 2A 2A 2A 
       00:1763: 2A 2A 2A 2A 
       00:1767: 2A 2A 2A 2A 
       00:176B: 2A 2A 2A 2A 
       00:176F: 2A 2A 2A 2A 
       00:1773: 2A 2A 2A 2A 
       00:1777: 2A 2A 2A 2A 
       00:177B: 2A 2A 2A 2A 
       00:177F: 2A 2A 2A 2A 
       00:1783: 2A 2A 2A 2A 
       00:1787: 2A 2A 2A 2A 
       00:178B: 2A 2A 2A 2A 
  Thu Mar 16 2023 11:47                                                                                                    Page 44


       00:178F: 2A 2A 20 0D 
       00:1793: 0A 0A 
  1829 00:1795: 20 20 20 20          .DB     "     Enter Command Number to continue: "
       00:1799: 20 45 6E 74 
       00:179D: 65 72 20 43 
       00:17A1: 6F 6D 6D 61 
       00:17A5: 6E 64 20 4E 
       00:17A9: 75 6D 62 65 
       00:17AD: 72 20 74 6F 
       00:17B1: 20 63 6F 6E 
       00:17B5: 74 69 6E 75 
       00:17B9: 65 3A 20 
  1830 00:17BC: 00                   .DB     $00
  1831                        ;
  1832                        RTC_INTRO
  1833 00:17BD: 0D 0A 0A             .DB     $0D,$0A,$0A
  1834 00:17C0: 20 52 65 61          .DB     " Realtime Clock Setup",$0D,$0A
       00:17C4: 6C 74 69 6D 
       00:17C8: 65 20 43 6C 
       00:17CC: 6F 63 6B 20 
       00:17D0: 53 65 74 75 
       00:17D4: 70 0D 0A 
  1835 00:17D7: 20 20 4E 4F          .DB     "  NOTE: Entry Data not range checked! Know what you are doing!",$0D,$0A
       00:17DB: 54 45 3A 20 
       00:17DF: 45 6E 74 72 
       00:17E3: 79 20 44 61 
       00:17E7: 74 61 20 6E 
       00:17EB: 6F 74 20 72 
       00:17EF: 61 6E 67 65 
       00:17F3: 20 63 68 65 
       00:17F7: 63 6B 65 64 
       00:17FB: 21 20 4B 6E 
       00:17FF: 6F 77 20 77 
       00:1803: 68 61 74 20 
       00:1807: 79 6F 75 20 
       00:180B: 61 72 65 20 
       00:180F: 64 6F 69 6E 
       00:1813: 67 21 0D 0A 
  1836 00:1817: 20 20 44 61          .DB     "  Day is 1-7 (1=Saturday, 7=Friday)",$0D,$0A,$0A
       00:181B: 79 20 69 73 
       00:181F: 20 31 2D 37 
       00:1823: 20 28 31 3D 
       00:1827: 53 61 74 75 
       00:182B: 72 64 61 79 
       00:182F: 2C 20 37 3D 
       00:1833: 46 72 69 64 
       00:1837: 61 79 29 0D 
       00:183B: 0A 0A 
  1837 00:183D: 20 20 45 6E          .DB     "  Enter the following to set the Date and Time.",$0D,$0A
       00:1841: 74 65 72 20 
       00:1845: 74 68 65 20 
       00:1849: 66 6F 6C 6C 
       00:184D: 6F 77 69 6E 
       00:1851: 67 20 74 6F 
       00:1855: 20 73 65 74 
       00:1859: 20 74 68 65 
       00:185D: 20 44 61 74 
       00:1861: 65 20 61 6E 
       00:1865: 64 20 54 69 
       00:1869: 6D 65 2E 0D 
       00:186D: 0A 
  1838 00:186E: 00                   .DB     $00
  1839                        ;
  Thu Mar 16 2023 11:47                                                                                                    Page 45


  1840                        RTC_YEAR_M
  1841 00:186F: 0D 0A                .DB     $0D,$0A
  1842 00:1871: 20 20 45 6E          .DB     "  Enter Year: "
       00:1875: 74 65 72 20 
       00:1879: 59 65 61 72 
       00:187D: 3A 20 
  1843 00:187F: 00                   .DB     $00
  1844                        ;
  1845                        RTC_MONTH_M
  1846 00:1880: 0D 0A                .DB     $0D,$0A
  1847 00:1882: 20 20 45 6E          .DB     "  Enter Month: "
       00:1886: 74 65 72 20 
       00:188A: 4D 6F 6E 74 
       00:188E: 68 3A 20 
  1848 00:1891: 00                   .DB     $00
  1849                        ;
  1850                        RTC_DATE_M
  1851 00:1892: 0D 0A                .DB     $0D,$0A
  1852 00:1894: 20 20 45 6E          .DB     "  Enter Date: "
       00:1898: 74 65 72 20 
       00:189C: 44 61 74 65 
       00:18A0: 3A 20 
  1853 00:18A2: 00                   .DB     $00
  1854                        ;
  1855                        RTC_DAY_M
  1856 00:18A3: 0D 0A                .DB     $0D,$0A
  1857 00:18A5: 20 20 45 6E          .DB     "  Enter Day: "
       00:18A9: 74 65 72 20 
       00:18AD: 44 61 79 3A 
       00:18B1: 20 
  1858 00:18B2: 00                   .DB     $00
  1859                        ;
  1860                        RTC_HOURS_M
  1861 00:18B3: 0D 0A                .DB     $0D,$0A
  1862 00:18B5: 20 20 45 6E          .DB     "  Enter Hours: "
       00:18B9: 74 65 72 20 
       00:18BD: 48 6F 75 72 
       00:18C1: 73 3A 20 
  1863 00:18C4: 00                   .DB     $00
  1864                        ;
  1865                        RTC_MINUTES_M
  1866 00:18C5: 0D 0A                .DB     $0D,$0A
  1867 00:18C7: 20 20 45 6E          .DB     "  Enter Minutes: "
       00:18CB: 74 65 72 20 
       00:18CF: 4D 69 6E 75 
       00:18D3: 74 65 73 3A 
       00:18D7: 20 
  1868 00:18D8: 00                   .DB     $00
  1869                        ;
  1870                        RTC_SECONDS_M
  1871 00:18D9: 0D 0A                .DB     $0D,$0A
  1872 00:18DB: 20 20 45 6E          .DB     "  Enter Seconds: "
       00:18DF: 74 65 72 20 
       00:18E3: 53 65 63 6F 
       00:18E7: 6E 64 73 3A 
       00:18EB: 20 
  1873 00:18EC: 00                   .DB     $00
  1874                        ;
  1875                        RTC_WRITE
  1876 00:18ED: 0D 0A                .DB     $0D,$0A
  1877 00:18EF: 20 41 62 6F          .DB     " About to write Data to RTC! Are you sure? "
       00:18F3: 75 74 20 74 
       00:18F7: 6F 20 77 72 
  Thu Mar 16 2023 11:47                                                                                                    Page 46


       00:18FB: 69 74 65 20 
       00:18FF: 44 61 74 61 
       00:1903: 20 74 6F 20 
       00:1907: 52 54 43 21 
       00:190B: 20 41 72 65 
       00:190F: 20 79 6F 75 
       00:1913: 20 73 75 72 
       00:1917: 65 3F 20 
  1878 00:191A: 00                   .DB     $00
  1879                        ;
  1880                        RTC_CONFIRM
  1881 00:191B: 0D 0A 0A             .DB     $0D,$0A,$0A
  1882 00:191E: 20 52 54 43          .DB     " RTC Data Updated!"
       00:1922: 20 44 61 74 
       00:1926: 61 20 55 70 
       00:192A: 64 61 74 65 
       00:192E: 64 21 
  1883 00:1930: 0D 0A                .DB     $0D,$0A
  1884 00:1932: 00                   .DB     $00
  1885                        ;
  1886                        ALARM_CLEAR
  1887 00:1933: 0D 0A                .DB     $0D,$0A
  1888 00:1935: 20 43 6C 65          .DB     " Clear the Alarm and Interrupt functions? "
       00:1939: 61 72 20 74 
       00:193D: 68 65 20 41 
       00:1941: 6C 61 72 6D 
       00:1945: 20 61 6E 64 
       00:1949: 20 49 6E 74 
       00:194D: 65 72 72 75 
       00:1951: 70 74 20 66 
       00:1955: 75 6E 63 74 
       00:1959: 69 6F 6E 73 
       00:195D: 3F 20 
  1889 00:195F: 00                   .DB     $00
  1890                        ;
  1891                        QUIT_MSG
  1892 00:1960: 0D 0A 0A             .DB     $0D,$0A,$0A
  1893 00:1963: 20 52 65 74          .DB     " Returning to DOS/65."
       00:1967: 75 72 6E 69 
       00:196B: 6E 67 20 74 
       00:196F: 6F 20 44 4F 
       00:1973: 53 2F 36 35 
       00:1977: 2E 
  1894 00:1978: 0D 0A                .DB     $0D,$0A
  1895 00:197A: 00                   .DB     $00
  1896                        ;
  1897                        NVRAM_WRMSG
  1898 00:197B: 0D 0A                .DB     $0D,$0A
  1899 00:197D: 20 45 6E 74          .DB     " Enter address for NVRAM data write"
       00:1981: 65 72 20 61 
       00:1985: 64 64 72 65 
       00:1989: 73 73 20 66 
       00:198D: 6F 72 20 4E 
       00:1991: 56 52 41 4D 
       00:1995: 20 64 61 74 
       00:1999: 61 20 77 72 
       00:199D: 69 74 65 
  1900 00:19A0: 0D 0A                .DB     $0D,$0A
  1901 00:19A2: 20 6F 72 20          .DB     " or hit enter to accept default address: "
       00:19A6: 68 69 74 20 
       00:19AA: 65 6E 74 65 
       00:19AE: 72 20 74 6F 
       00:19B2: 20 61 63 63 
  Thu Mar 16 2023 11:47                                                                                                    Page 47


       00:19B6: 65 70 74 20 
       00:19BA: 64 65 66 61 
       00:19BE: 75 6C 74 20 
       00:19C2: 61 64 64 72 
       00:19C6: 65 73 73 3A 
       00:19CA: 20 
  1902 00:19CB: 00                   .DB     $00
  1903                        ;
  1904                        NVRAM_CONF
  1905 00:19CC: 20 20 41 62          .DB     "  About to write NVRAM! Are you sure? (Y/N): "
       00:19D0: 6F 75 74 20 
       00:19D4: 74 6F 20 77 
       00:19D8: 72 69 74 65 
       00:19DC: 20 4E 56 52 
       00:19E0: 41 4D 21 20 
       00:19E4: 41 72 65 20 
       00:19E8: 79 6F 75 20 
       00:19EC: 73 75 72 65 
       00:19F0: 3F 20 28 59 
       00:19F4: 2F 4E 29 3A 
       00:19F8: 20 
  1906 00:19F9: 00                   .DB     $00
  1907                        ;
  1908                        NVRAM_DONE
  1909 00:19FA: 0D 0A                .DB     $0D,$0A
  1910 00:19FC: 20 4E 56 52          .DB     " NVRAM Data written."
       00:1A00: 41 4D 20 44 
       00:1A04: 61 74 61 20 
       00:1A08: 77 72 69 74 
       00:1A0C: 74 65 6E 2E 
  1911 00:1A10: 00                   .DB     $00
  1912                        ;
  1913                        USER_INMSG
  1914 00:1A11: 0D 0A 0A             .DB     $0D,$0A,$0A
  1915 00:1A14: 20 45 6E 74          .DB     " Enter Command or M for Menu."
       00:1A18: 65 72 20 43 
       00:1A1C: 6F 6D 6D 61 
       00:1A20: 6E 64 20 6F 
       00:1A24: 72 20 4D 20 
       00:1A28: 66 6F 72 20 
       00:1A2C: 4D 65 6E 75 
       00:1A30: 2E 
  1916 00:1A31: 0D 0A                .DB     $0D,$0A
  1917 00:1A33: 00                   .DB     $00
  1918                        ;
  1919                        DRIVE_IDENTITY
  1920 00:1A34: 0D 0A 0A             .DB     $0D,$0A,$0A
  1921 00:1A37: 20 4D 69 63          .DB     " MicroDrive Information:"
       00:1A3B: 72 6F 44 72 
       00:1A3F: 69 76 65 20 
       00:1A43: 49 6E 66 6F 
       00:1A47: 72 6D 61 74 
       00:1A4B: 69 6F 6E 3A 
  1922 00:1A4F: 0D 0A                .DB     $0D,$0A
  1923 00:1A51: 00                   .DB     $00
  1924                        ;
  1925                        MODEL_NUM
  1926 00:1A52: 0D 0A                .DB     $0D,$0A
  1927 00:1A54: 20 4D 6F 64          .DB     " Model Number: "
       00:1A58: 65 6C 20 4E 
       00:1A5C: 75 6D 62 65 
       00:1A60: 72 3A 20 
  1928 00:1A63: 00                   .DB     $00
  Thu Mar 16 2023 11:47                                                                                                    Page 48


  1929                        ;
  1930                        SERIAL_NUM
  1931 00:1A64: 0D 0A                .DB     $0D,$0A
  1932 00:1A66: 20 53 65 72          .DB     " Serial Number: "
       00:1A6A: 69 61 6C 20 
       00:1A6E: 4E 75 6D 62 
       00:1A72: 65 72 3A 20 
  1933 00:1A76: 00                   .DB     $00
  1934                        ;
  1935                        FIRM_REV
  1936 00:1A77: 0D 0A                .DB     $0D,$0A
  1937 00:1A79: 20 46 69 72          .DB     " Firmware Revision: "
       00:1A7D: 6D 77 61 72 
       00:1A81: 65 20 52 65 
       00:1A85: 76 69 73 69 
       00:1A89: 6F 6E 3A 20 
  1938 00:1A8D: 00                   .DB     $00
  1939                        ;
  1940                        MODE_SUPPORT
  1941 00:1A8E: 0D 0A                .DB     $0D,$0A
  1942 00:1A90: 20 4C 42 41          .DB     " LBA Mode Supported: "
       00:1A94: 20 4D 6F 64 
       00:1A98: 65 20 53 75 
       00:1A9C: 70 70 6F 72 
       00:1AA0: 74 65 64 3A 
       00:1AA4: 20 
  1943 00:1AA5: 00                   .DB     $00
  1944                        TOTAL_LBA
  1945 00:1AA6: 0D 0A                .DB     $0D,$0A
  1946 00:1AA8: 20 54 6F 74          .DB     " Total LBA Count: "
       00:1AAC: 61 6C 20 4C 
       00:1AB0: 42 41 20 43 
       00:1AB4: 6F 75 6E 74 
       00:1AB8: 3A 20 
  1947 00:1ABA: 00                   .DB     $00
  1948                        ;
  1949                        LBA_INPUT
  1950 00:1ABB: 0D 0A                .DB     $0D,$0A
  1951 00:1ABD: 20 45 6E 74          .DB     " Enter LBA number to Read from: "
       00:1AC1: 65 72 20 4C 
       00:1AC5: 42 41 20 6E 
       00:1AC9: 75 6D 62 65 
       00:1ACD: 72 20 74 6F 
       00:1AD1: 20 52 65 61 
       00:1AD5: 64 20 66 72 
       00:1AD9: 6F 6D 3A 20 
  1952 00:1ADD: 00                   .DB     $00
  1953                        ;
  1954                        LBA_OUTPUT
  1955 00:1ADE: 0D 0A                .DB     $0D,$0A
  1956 00:1AE0: 20 45 6E 74          .DB     " Enter LBA number to Write to: "
       00:1AE4: 65 72 20 4C 
       00:1AE8: 42 41 20 6E 
       00:1AEC: 75 6D 62 65 
       00:1AF0: 72 20 74 6F 
       00:1AF4: 20 57 72 69 
       00:1AF8: 74 65 20 74 
       00:1AFC: 6F 3A 20 
  1957 00:1AFF: 00                   .DB     $00
  1958                        ;
  1959                        LBA_START
  1960 00:1B00: 0D 0A                .DB     $0D,$0A
  1961 00:1B02: 20 45 6E 74          .DB     " Enter starting LBA number: "
  Thu Mar 16 2023 11:47                                                                                                    Page 49


       00:1B06: 65 72 20 73 
       00:1B0A: 74 61 72 74 
       00:1B0E: 69 6E 67 20 
       00:1B12: 4C 42 41 20 
       00:1B16: 6E 75 6D 62 
       00:1B1A: 65 72 3A 20 
  1962 00:1B1E: 00                   .DB     $00
  1963                        ;
  1964                        LBA_WR_DATA
  1965 00:1B1F: 0D 0A                .DB     $0D,$0A
  1966 00:1B21: 20 41 62 6F          .DB     " About to write LBA from buffer Data below!"
       00:1B25: 75 74 20 74 
       00:1B29: 6F 20 77 72 
       00:1B2D: 69 74 65 20 
       00:1B31: 4C 42 41 20 
       00:1B35: 66 72 6F 6D 
       00:1B39: 20 62 75 66 
       00:1B3D: 66 65 72 20 
       00:1B41: 44 61 74 61 
       00:1B45: 20 62 65 6C 
       00:1B49: 6F 77 21 
  1967 00:1B4C: 0D 0A                .DB     $0D,$0A
  1968 00:1B4E: 00                   .DB     $00
  1969                        ;
  1970                        LBA_WR_CNFM
  1971 00:1B4F: 0D 0A                .DB     $0D,$0A
  1972 00:1B51: 20 41 72 65          .DB     " Are you SURE you want to overwrite the LBA?"
       00:1B55: 20 79 6F 75 
       00:1B59: 20 53 55 52 
       00:1B5D: 45 20 79 6F 
       00:1B61: 75 20 77 61 
       00:1B65: 6E 74 20 74 
       00:1B69: 6F 20 6F 76 
       00:1B6D: 65 72 77 72 
       00:1B71: 69 74 65 20 
       00:1B75: 74 68 65 20 
       00:1B79: 4C 42 41 3F 
  1973 00:1B7D: 00                   .DB     $00
  1974                        ;
  1975                        NEXT_LBA
  1976 00:1B7E: 0D 0A                .DB     $0D,$0A
  1977 00:1B80: 20 44 69 73          .DB     " Display (N)ext LBA or (R)eturn "
       00:1B84: 70 6C 61 79 
       00:1B88: 20 28 4E 29 
       00:1B8C: 65 78 74 20 
       00:1B90: 4C 42 41 20 
       00:1B94: 6F 72 20 28 
       00:1B98: 52 29 65 74 
       00:1B9C: 75 72 6E 20 
  1978 00:1BA0: 00                   .DB     $00
  1979                        ;
  1980                        SHOW_NEXT_LBA
  1981 00:1BA1: 0D 0A 0A             .DB     $0D,$0A,$0A
  1982 00:1BA4: 20 44 69 73          .DB     " Displaying Data for LBA: "
       00:1BA8: 70 6C 61 79 
       00:1BAC: 69 6E 67 20 
       00:1BB0: 44 61 74 61 
       00:1BB4: 20 66 6F 72 
       00:1BB8: 20 4C 42 41 
       00:1BBC: 3A 20 
  1983 00:1BBE: 00                   .DB     $00
  1984                        ;
  1985                        LBA_SEQ_RD_MSG
  Thu Mar 16 2023 11:47                                                                                                    Page 50


  1986 00:1BBF: 0D 0A 0A             .DB     $0D,$0A,$0A
  1987 00:1BC2: 20 41 62 6F          .DB     " About to read ALL LBAs from MicroDrive!"
       00:1BC6: 75 74 20 74 
       00:1BCA: 6F 20 72 65 
       00:1BCE: 61 64 20 41 
       00:1BD2: 4C 4C 20 4C 
       00:1BD6: 42 41 73 20 
       00:1BDA: 66 72 6F 6D 
       00:1BDE: 20 4D 69 63 
       00:1BE2: 72 6F 44 72 
       00:1BE6: 69 76 65 21 
  1988 00:1BEA: 0D 0A                .DB     $0D,$0A
  1989 00:1BEC: 00                   .DB     $00
  1990                        ;
  1991                        LBA_SEQ_WR_MSG
  1992 00:1BED: 0D 0A 0A             .DB     $0D,$0A,$0A
  1993 00:1BF0: 20 41 62 6F          .DB     " About to write ALL LBAs to MicroDrive!"
       00:1BF4: 75 74 20 74 
       00:1BF8: 6F 20 77 72 
       00:1BFC: 69 74 65 20 
       00:1C00: 41 4C 4C 20 
       00:1C04: 4C 42 41 73 
       00:1C08: 20 74 6F 20 
       00:1C0C: 4D 69 63 72 
       00:1C10: 6F 44 72 69 
       00:1C14: 76 65 21 
  1994 00:1C17: 0D 0A                .DB     $0D,$0A
  1995 00:1C19: 00                   .DB     $00
  1996                        ;
  1997                        LBA_SEQ_TM_MSG
  1998 00:1C1A: 20 43 6F 6D          .DB     " Completion time based on drive capacity."
       00:1C1E: 70 6C 65 74 
       00:1C22: 69 6F 6E 20 
       00:1C26: 74 69 6D 65 
       00:1C2A: 20 62 61 73 
       00:1C2E: 65 64 20 6F 
       00:1C32: 6E 20 64 72 
       00:1C36: 69 76 65 20 
       00:1C3A: 63 61 70 61 
       00:1C3E: 63 69 74 79 
       00:1C42: 2E 
  1999 00:1C43: 0D 0A                .DB     $0D,$0A
  2000 00:1C45: 00                   .DB     $00
  2001                        
  2002                        LBA_SEQ_CFM
  2003 00:1C46: 0D 0A                .DB     $0D,$0A
  2004 00:1C48: 20 41 72 65          .DB     " Are you sure you want to"
       00:1C4C: 20 79 6F 75 
       00:1C50: 20 73 75 72 
       00:1C54: 65 20 79 6F 
       00:1C58: 75 20 77 61 
       00:1C5C: 6E 74 20 74 
       00:1C60: 6F 
  2005 00:1C61: 00                   .DB     $00
  2006                        ;
  2007                        LBA_SEQ_CFM2
  2008 00:1C62: 0D 0A                .DB     $0D,$0A
  2009 00:1C64: 20 41 72 65          .DB     " Are you REALLY sure you want to"
       00:1C68: 20 79 6F 75 
       00:1C6C: 20 52 45 41 
       00:1C70: 4C 4C 59 20 
       00:1C74: 73 75 72 65 
       00:1C78: 20 79 6F 75 
  Thu Mar 16 2023 11:47                                                                                                    Page 51


       00:1C7C: 20 77 61 6E 
       00:1C80: 74 20 74 6F 
  2010 00:1C84: 00                   .DB     $00
  2011                        ;
  2012                        LBA_BLKS_RD
  2013 00:1C85: 0D 0A                .DB     $0D,$0A
  2014 00:1C87: 42 6C 6F 63          .DB     "Blocks Read:"
       00:1C8B: 6B 73 20 52 
       00:1C8F: 65 61 64 3A 
  2015 00:1C93: 0D 0A 00             .DB     $0D,$0A,$00
  2016                        ;
  2017                        LBA_BLKS_WR
  2018 00:1C96: 0D 0A                .DB     $0D,$0A
  2019 00:1C98: 42 6C 6F 63          .DB     "Blocks Written:"
       00:1C9C: 6B 73 20 57 
       00:1CA0: 72 69 74 74 
       00:1CA4: 65 6E 3A 
  2020 00:1CA7: 0D 0A 00             .DB     $0D,$0A,$00
  2021                        ;
  2022                        LBA_BLKS_RD_CMP
  2023 00:1CAA: 0D 0A                .DB     $0D,$0A
  2024 00:1CAC: 20 41 6C 6C          .DB     " All LBAs have been successfully read!"
       00:1CB0: 20 4C 42 41 
       00:1CB4: 73 20 68 61 
       00:1CB8: 76 65 20 62 
       00:1CBC: 65 65 6E 20 
       00:1CC0: 73 75 63 63 
       00:1CC4: 65 73 73 66 
       00:1CC8: 75 6C 6C 79 
       00:1CCC: 20 72 65 61 
       00:1CD0: 64 21 
  2025 00:1CD2: 0D 0A                .DB     $0D,$0A
  2026 00:1CD4: 00                   .DB     $00
  2027                        ;
  2028                        LBA_BLKS_WR_CMP
  2029 00:1CD5: 0D 0A                .DB     $0D,$0A
  2030 00:1CD7: 20 41 6C 6C          .DB     " All LBAs have been successfully written!"
       00:1CDB: 20 4C 42 41 
       00:1CDF: 73 20 68 61 
       00:1CE3: 76 65 20 62 
       00:1CE7: 65 65 6E 20 
       00:1CEB: 73 75 63 63 
       00:1CEF: 65 73 73 66 
       00:1CF3: 75 6C 6C 79 
       00:1CF7: 20 77 72 69 
       00:1CFB: 74 74 65 6E 
       00:1CFF: 21 
  2031 00:1D00: 0D 0A                .DB     $0D,$0A
  2032 00:1D02: 00                   .DB     $00
  2033                        ;
  2034                        PATTERN_MSG
  2035 00:1D03: 0D 0A                .DB     $0D,$0A
  2036 00:1D05: 20 45 6E 74          .DB     " Enter a 16-bit Hex value for the Fill Pattern: "
       00:1D09: 65 72 20 61 
       00:1D0D: 20 31 36 2D 
       00:1D11: 62 69 74 20 
       00:1D15: 48 65 78 20 
       00:1D19: 76 61 6C 75 
       00:1D1D: 65 20 66 6F 
       00:1D21: 72 20 74 68 
       00:1D25: 65 20 46 69 
       00:1D29: 6C 6C 20 50 
       00:1D2D: 61 74 74 65 
  Thu Mar 16 2023 11:47                                                                                                    Page 52


       00:1D31: 72 6E 3A 20 
  2037 00:1D35: 00                   .DB     $00
  2038                        ;
  2039                        LBA_BENCH_INTRO
  2040 00:1D36: 0D 0A 0A             .DB     $0D,$0A,$0A
  2041 00:1D39: 20 42 65 6E          .DB     " Benchmark Performance Testing to Read or Write",$0D,$0A
       00:1D3D: 63 68 6D 61 
       00:1D41: 72 6B 20 50 
       00:1D45: 65 72 66 6F 
       00:1D49: 72 6D 61 6E 
       00:1D4D: 63 65 20 54 
       00:1D51: 65 73 74 69 
       00:1D55: 6E 67 20 74 
       00:1D59: 6F 20 52 65 
       00:1D5D: 61 64 20 6F 
       00:1D61: 72 20 57 72 
       00:1D65: 69 74 65 0D 
       00:1D69: 0A 
  2042 00:1D6A: 20 61 20 31          .DB     " a 16MB contiguous block of data starting from",$0D,$0A
       00:1D6E: 36 4D 42 20 
       00:1D72: 63 6F 6E 74 
       00:1D76: 69 67 75 6F 
       00:1D7A: 75 73 20 62 
       00:1D7E: 6C 6F 63 6B 
       00:1D82: 20 6F 66 20 
       00:1D86: 64 61 74 61 
       00:1D8A: 20 73 74 61 
       00:1D8E: 72 74 69 6E 
       00:1D92: 67 20 66 72 
       00:1D96: 6F 6D 0D 0A 
  2043 00:1D9A: 20 74 68 65          .DB     " the entered LBA address.",$0D,$0A,$0A
       00:1D9E: 20 65 6E 74 
       00:1DA2: 65 72 65 64 
       00:1DA6: 20 4C 42 41 
       00:1DAA: 20 61 64 64 
       00:1DAE: 72 65 73 73 
       00:1DB2: 2E 0D 0A 0A 
  2044 00:1DB6: 20 54 68 65          .DB     " The Write Benchmark requires a 16-bit Hex fill pattern.",$0D,$0A
       00:1DBA: 20 57 72 69 
       00:1DBE: 74 65 20 42 
       00:1DC2: 65 6E 63 68 
       00:1DC6: 6D 61 72 6B 
       00:1DCA: 20 72 65 71 
       00:1DCE: 75 69 72 65 
       00:1DD2: 73 20 61 20 
       00:1DD6: 31 36 2D 62 
       00:1DDA: 69 74 20 48 
       00:1DDE: 65 78 20 66 
       00:1DE2: 69 6C 6C 20 
       00:1DE6: 70 61 74 74 
       00:1DEA: 65 72 6E 2E 
       00:1DEE: 0D 0A 
  2045 00:1DF0: 20 4E 6F 74          .DB     " Note: the Write Benchmark will result in",$0D,$0A
       00:1DF4: 65 3A 20 74 
       00:1DF8: 68 65 20 57 
       00:1DFC: 72 69 74 65 
       00:1E00: 20 42 65 6E 
       00:1E04: 63 68 6D 61 
       00:1E08: 72 6B 20 77 
       00:1E0C: 69 6C 6C 20 
       00:1E10: 72 65 73 75 
       00:1E14: 6C 74 20 69 
       00:1E18: 6E 0D 0A 
  Thu Mar 16 2023 11:47                                                                                                    Page 53


  2046 00:1E1B: 20 4C 4F 53          .DB     " LOSS of DATA on the MicroDrive being tested!",$0D,$0A,$0A
       00:1E1F: 53 20 6F 66 
       00:1E23: 20 44 41 54 
       00:1E27: 41 20 6F 6E 
       00:1E2B: 20 74 68 65 
       00:1E2F: 20 4D 69 63 
       00:1E33: 72 6F 44 72 
       00:1E37: 69 76 65 20 
       00:1E3B: 62 65 69 6E 
       00:1E3F: 67 20 74 65 
       00:1E43: 73 74 65 64 
       00:1E47: 21 0D 0A 0A 
  2047 00:1E4B: 20 4D 61 6B          .DB     " Make sure you know what you are doing!",$0D,$0A,$0A
       00:1E4F: 65 20 73 75 
       00:1E53: 72 65 20 79 
       00:1E57: 6F 75 20 6B 
       00:1E5B: 6E 6F 77 20 
       00:1E5F: 77 68 61 74 
       00:1E63: 20 79 6F 75 
       00:1E67: 20 61 72 65 
       00:1E6B: 20 64 6F 69 
       00:1E6F: 6E 67 21 0D 
       00:1E73: 0A 0A 
  2048 00:1E75: 20 45 6E 74          .DB     " Enter 'R' for Read or 'W' for Write: "
       00:1E79: 65 72 20 27 
       00:1E7D: 52 27 20 66 
       00:1E81: 6F 72 20 52 
       00:1E85: 65 61 64 20 
       00:1E89: 6F 72 20 27 
       00:1E8D: 57 27 20 66 
       00:1E91: 6F 72 20 57 
       00:1E95: 72 69 74 65 
       00:1E99: 3A 20 
  2049 00:1E9B: 00                   .DB     $00
  2050                        ;
  2051                        LBA_RD_BENCH
  2052 00:1E9C: 0D 0A 0A             .DB     $0D,$0A,$0A
  2053 00:1E9F: 20 52 65 61          .DB     " Reading 16MB of LBA data in: "
       00:1EA3: 64 69 6E 67 
       00:1EA7: 20 31 36 4D 
       00:1EAB: 42 20 6F 66 
       00:1EAF: 20 4C 42 41 
       00:1EB3: 20 64 61 74 
       00:1EB7: 61 20 69 6E 
       00:1EBB: 3A 20 
  2054 00:1EBD: 00                   .DB     $00
  2055                        ;
  2056                        LBA_WR_BENCH
  2057 00:1EBE: 0D 0A 0A             .DB     $0D,$0A,$0A
  2058 00:1EC1: 20 57 72 69          .DB     " Writing 16MB of LBA data in: "
       00:1EC5: 74 69 6E 67 
       00:1EC9: 20 31 36 4D 
       00:1ECD: 42 20 6F 66 
       00:1ED1: 20 4C 42 41 
       00:1ED5: 20 64 61 74 
       00:1ED9: 61 20 69 6E 
       00:1EDD: 3A 20 
  2059 00:1EDF: 00                   .DB     $00
  2060                        ;
  2061                        LBA_BENCH_WARN
  2062 00:1EE0: 0D 0A 0A             .DB     $0D,$0A,$0A
  2063 00:1EE3: 20 59 6F 75          .DB     " You are about to Write 32,768 LBAs!",$0D,$0A
       00:1EE7: 20 61 72 65 
  Thu Mar 16 2023 11:47                                                                                                    Page 54


       00:1EEB: 20 61 62 6F 
       00:1EEF: 75 74 20 74 
       00:1EF3: 6F 20 57 72 
       00:1EF7: 69 74 65 20 
       00:1EFB: 33 32 2C 37 
       00:1EFF: 36 38 20 4C 
       00:1F03: 42 41 73 21 
       00:1F07: 0D 0A 
  2064 00:1F09: 20 41 6C 6C          .DB     " All Data from starting LBA will be overwritten!",$0D,$0A
       00:1F0D: 20 44 61 74 
       00:1F11: 61 20 66 72 
       00:1F15: 6F 6D 20 73 
       00:1F19: 74 61 72 74 
       00:1F1D: 69 6E 67 20 
       00:1F21: 4C 42 41 20 
       00:1F25: 77 69 6C 6C 
       00:1F29: 20 62 65 20 
       00:1F2D: 6F 76 65 72 
       00:1F31: 77 72 69 74 
       00:1F35: 74 65 6E 21 
       00:1F39: 0D 0A 
  2065 00:1F3B: 20 42 65 20          .DB     " Be sure about this before continuing (Y/N)"
       00:1F3F: 73 75 72 65 
       00:1F43: 20 61 62 6F 
       00:1F47: 75 74 20 74 
       00:1F4B: 68 69 73 20 
       00:1F4F: 62 65 66 6F 
       00:1F53: 72 65 20 63 
       00:1F57: 6F 6E 74 69 
       00:1F5B: 6E 75 69 6E 
       00:1F5F: 67 20 28 59 
       00:1F63: 2F 4E 29 
  2066 00:1F66: 00                   .DB     $00
  2067                        ;
  2068                        LBA_BENCH_ABORT
  2069 00:1F67: 0D 0A                .DB     $0D,$0A
  2070 00:1F69: 20 57 72 69          .DB     " Write Benchmark test aborted!",$0D,$0A
       00:1F6D: 74 65 20 42 
       00:1F71: 65 6E 63 68 
       00:1F75: 6D 61 72 6B 
       00:1F79: 20 74 65 73 
       00:1F7D: 74 20 61 62 
       00:1F81: 6F 72 74 65 
       00:1F85: 64 21 0D 0A 
  2071 00:1F89: 00                   .DB     $00
  2072                        ;
  2073                        IDE_CONTROLLER_ERROR
  2074 00:1F8A: 0D 0A 0A             .DB     $0D,$0A,$0A
  2075 00:1F8D: 20 41 6E 20          .DB     " An error occured accessing the MicroDrive!",$0D,$0A,$0A
       00:1F91: 65 72 72 6F 
       00:1F95: 72 20 6F 63 
       00:1F99: 63 75 72 65 
       00:1F9D: 64 20 61 63 
       00:1FA1: 63 65 73 73 
       00:1FA5: 69 6E 67 20 
       00:1FA9: 74 68 65 20 
       00:1FAD: 4D 69 63 72 
       00:1FB1: 6F 44 72 69 
       00:1FB5: 76 65 21 0D 
       00:1FB9: 0A 0A 
  2076 00:1FBB: 20 20 2A 20          .DB     "  * "
  2077 00:1FBF: 00                   .DB     $00
  2078                        ;
  Thu Mar 16 2023 11:47                                                                                                    Page 55


  2079                        SYS_INTRO_MSG
  2080 00:1FC0: 0D 0A                .DB     $0D,$0A
  2081 00:1FC2: 54 68 69 73          .DB     "This will write an image from memory to the Microdrive!",$0D,$0A
       00:1FC6: 20 77 69 6C 
       00:1FCA: 6C 20 77 72 
       00:1FCE: 69 74 65 20 
       00:1FD2: 61 6E 20 69 
       00:1FD6: 6D 61 67 65 
       00:1FDA: 20 66 72 6F 
       00:1FDE: 6D 20 6D 65 
       00:1FE2: 6D 6F 72 79 
       00:1FE6: 20 74 6F 20 
       00:1FEA: 74 68 65 20 
       00:1FEE: 4D 69 63 72 
       00:1FF2: 6F 64 72 69 
       00:1FF6: 76 65 21 0D 
       00:1FFA: 0A 
  2082 00:1FFB: 4D 61 6B 65          .DB     "Make sure you know what you are doing before you commit!!",$0D,$0A,$0A
       00:1FFF: 20 73 75 72 
       00:2003: 65 20 79 6F 
       00:2007: 75 20 6B 6E 
       00:200B: 6F 77 20 77 
       00:200F: 68 61 74 20 
       00:2013: 79 6F 75 20 
       00:2017: 61 72 65 20 
       00:201B: 64 6F 69 6E 
       00:201F: 67 20 62 65 
       00:2023: 66 6F 72 65 
       00:2027: 20 79 6F 75 
       00:202B: 20 63 6F 6D 
       00:202F: 6D 69 74 21 
       00:2033: 21 0D 0A 0A 
  2083 00:2037: 00                   .DB     $00
  2084                        ;
  2085                        SYS_LBA_MSG
  2086 00:2038: 0D 0A                .DB     $0D,$0A
  2087 00:203A: 20 45 6E 74          .DB     " Enter the Starting LBA (decimal) to write the Memory Image to: "
       00:203E: 65 72 20 74 
       00:2042: 68 65 20 53 
       00:2046: 74 61 72 74 
       00:204A: 69 6E 67 20 
       00:204E: 4C 42 41 20 
       00:2052: 28 64 65 63 
       00:2056: 69 6D 61 6C 
       00:205A: 29 20 74 6F 
       00:205E: 20 77 72 69 
       00:2062: 74 65 20 74 
       00:2066: 68 65 20 4D 
       00:206A: 65 6D 6F 72 
       00:206E: 79 20 49 6D 
       00:2072: 61 67 65 20 
       00:2076: 74 6F 3A 20 
  2088 00:207A: 00                   .DB     $00
  2089                        ;
  2090                        BLK_SIZE_MSG
  2091 00:207B: 0D 0A                .DB     $0D,$0A
  2092 00:207D: 20 45 6E 74          .DB     " Enter the number of 512-byte Blocks (decimal) to transfer: "
       00:2081: 65 72 20 74 
       00:2085: 68 65 20 6E 
       00:2089: 75 6D 62 65 
       00:208D: 72 20 6F 66 
       00:2091: 20 35 31 32 
       00:2095: 2D 62 79 74 
  Thu Mar 16 2023 11:47                                                                                                    Page 56


       00:2099: 65 20 42 6C 
       00:209D: 6F 63 6B 73 
       00:20A1: 20 28 64 65 
       00:20A5: 63 69 6D 61 
       00:20A9: 6C 29 20 74 
       00:20AD: 6F 20 74 72 
       00:20B1: 61 6E 73 66 
       00:20B5: 65 72 3A 20 
  2093 00:20B9: 00                   .DB     $00
  2094                        ;
  2095                        RAM_START_MSG
  2096 00:20BA: 0D 0A                .DB     $0D,$0A
  2097 00:20BC: 20 45 6E 74          .DB     " Enter the Starting RAM address in Hex: "
       00:20C0: 65 72 20 74 
       00:20C4: 68 65 20 53 
       00:20C8: 74 61 72 74 
       00:20CC: 69 6E 67 20 
       00:20D0: 52 41 4D 20 
       00:20D4: 61 64 64 72 
       00:20D8: 65 73 73 20 
       00:20DC: 69 6E 20 48 
       00:20E0: 65 78 3A 20 
  2098 00:20E4: 00                   .DB     $00
  2099                        ;
  2100                        SYS_CONFIRM_MSG
  2101 00:20E5: 0D 0A                .DB     $0D,$0A
  2102 00:20E7: 20 41 72 65          .DB     " Are you sure you want to overwrite the Disc data? "
       00:20EB: 20 79 6F 75 
       00:20EF: 20 73 75 72 
       00:20F3: 65 20 79 6F 
       00:20F7: 75 20 77 61 
       00:20FB: 6E 74 20 74 
       00:20FF: 6F 20 6F 76 
       00:2103: 65 72 77 72 
       00:2107: 69 74 65 20 
       00:210B: 74 68 65 20 
       00:210F: 44 69 73 63 
       00:2113: 20 64 61 74 
       00:2117: 61 3F 20 
  2103 00:211A: 00                   .DB     $00
  2104                        ;
  2105                        SYS_WRITE_MSG
  2106 00:211B: 0D 0A                .DB     $0D,$0A
  2107 00:211D: 20 57 72 69          .DB     " Writing Disc Image..."
       00:2121: 74 69 6E 67 
       00:2125: 20 44 69 73 
       00:2129: 63 20 49 6D 
       00:212D: 61 67 65 2E 
       00:2131: 2E 2E 
  2108 00:2133: 0D 0A 00             .DB     $0D,$0A,$00
  2109                        ;
  2110                        SYS_COMPLETE_MSG
  2111 00:2136: 0D 0A                .DB     $0D,$0A
  2112 00:2138: 20 53 79 73          .DB     " System Image written to Disc."
       00:213C: 74 65 6D 20 
       00:2140: 49 6D 61 67 
       00:2144: 65 20 77 72 
       00:2148: 69 74 74 65 
       00:214C: 6E 20 74 6F 
       00:2150: 20 44 69 73 
       00:2154: 63 2E 
  2113 00:2156: 0A 0D 00             .DB     $0A,$0D,$00
  2114                        ;
  Thu Mar 16 2023 11:47                                                                                                    Page 57


  2115                        ;
  2116                        ; BCD multiplicand table:
  2117                        ;
  2118 00:2159: 00 00 00 00  HMULTAB .DB $00, $00, $00, $00, $01             ;BCD weight of least significant HEX digit
       00:215D: 01 
  2119 00:215E: 00 00 00 00          .DB $00, $00, $00, $00, $16
       00:2162: 16 
  2120 00:2163: 00 00 00 02          .DB $00, $00, $00, $02, $56
       00:2167: 56 
  2121 00:2168: 00 00 00 40          .DB $00, $00, $00, $40, $96
       00:216C: 96 
  2122 00:216D: 00 00 06 55          .DB $00, $00, $06, $55, $36
       00:2171: 36 
  2123 00:2172: 00 01 04 85          .DB $00, $01, $04, $85, $76
       00:2176: 76 
  2124 00:2177: 00 16 77 72          .DB $00, $16, $77, $72, $16
       00:217B: 16 
  2125 00:217C: 02 68 43 54          .DB $02, $68, $43, $54, $56             ;BCD weight of most significant HEX digit
       00:2180: 56 
  2126                        ;
  2127                        ; HEX multiplicand table:
  2128                        ;
  2129 00:2181: 00 00 00 01  DMULTAB .DB  $00, $00, $00, $01                 ;HEX weight of least significant BCD digit
  2130 00:2185: 00 00 00 0A          .DB  $00, $00, $00, $0A
  2131 00:2189: 00 00 00 64          .DB  $00, $00, $00, $64
  2132 00:218D: 00 00 03 E8          .DB  $00, $00, $03, $E8
  2133 00:2191: 00 00 27 10          .DB  $00, $00, $27, $10
  2134 00:2195: 00 01 86 A0          .DB  $00, $01, $86, $A0
  2135 00:2199: 00 0F 42 40          .DB  $00, $0F, $42, $40
  2136 00:219D: 00 98 96 80          .DB  $00, $98, $96, $80
  2137 00:21A1: 05 F5 E1 00          .DB  $05, $F5, $E1, $00
  2138 00:21A5: 3B 9A CA 00          .DB  $3B, $9A, $CA, $00                 ;HEX weight of most significant BCD digit
  2139                        ;
  2140                        ; Data variables used
  2141                        ;
  2142 00:21A9: 10           ROWS    .DB     #$10                            ;Default to 16 rows of displayed data
  2143                        ;
  2144                        ; LBA word count variables
  2145                        ;
  2146 00:21AA: 00 00        LBA_LOW_WORD    .DW     $0000                   ;Low word for LBA count
  2147 00:21AC: 00 00        LBA_HIGH_WORD   .DW     $0000                   ;High word for LBA count
  2148                        ;
  2149                        ; MicroDrive Error codes
  2150                        ;       These are the error codes per the Hitachi MicroDrive documentation.
  2151                        ;       The codes are read after an error is returned from a command
  2152                        ;       by executing an IDE Get Status command from BIOS.
  2153                        ;
  2154                        ;The X register will contaim the error code as detailed below:
  2155                        ;
  2156                        ; Error Register:
  2157                        ;Bit 7 - CRC Error or Bad Block error
  2158                        ;Bit 6 - Uncorrectable Data Error
  2159                        ;Bit 5 - 0 (not used) MC (used for Removable-Media drives)
  2160                        ;Bit 4 - ID Not Found
  2161                        ;Bit 3 - 0 (not used) MCR (used for Removable-Media drives)
  2162                        ;Bit 2 - Aborted Command error
  2163                        ;Bit 1 - Track Zero not found error
  2164                        ;Bit 0 - Data Address Mark Not Found
  2165                        ;
  2166                        ; The codes are indexed here and as they are received, the appropriate
  2167                        ; error message will be displayed.
  2168                        ;
  2169                        IDE_ERROR_CODES
  Thu Mar 16 2023 11:47                                                                                                    Page 58


  2170                        ;
  2171 00:21AE: 80                   .DB     %10000000                       ;CRC or Bad Block
  2172 00:21AF: 40                   .DB     %01000000                       ;Uncorrectable Data Error
  2173 00:21B0: 10                   .DB     %00010000                       ;ID Not Found
  2174 00:21B1: 04                   .DB     %00000100                       ;Aborted Command
  2175 00:21B2: 02                   .DB     %00000010                       ;Track Zero not found
  2176 00:21B3: 01                   .DB     %00000001                       ;Data Address Mark not found
  2177                        ;
  2178                        ; IDE Error handler addresses
  2179                        ;       These are the addresses for the error messages.
  2180                        ;       These are indexed as above, so once the error message is matched
  2181                        ;       above, the index is multiplied by two and the address is used for the
  2182                        ;       error message text string.
  2183                        ;
  2184                        IDE_ERROR_ADDRESS
  2185                        ;
  2186 00:21B4: C0 21                .DW     IDE_ERROR_00                    ;CRC or Bad Block
  2187 00:21B6: D7 21                .DW     IDE_ERROR_01                    ;Uncorrectable Data Error
  2188 00:21B8: F0 21                .DW     IDE_ERROR_02                    ;ID Not Found
  2189 00:21BA: 03 22                .DW     IDE_ERROR_03                    ;Aborted Command
  2190 00:21BC: 13 22                .DW     IDE_ERROR_04                    ;Track Zero not found
  2191 00:21BE: 28 22                .DW     IDE_ERROR_05                    ;Data Address Mark not found
  2192                        ;
  2193                        ; Error messages are here:
  2194                        ;
  2195                        IDE_ERROR_00
  2196 00:21C0: 43 52 43 20          .DB     "CRC or Bad Block Error"
       00:21C4: 6F 72 20 42 
       00:21C8: 61 64 20 42 
       00:21CC: 6C 6F 63 6B 
       00:21D0: 20 45 72 72 
       00:21D4: 6F 72 
  2197 00:21D6: 00                   .DB     $00
  2198                        ;
  2199                        IDE_ERROR_01
  2200 00:21D7: 55 6E 63 6F          .DB     "Uncorrectable Data Error"
       00:21DB: 72 72 65 63 
       00:21DF: 74 61 62 6C 
       00:21E3: 65 20 44 61 
       00:21E7: 74 61 20 45 
       00:21EB: 72 72 6F 72 
  2201 00:21EF: 00                   .DB     $00
  2202                        ;
  2203                        IDE_ERROR_02
  2204 00:21F0: 42 6C 6F 63          .DB     "Block ID Not Found"
       00:21F4: 6B 20 49 44 
       00:21F8: 20 4E 6F 74 
       00:21FC: 20 46 6F 75 
       00:2200: 6E 64 
  2205 00:2202: 00                   .DB     $00
  2206                        ;
  2207                        IDE_ERROR_03
  2208 00:2203: 41 62 6F 72          .DB     "Aborted Command"
       00:2207: 74 65 64 20 
       00:220B: 43 6F 6D 6D 
       00:220F: 61 6E 64 
  2209 00:2212: 00                   .DB     $00
  2210                        ;
  2211                        IDE_ERROR_04
  2212 00:2213: 54 72 61 63          .DB     "Track Zero not Found"
       00:2217: 6B 20 5A 65 
       00:221B: 72 6F 20 6E 
       00:221F: 6F 74 20 46 
  Thu Mar 16 2023 11:47                                                                                                    Page 59


       00:2223: 6F 75 6E 64 
  2213 00:2227: 00                   .DB     $00
  2214                        ;
  2215                        IDE_ERROR_05
  2216 00:2228: 44 61 74 61          .DB     "Data Address Mark not found"
       00:222C: 20 41 64 64 
       00:2230: 72 65 73 73 
       00:2234: 20 4D 61 72 
       00:2238: 6B 20 6E 6F 
       00:223C: 74 20 66 6F 
       00:2240: 75 6E 64 
  2217 00:2243: 00                   .DB     $00
  2218                        ;
  2219                        IDE_ERROR_06
  2220 00:2244: 55 6E 6B 6E          .DB     "Unknown Error"
       00:2248: 6F 77 6E 20 
       00:224C: 45 72 72 6F 
       00:2250: 72 
  2221 00:2251: 00                   .DB     $00
  2222                        ;
  2223                                .ORG    $/256*256+256                   ;Benchmark Buffer (start on page boundary)
  2224                        BENCH_BUFFER
  2225                        ;
  2226                                .END


      Lines assembled: 2642
      Errors: 0
