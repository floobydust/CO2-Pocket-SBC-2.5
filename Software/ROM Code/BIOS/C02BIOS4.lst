  Mon Apr  3 2023 13:43                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C02 Macro Assembler    **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;**************************************************************************************************
     2                        ;*    C02BIOS 4.02 - Release version for Pocket SBC  (c)2013-2023 by Kevin E. Maier 03/04/2023    *
     3                        ;*                                                                                                *
     4                        ;* BIOS Version 4.02 supports the following 3.3V hardware specification:                          *
     5                        ;*                                                                                                *
     6                        ;*  - W65C02S with clock rate up to 8.0 MHz                                                       *
     7                        ;*  - AS6C66256 32KB Static RAM                                                                   *
     8                        ;*  - AT28BV256 32KB EEPROM ROM                                                                   *
     9                        ;*  - ATF22LV10C Single Glue Logic                                                                *
    10                        ;*  - NXP SC28L92 DUART for Console Port / Aux Serial Port / Timer                                *
    11                        ;*  - TL7533 Reset Circuit (positive & negative Reset signals)                                    *
    12                        ;*  - DS1233A Reset Circuit for NMI Panic Trigger                                                 *
    13                        ;*                                                                                                *
    14                        ;* Hardware map is flexible via Glue logic                                                        *
    15                        ;*  - 5 I/O selects @ 32-bytes wide             $FE00 - $FE9F                                     *
    16                        ;*  - 1 I/O select used by SC28L92 DUART        $FE80 - $FE9F                                     *
    17                        ;*  - 4 I/O selects available on expansion bus  $FE00 - $FE7F                                     *
    18                        ;*                                                                                                *
    19                        ;* Additional Hardware support:                                                                   *
    20                        ;* - Modified CF-Card/RTC adapter card                                                            *
    21                        ;*  - ATF16LV8C Glue Logic used for I/O decoding and Latch Selection                              *
    22                        ;*  - MicroDrive IDE PATA interface                                                               *
    23                        ;*    - 16-bit upper latch for data read/write                                                    *
    24                        ;*  - DS15x1W Realtime Clock/Calendar                                                             *
    25                        ;*                                                                                                *
    26                        ;* BIOS Functions are divided into groups as follows:                                             *
    27                        ;*                                                                                                *
    28                        ;* SC28L92 DUART functions:                                                                       *
    29                        ;* - Full duplex interrupt-driven/buffered I/O for both DUART Channels                            *
    30                        ;* - Precision timer services with 10ms accuracy                                                  *
    31                        ;* - RTC based Jiffy Clock, Sec, Min, Hour, Date                                                  *
    32                        ;* - Accurate delays from 10ms to ~46 hours                                                       *
    33                        ;* - 10ms Benchmark Timing to 65535.99 seconds                                                    *
    34                        ;*                                                                                                *
    35                        ;* IDE Controller Functions supporting PATA 16-bit Data Transfers:                                *
    36                        ;* - Multiple Block transfers are now supported for Read/Write/Verify Block commands              *
    37                        ;* - Reset IDE (recalibrate command)                                                              *
    38                        ;* - Get IDE Status and Extended Error codes                                                      *
    39                        ;* - Get IDE Identification Block                                                                 *
    40                        ;* - Read a Block from IDE device                                                                 *
    41                        ;* - Write a Block to IDE device                                                                  *
    42                        ;* - Verify the last Block from IDE device                                                        *
    43                        ;* - Set the LBA Block ID for Read/Write/Verify                                                   *
    44                        ;* - Set the Memory Address to transfer Block data to/from                                        *
    45                        ;* - Enable the Write Cache on IDE controller                                                     *
    46                        ;* - Disable the Write Cache on IDE controller                                                    *
    47                        ;*                                                                                                *
    48                        ;* Maxim Realtime Clock functions:                                                                *
    49                        ;* - Detect RTC (signature in NVRAM) and Load software RTC variables                              *
    50                        ;* - Read and Write NVRAM block                                                                   *
    51                        ;*                                                                                                *
    52                        ;* BIOS Features:                                                                                 *
    53                        ;* - Extendable BIOS structure with soft vectors                                                  *
    54                        ;* - Soft config parameters for I/O devices                                                       *
    55                        ;* - Monitor cold/warm start soft vectored                                                        *
    56                        ;* - Panic Routine to restore Vectors and Reinitialize Console                                    *
    57                        ;* - Fully relocatable code (sans page $FF)                                                       *
  Mon Apr  3 2023 13:43                                                                                                    Page 2


    58                        ;* - JUMP Table at $FF00 - 32 functions                                                           *
    59                        ;* - Default memory allocation of 2KB (includes 160 bytes of I/O mapping)                         *
    60                        ;**************************************************************************************************
    61                                PL      66      ;Page Length
    62                                PW      132     ;Page Width (# of char/line)
    63                                CHIP    W65C02S ;Enable WDC 65C02 instructions
    64                                PASS1   OFF     ;Set ON when used for debug
    65                                INCLIST ON      ;Set ON for listing Include files
    66                        ;**************************************************************************************************
    67                        ;
    68                        ; C02BIOS Version 4.0x is based on C02BIOS Version 3.04.
    69                        ;
    70                        ; - Main changes are to support the NXP SC28L92 DUART.
    71                        ; - Minor changes to Page Zero to include required pointers, etc. for the second serial port.
    72                        ; - IDE support now focused on IBM/Hitachi Microdrive with 35-pin PATA interface.
    73                        ; - Removal of Compact Flash specific code, as no longer required for standard IDE.
    74                        ; - Minor change for testing IDE busy, no more JSR, integrated test into each routine.
    75                        ;
    76                        ;**************************************************************************************************
    77                        ;
    78                        ; This BIOS and Monitor version also use a common source file for constants and variables used by
    79                        ; both. This just simplifies keeping both code pieces in sync.
    80                        ;
    81                                INCLUDE         C02Constants4.asm
     1                        ;**************************************************************************************************
     2                        ;*                                                                                                *
     3                        ;*              C02 Constants used for the 4.0x releases of C02BIOS4 and C02Monitor4              *
     4                        ;*                                                                                                *
     5                        ;*                                                                                                *
     6                        ;*                                  15/02/2023 (Day/Month/Year)                                   *
     7                        ;*                                                                                                *
     8                        ;**************************************************************************************************
     9                        ; C02BIOS / C02Monitor Version is now at 4.02                                                     *
    10                        ; - All Constants and Variables are now defined in a single source file (this one) for assembling *
    11                        ; - both the C02BIOS4 and the C02Monitor4. It is also used for the Template for writing code to   *
    12                        ; - be used for the C02 Pocket SBC and Adapters.                                                  *
    13                        ;                                                                                                 *
    14                        ; - Be sure to include this file at the start of any source file that needs it.                   *
    15                        ;                                                                                                 *
    16                        ;**************************************************************************************************
    17                        ;                                                                                                 *
    18                        ;          - Page Zero locations $00 to $9F (160 bytes) reserved for user applications            * 
    19                        ;                                                                                                 *
    20                        ;**************************************************************************************************
    21                        ;
    22             000000A0   PGZERO_ST       .EQU    $A0                     ;Start of Monitor Page 0 use ($A0-$CF, 48 bytes)
    23                        ;
    24             000000A0   BUFF_PG0        .EQU    PGZERO_ST+00            ;Default Page zero location for Monitor buffers
    25                        ;
    26             000000A0   INBUFF          .EQU    BUFF_PG0+00             ;Input Buffer - 4 bytes ($A0-$A3)
    27             000000A4   DATABUFF        .EQU    BUFF_PG0+04             ;Data Buffer - 6 bytes ($A4-$A9)
    28                        ;
    29                        ;       - 16-bit variables:
    30             000000AA   HEXDATAH        .EQU    PGZERO_ST+10            ;Hexadecimal input
    31             000000AB   HEXDATAL        .EQU    PGZERO_ST+11
    32             000000AC   BINVALL         .EQU    PGZERO_ST+12            ;Binary Value for HEX2ASC
    33             000000AD   BINVALH         .EQU    PGZERO_ST+13
    34             000000AE   COMLO           .EQU    PGZERO_ST+14            ;User command address
    35             000000AF   COMHI           .EQU    PGZERO_ST+15
    36             000000B0   INDEXL          .EQU    PGZERO_ST+16            ;Index for address - multiple routines
    37             000000B1   INDEXH          .EQU    PGZERO_ST+17
    38             000000B2   TEMP1L          .EQU    PGZERO_ST+18            ;Index for word temp value used by Memdump
    39             000000B3   TEMP1H          .EQU    PGZERO_ST+19
  Mon Apr  3 2023 13:43                                                                                                    Page 3


    40             000000B4   TEMP2L          .EQU    PGZERO_ST+20            ;Index for Text entry
    41             000000B5   TEMP2H          .EQU    PGZERO_ST+21
    42             000000B6   PROMPTL         .EQU    PGZERO_ST+22            ;Prompt string address
    43             000000B7   PROMPTH         .EQU    PGZERO_ST+23
    44             000000B8   SRCL            .EQU    PGZERO_ST+24            ;Source address for memory operations
    45             000000B9   SRCH            .EQU    PGZERO_ST+25
    46             000000BA   TGTL            .EQU    PGZERO_ST+26            ;Target address for memory operations
    47             000000BB   TGTH            .EQU    PGZERO_ST+27
    48             000000BC   LENL            .EQU    PGZERO_ST+28            ;Length address for memory operations
    49             000000BD   LENH            .EQU    PGZERO_ST+29
    50                        ;
    51                        ;       - 8-bit variables and constants:
    52             000000BE   BUFIDX          .EQU    PGZERO_ST+30            ;Buffer index
    53             000000BF   BUFLEN          .EQU    PGZERO_ST+31            ;Buffer length
    54             000000C0   IDX             .EQU    PGZERO_ST+32            ;Temp Indexing
    55             000000C1   IDY             .EQU    PGZERO_ST+33            ;Temp Indexing
    56             000000C2   TEMP1           .EQU    PGZERO_ST+34            ;Temp - Code Conversion routines
    57             000000C3   TEMP2           .EQU    PGZERO_ST+35            ;Temp - Memory/EEPROM/SREC routines - Disassembler
    58             000000C4   TEMP3           .EQU    PGZERO_ST+36            ;Temp - EEPROM/SREC routines
    59             000000C5   CMDFLAG         .EQU    PGZERO_ST+37            ;Command Flag, bit specific, used by many routines
    60             000000C6   OPXMDM          .EQU    PGZERO_ST+38            ;Saved Opcode/Xmodem Flag variable
    61                        ;
    62                        ;       - Xmodem transfer variables
    63             000000C7   CRCHI           .EQU    PGZERO_ST+39            ;CRC hi byte  (two byte variable)
    64             000000C8   CRCLO           .EQU    PGZERO_ST+40            ;CRC lo byte - Operand in Disassembler
    65             000000C9   CRCCNT          .EQU    PGZERO_ST+41            ;CRC retry count - Operand in Disassembler
    66             000000CA   PTRL            .EQU    PGZERO_ST+42            ;Data pointer lo byte - Mnemonic in Disassembler
    67             000000CB   PTRH            .EQU    PGZERO_ST+43            ;Data pointer hi byte - Mnemonic in Disassembler
    68             000000CC   BLKNO           .EQU    PGZERO_ST+44            ;Block number
    69                        ;
    70                        ;        - Macro Loop Counter variables
    71             000000CD   LPCNTL          .EQU    PGZERO_ST+45            ;Loop Count low byte
    72             000000CE   LPCNTH          .EQU    PGZERO_ST+46            ;Loop Count high byte
    73                        ;
    74                        ;       - Spare Monitor byte for future use
    75             000000CF   SPARE_M0        .EQU    PGZERO_ST+47            ;Spare Monitor page zero byte
    76                        ;
    77                        ;       - BIOS variables, pointers, flags located at top of Page Zero
    78             000000D0   BIOS_PG0        .EQU    PGZERO_ST+48            ;Start of BIOS page 0 use ($D0-$FF, 48 bytes)
    79                        ;
    80                        ;       - BRK handler routine
    81             000000D0   PCL             .EQU    BIOS_PG0+00             ;Program Counter Low index
    82             000000D1   PCH             .EQU    BIOS_PG0+01             ;Program Counter High index
    83             000000D2   PREG            .EQU    BIOS_PG0+02             ;Temp Status Reg
    84             000000D3   SREG            .EQU    BIOS_PG0+03             ;Temp Stack ptr
    85             000000D4   YREG            .EQU    BIOS_PG0+04             ;Temp Y Reg
    86             000000D5   XREG            .EQU    BIOS_PG0+05             ;Temp X Reg
    87             000000D6   AREG            .EQU    BIOS_PG0+06             ;Temp A Reg
    88                        ;
    89                        ;       - 28L92 IRQ handler pointers and status
    90             000000D7   ICNT_A          .EQU    BIOS_PG0+07             ;Input buffer count
    91             000000D8   IHEAD_A         .EQU    BIOS_PG0+08             ;Input buffer head pointer
    92             000000D9   ITAIL_A         .EQU    BIOS_PG0+09             ;Input buffer tail pointer
    93             000000DA   OCNT_A          .EQU    BIOS_PG0+10             ;Output buffer count
    94             000000DB   OHEAD_A         .EQU    BIOS_PG0+11             ;Output buffer head pointer
    95             000000DC   OTAIL_A         .EQU    BIOS_PG0+12             ;Output buffer tail pointer
    96                        ;
    97             000000DD   ICNT_B          .EQU    BIOS_PG0+13             ;Input buffer count
    98             000000DE   IHEAD_B         .EQU    BIOS_PG0+14             ;Input buffer head pointer
    99             000000DF   ITAIL_B         .EQU    BIOS_PG0+15             ;Input buffer tail pointer
   100             000000E0   OCNT_B          .EQU    BIOS_PG0+16             ;Output buffer count
   101             000000E1   OHEAD_B         .EQU    BIOS_PG0+17             ;Output buffer head pointer
   102             000000E2   OTAIL_B         .EQU    BIOS_PG0+18             ;Output buffer tail pointer
  Mon Apr  3 2023 13:43                                                                                                    Page 4


   103             000000E3   UART_IRT        .EQU    BIOS_PG0+19             ;SC28L92 Interrupt Status byte
   104                        ;
   105                        ;       - Real-Time Clock variables
   106                        ; These are repurposed for adding a Realtime clock chip (DS1501/DS1511)
   107                        ; The Ticks, Seconds, Minutes and Hours remain the same in function.
   108                        ; The 16-bit Days variable is replaced however.
   109                        ; - The DAY_DATE is a new variable. To minimize Page Zero usage, it has two functions
   110                        ;       Bits 0-4 represent the days of the Month 1-31
   111                        ;       Bits 5-7 represent the Day of the Week, 1-7 (Saturday=1)
   112                        ; The Months are handled by the upper 4 bits of the MONTH_YEAR variable
   113                        ; The Century is handled by a the Year (0-255) and the lower 4 bits of the MONTH_YEAR variable
   114                        ;
   115             000000E4   TICKS           .EQU    BIOS_PG0+20             ;Number of timer countdowns = 1 second (100)
   116             000000E5   SECS            .EQU    BIOS_PG0+21             ;Seconds: 0-59
   117             000000E6   MINS            .EQU    BIOS_PG0+22             ;Minutes: 0-59
   118             000000E7   HOURS           .EQU    BIOS_PG0+23             ;Hours: 0-23
   119             000000E8   DAY_DATE        .EQU    BIOS_PG0+24             ;Day: (bits 5-7) Date: (bits 0-4)
   120             000000E9   MONTH_CENTURY   .EQU    BIOS_PG0+25             ;Month: (bits 4-7) Century: (bits 0-3)
   121             000000EA   YEAR            .EQU    BIOS_PG0+26             ;Century 0-255 plus 4 bits as noted above
   122             000000EB   RTC_TEMP        .EQU    BIOS_PG0+27             ;Temp work byte for updating shared variables
   123                        ;
   124                        ;       - Delay Timer variables
   125             000000EC   MSDELAY         .EQU    BIOS_PG0+28             ;Timer delay countdown byte (255 > 0)
   126             000000ED   SETMS           .EQU    BIOS_PG0+29             ;Set timeout for delay routines - BIOS use only
   127             000000EE   DELLO           .EQU    BIOS_PG0+30             ;Delay value BIOS use only
   128             000000EF   DELHI           .EQU    BIOS_PG0+31             ;Delay value BIOS use only
   129                        ;
   130                        ;       - Count variables for 10ms benchmark timing
   131             000000F0   MS10_CNT        .EQU    BIOS_PG0+32             ;10ms Count variable
   132             000000F1   SECL_CNT        .EQU    BIOS_PG0+33             ;Seconds Low byte count
   133             000000F2   SECH_CNT        .EQU    BIOS_PG0+34             ;Seconds High byte count
   134                        ;
   135                        ;       - Address and pointers for IDE Interface
   136             000000F3   LBA_ADDR_LOW    .EQU    BIOS_PG0+35             ;LBA Transfer Address low byte
   137             000000F4   LBA_ADDR_HIGH   .EQU    BIOS_PG0+36             ;LBA Transfer Address high byte
   138                        ;
   139             000000F5   LBA_XFER_CNT    .EQU    BIOS_PG0+37             ;LBA Transfer Count 1-xx (check RAM space!)
   140             000000F6   LBA_LOW_BYTE    .EQU    BIOS_PG0+38             ;LBA Block number bits 0-7
   141             000000F7   LBA_HIGH_BYTE   .EQU    BIOS_PG0+39             ;LBA Block number bits 8-15
   142             000000F8   LBA_EXT_BYTE    .EQU    BIOS_PG0+40             ;LBA Block number bits 16-23
   143                        ;
   144             000000F9   BIOS_XFERL      .EQU    BIOS_PG0+41             ;BIOS Move Routine low byte
   145             000000FA   BIOS_XFERH      .EQU    BIOS_PG0+42             ;BIOS Move Routine high byte
   146             000000FB   BIOS_XFERC      .EQU    BIOS_PG0+43             ;BIOS Block Count moved (needs to be set)
   147                        ;
   148             000000FC   IDE_STATUS_RAM  .EQU    BIOS_PG0+44             ;IDE RAM-Based Status
   149                        ;
   150             000000FD   SPARE_B0        .EQU    BIOS_PG0+45             ;Spare byte 0
   151             000000FE   SPARE_B1        .EQU    BIOS_PG0+46             ;Spare byte 1
   152                        ;
   153                        ;       - Timer/Counter Match flag for Delay/Benchmark
   154             000000FF   MATCH           .EQU    BIOS_PG0+47             ;Bit7 used for Delay, Bit6 used for Benchmark
   155                                                                        ;Bits 3,2,1 used for IDE Interrupt Handler
   156                        ;
   157                        ;       - Default for RTC tick count - number of IRQs for 1 second
   158             00000064   DF_TICKS        .EQU    100                     ;Timer is 10 milliseconds (100 x 10ms = 1 second)
   159                        ;
   160                        ;**************************************************************************************************
   161             00000200   IBUF_A          .EQU    $0200                   ;Console Input Buffer - 128 bytes
   162             00000280   OBUF_A          .EQU    $0280                   ;Console Output Buffer - 128 bytes
   163                        ;
   164             00000400   IBUF_B          .EQU    $0400                   ;Alternate Input Buffer - 128 bytes
   165             00000480   OBUF_B          .EQU    $0480                   ;Alternate Output Buffer - 128 bytes
  Mon Apr  3 2023 13:43                                                                                                    Page 5


   166                        ;**************************************************************************************************
   167             00000300   SOFTVEC         .EQU    $0300                   ;Start of soft vectors
   168                        ;The Interrupt structure is vector based. During startup, Page $03 is loaded from ROM.
   169                        ; The soft vectors are structured to allow inserting additional routines either before
   170                        ; or after the ROM based routines. This allows flexibility and changing of routine priority.
   171                        ;
   172                        ;The main set of vectors occupy the first 16 bytes of Page $03. The ROM handler for
   173                        ; NMI, BRK and IRQ jump to the first 3 vectors. The following 3 vectors are loaded with
   174                        ; return addresses to the ROM handler for each. The following 2 vectors are the cold and
   175                        ; warm entry points for the Monitor. After the basic initialization, the monitor is entered.
   176                        ;
   177                        ;The following vector set allows inserts, pre or post for NMI/BRK/IRQ. There a total of 8 inserts
   178                        ; which occupy 16 bytes. They can be used as required.
   179                        ; Currently, VECINSRT0 will be used if an IDE Controller is detected.
   180                        ;
   181             00000300   NMIVEC0         .EQU    SOFTVEC+00              ;NMI Vector Entry 0
   182             00000302   BRKVEC0         .EQU    SOFTVEC+02              ;BRK Vector Entry 0
   183             00000304   IRQVEC0         .EQU    SOFTVEC+04              ;IRQ Vector Entry 0
   184                        ;
   185             00000306   NMIRTVEC0       .EQU    SOFTVEC+06              ;NMI Vector Return 0
   186             00000308   BRKRTVEC0       .EQU    SOFTVEC+08              ;BRK Vector Return 0
   187             0000030A   IRQRTVEC0       .EQU    SOFTVEC+10              ;IRQ Vector Return 0
   188                        ;
   189             0000030C   CLDMNVEC0       .EQU    SOFTVEC+12              ;Monitor Cold Entry Vector 0
   190             0000030E   WRMMNVEC0       .EQU    SOFTVEC+14              ;Monitor Warm Entry Vector 0
   191                        ;
   192             00000310   VECINSRT0       .EQU    SOFTVEC+16              ;1st Vector Insert
   193             00000312   VECINSRT1       .EQU    SOFTVEC+18              ;2nd Vector Insert
   194             00000314   VECINSRT2       .EQU    SOFTVEC+20              ;3rd Vector Insert
   195             00000316   VECINSRT3       .EQU    SOFTVEC+22              ;4th Vector Insert
   196             00000318   VECINSRT4       .EQU    SOFTVEC+24              ;5th Vector Insert
   197             0000031A   VECINSRT5       .EQU    SOFTVEC+26              ;6th Vector Insert
   198             0000031C   VECINSRT6       .EQU    SOFTVEC+28              ;7th Vector Insert
   199             0000031E   VECINSRT7       .EQU    SOFTVEC+30              ;8th Vector Insert
   200                        ;
   201                        ;**************************************************************************************************
   202                        ;
   203                        ;Soft Config values below are loaded from ROM and are the default I/O setup Configuration data that
   204                        ; the INIT_x routines use. As a result, you can write a routine to change the I/O Configuration
   205                        ; data and use the standard ROM routines to initialize the I/O without restarting or changing ROM
   206                        ; A Reset (HW or coded) will reinitialize the I/O with the ROM default I/O Configuration.
   207                        ;
   208                        ;There are a total of 32 Bytes Configuration data reserved starting at $0320,
   209                        ; - 22 bytes are reserved for the NXP SC28L92 DUART.
   210                        ;
   211             00000320   SOFTCFG         .EQU    SOFTVEC+32              ;Start of hardware Config parameters
   212                        ;
   213             00000320   LOAD_28L92      .EQU    SOFTCFG+00              ;SC28L92 Soft Config Data
   214                        ;
   215                        ; The configuration for the DUART consists of 14 parameters/commands stored in the following
   216                        ; - memory locations. Note that these are sent in reverse, i.e., $32E thru $320.
   217                        ;
   218                        ;       $320    .DB     %00000011       $03     ;Enable OP0/1 for RTS control Port A/B
   219                        ;       $321    .DB     %00001010       $A0     ;Disable Receiver/Disable Transmitter B
   220                        ;       $322    .DB     %00001001       $09     ;Enable Receiver/Disable Transmitter A
   221                        ;       $323    .DB     %00001111       $0F     ;Interrupt Mask Register setup
   222                        ;       $324    .DB     %11100000       $E0     ;Aux Register setup for Counter/Timer
   223                        ;       $325    .DB     %01001000       $48     ;Counter/Timer Upper Preset (18432 decimal)
   224                        ;       $326    .DB     %00000000       $00     ;Counter/Timer Lower Preset
   225                        ;       $327    .DB     %11001100       $CC     ;Baud Rate clock for B Rcv/Xmt - 115.2K
   226                        ;       $328    .DB     %11001100       $CC     ;Baud Rate clock for A Rcv/Xmt - 115.2K
   227                        ;       $329    .DB     %00110000       $30     ;Reset Transmitter B
   228                        ;       $32A    .DB     %00100000       $20     ;Reset Receiver B
  Mon Apr  3 2023 13:43                                                                                                    Page 6


   229                        ;       $32B    .DB     %00110000       $30     ;Reset Transmitter A
   230                        ;       $32C    .DB     %00100000       $20     ;Reset Receiver A
   231                        ;       $32D    .DB     %00000000       $00     ;Interrupt Mask Register setup (clear)
   232                        ;       $32E    .DB     %11110000       $F0     ;Command Register A - Disable Power Down
   233                        ;       $32F    .DB     %11111111       $FF     ;Spare Byte
   234                        ;
   235                        ; The MR registers of the DUART also have soft config data loaded here, but is separate from the
   236                        ; - main register config data, as these are all accessed via a single I/O port (auto-indexed).
   237                        ; - These are also sent in reverse order as above.
   238                        ;
   239                        ;       $330    .DB     %00010111       $17     ;Mode Register 2 data
   240                        ;       $331    .DB     %11010011       $D3     ;Mode Register 1 Data
   241                        ;       $332    .DB     %11111001       $F9     ;Mode Register 0 Data
   242                        ;
   243                        ;       $333    .DB     %00010111       $17     ;Mode Register 2 data
   244                        ;       $334    .DB     %11010011       $D3     ;Mode Register 1 Data
   245                        ;       $335    .DB     %11000001       $C1     ;Mode Register 0 Data
   246                        ;
   247                        ;       10 additional bytes all reserved as $FF fill up the remaining soft configuration data.
   248                        ;
   249                        ; The Microdrive is initialized and the total LBA count is save here during startup.
   250                        ;  It is used by various utilities and allows drive capacity sensing without sending additional
   251                        ;  commands to the Microdrive. A total of 4 bytes are used for a 32-bit LBA count. These are saved
   252                        ;  at addresses $33C - $33F. Order is low-word/high-word. Each word is low-byte/high/byte.
   253                        ;
   254             0000033C   LOAD_IDE        .EQU    SOFTCFG+28              ;IDE/CF-Card Soft Config Data
   255                        ;
   256                        ;       $33C    .DW                             ;Low order LBA count
   257                        ;       $33E    .DW                             ;High order LBA count
   258                        ;
   259                        ;Search Buffer is 16 bytes in length. Used to hold search string for text or hex data
   260             00000340   SRCHBUFF        .EQU    SOFTCFG+32              ;Located in Page $03 following Hardware Config data
   261                        ;       $340                                    ;Start of search buffer (16 bytes)
   262                        ;
   263                        ;Xmodem/CRC Loader also provides Motorola S19 Record sense and load. Designed to handle the S19
   264                        ; records from the WDC Assembler/Linker package. This requires a 44 byte buffer to parse each valid
   265                        ; S1 record, located just before the 132 Byte Xmodem frame buffer. Total Buffer space for the
   266                        ; Xmodem/CRC Loader is 176 bytes
   267                        ;
   268                        ;Valid S-record headers are "S1" and "S9". For S1, the maximum length is "$19" hex. The last S1
   269                        ; record can be less. S9 record is always the last record with no data. WDC Linker also appends
   270                        ; a CR/LF to the end of each record for a total of 44 bytes.
   271                        ;
   272             00000350   SRBUFF          .EQU    SOFTCFG+48              ;S-Record buffer, up to 44 bytes in length
   273                        ;       $350                                    ;Start of S-Record buffer
   274                        ;
   275                        ;Xmodem frame buffer. The entire Xmodem frame is buffered here and then checked for proper header
   276                        ; and frame number, CRC-16 on the data, then moved to user RAM.
   277             0000037C   RBUFF           .EQU    SOFTCFG+92              ;Xmodem temp 132 byte receive buffer
   278                        ;       $37C                                    ;Start of Receive buffer for Xmodem
   279                        ;
   280                        ;Page $03 is completely allocated for Buffers, Config Data and Vector pointers.
   281                        ; Some of the buffer space can be used as needed, provided any required Monitor functions are NOT
   282                        ; being used concurrently.
   283                        ;
   284                        ;**************************************************************************************************
   285                        ;
   286                        ;Page $05 is used for the Realtime Clock NVRAM read and write routines
   287             00000500   NVRAM_DATA      .EQU    $0500                   ;NVRAM Data Buffer address
   288                        ;
   289                        ;**************************************************************************************************
   290                        ;
   291                        ;Pages $06 - $07 are used for the IDE device Block Buffer (512 bytes)
  Mon Apr  3 2023 13:43                                                                                                    Page 7


   292             00000600   LBA_BUFFER      .EQU    $0600                   ;Default IDE Block Buffer address
   293             00000800   BOOT_BUFFER     .EQU    $0800                   ;Default IDE Boot Buffer address
   294                        ; 
   295                        ;**************************************************************************************************
   296                        ;XMODEM Control Character Constants
   297             00000001   SOH             .EQU    $01                     ;Start of Block Header
   298             00000004   EOT             .EQU    $04                     ;End of Text marker
   299             00000006   ACK             .EQU    $06                     ;Good Block Acknowledge
   300             00000015   NAK             .EQU    $15                     ;Bad Block Acknowledged
   301             00000018   CAN             .EQU    $18                     ;Cancel character
   302                        ;
   303                        ;**************************************************************************************************
   304                        ;RAM location used for the EEPROM Byte Write routine
   305                        ; EEPROM is the address offset of the AT28BV256 in the hardware memory map and added to the
   306                        ; EEPROM address locations required to unlock the AT28BV256 for insitu programming. For more
   307                        ; information, refer to the AT28BV256 Datasheet.
   308                        ;
   309             00000070   BURN_BYTE       .EQU    $0070                   ;Page 0 RAM for EEPROM BYTE write routine
   310             00008000   EEPROM          .EQU    $8000                   ;Offset to EEPROM in hardware
   311                        ;**************************************************************************************************
   312                        ;DOS/65 can be called from the Monitor via the Ctrl-B command.
   313                        ;The start location is just added here for convenience, but should be changed if needed.
   314                        ;
   315             0000D630   DOS_65          .EQU    $D630                   ;Default location to Boot DOS/65 (optional)
   316                        ;**************************************************************************************************
   317             0000FE00   IOPAGE          .EQU    $FE00                   ;I/O Page Base Start Address
   318                        ;**************************************************************************************************
   319             0000FE80   SC28L92_BASE    .EQU    IOPAGE+$80              ;Beginning of Console UART address
   320                        ;
   321             0000FE80   UART_MODEREG_A  .EQU    SC28L92_BASE+$00        ;MR0/MR1/MR2 Port A sequential (Read/Write)
   322             0000FE81   UART_STATUS_A   .EQU    SC28L92_BASE+$01        ;UART Status Register Port A (READ)
   323             0000FE81   UART_CLKSEL_A   .EQU    SC28L92_BASE+$01        ;UART Clock Select Port A (WRITE)
   324             0000FE82   UART_RES_A      .EQU    SC28L92_BASE+$02        ;UART Reserved Port A (READ)
   325             0000FE82   UART_COMMAND_A  .EQU    SC28L92_BASE+$02        ;UART Command Register Port A (WRITE)
   326             0000FE83   UART_RECEIVE_A  .EQU    SC28L92_BASE+$03        ;UART Receive Register Port A (READ)
   327             0000FE83   UART_TRANSMIT_A .EQU    SC28L92_BASE+$03        ;UART Transmit Register Port A (WRITE)
   328                        ;
   329             0000FE84   UART_PORT_CHG   .EQU    SC28L92_BASE+$04        ;UART Input Port Change Register (READ)
   330             0000FE84   UART_AUXCR      .EQU    SC28L92_BASE+$04        ;UART Aux Command Register (WRITE)
   331             0000FE85   UART_ISR        .EQU    SC28L92_BASE+$05        ;UART Interrupt Status Register (READ)
   332             0000FE85   UART_IMR        .EQU    SC28L92_BASE+$05        ;UART Interrupt Mask Register (WRITE)
   333                        ;
   334             0000FE86   UART_CNTU       .EQU    SC28L92_BASE+$06        ;Counter/Timer Upper Register (READ)
   335             0000FE86   UART_CNTUP      .EQU    SC28L92_BASE+$06        ;Counter/Timer Upper Preset Register (WRITE)
   336             0000FE87   UART_CNTL       .EQU    SC28L92_BASE+$07        ;Counter/Timer Lower Register (READ)
   337             0000FE87   UART_CNTLP      .EQU    SC28L92_BASE+$07        ;Counter/Timer Lower Preset Register (WRITE)
   338                        ;
   339             0000FE88   UART_MODEREG_B  .EQU    SC28L92_BASE+$08        ;MR0/MR1/MR2 Port B sequential Read/Write
   340             0000FE89   UART_STATUS_B   .EQU    SC28L92_BASE+$09        ;UART Status Register Port B (READ)
   341             0000FE89   UART_CLKSEL_B   .EQU    SC28L92_BASE+$09        ;UART Clock Select Port B (WRITE)
   342             0000FE8A   UART_RES_B      .EQU    SC28L92_BASE+$0A        ;UART Reserved Port B (READ)
   343             0000FE8A   UART_COMMAND_B  .EQU    SC28L92_BASE+$0A        ;UART Command Register Port B (WRITE)
   344             0000FE8B   UART_RECEIVE_B  .EQU    SC28L92_BASE+$0B        ;UART Receive Register Port B (READ)
   345             0000FE8B   UART_TRANSMIT_B .EQU    SC28L92_BASE+$0B        ;UART Transmit Register Port B (WRITE)
   346                        ;
   347             0000FE8C   UART_MISC       .EQU    SC28L92_BASE+$0C        ;UART Miscellaneous Register Intel (Read/Write)
   348             0000FE8D   UART_INPUT_PORT .EQU    SC28L92_BASE+$0D        ;UART Input Port Register (READ)
   349             0000FE8D   UART_OUT_CFG    .EQU    SC28L92_BASE+$0D        ;UART Ouput Port Config Register (WRITE)
   350             0000FE8E   UART_START_CNT  .EQU    SC28L92_BASE+$0E        ;UART Start Counter Command (READ)
   351             0000FE8E   UART_SOPR_CMD   .EQU    SC28L92_BASE+$0E        ;UART Set Output Port Bits Register (WRITE)
   352             0000FE8F   UART_STOP_CNT   .EQU    SC28L92_BASE+$0F        ;UART Stop Counter Command (READ)
   353             0000FE8F   UART_ROPR_CMD   .EQU    SC28L92_BASE+$0F        ;UART Reset Output Port Bits Register (WRITE)
   354                        ;
  Mon Apr  3 2023 13:43                                                                                                    Page 8


   355                        ;Additional Hardware
   356                        ; Adding BIOS definitions for Realtime Clock chip - DS1511
   357                        ; uses the first 16 addresses for RTC registers and basic operation
   358                        ; uses two addresses for extended RAM of 256 bytes
   359                        ;
   360                        ; upper addresses are used for a 16-bit IDE interface (below)
   361                        ; NOTE: offset $11 and $12 are unused (reserved per the datasheet).
   362                        ;
   363             0000FE60   RTC_IDE_BASE    .EQU    IOPAGE+$60              ;Beginning of Realtime Clock address
   364                        ;
   365             0000FE60   RTC_SECONDS     .EQU    RTC_IDE_BASE+$00        ;Seconds in BCD 00-59
   366             0000FE61   RTC_MINUTES     .EQU    RTC_IDE_BASE+$01        ;Minutes in BCD 00-59
   367             0000FE62   RTC_HOURS       .EQU    RTC_IDE_BASE+$02        ;Hours in BCD 00-23
   368             0000FE63   RTC_DAY         .EQU    RTC_IDE_BASE+$03        ;Day in BCD 1-7
   369             0000FE64   RTC_DATE        .EQU    RTC_IDE_BASE+$04        ;Date in BCD 1-31
   370             0000FE65   RTC_MONTH       .EQU    RTC_IDE_BASE+$05        ;Month in BCD 1-12
   371             0000FE66   RTC_YEAR        .EQU    RTC_IDE_BASE+$06        ;Year in BCD 00-99
   372             0000FE67   RTC_CENTURY     .EQU    RTC_IDE_BASE+$07        ;Century in BCD 00-39
   373                        ;
   374             0000FE68   RTC_ALARM_SEC   .EQU    RTC_IDE_BASE+$08        ;Alarm Seconds in BCD 00-59
   375             0000FE69   RTC_ALARM_MIN   .EQU    RTC_IDE_BASE+$09        ;Alarm Minutes in BCD 00-59
   376             0000FE6A   RTC_ALARM_HRS   .EQU    RTC_IDE_BASE+$0A        ;Alarm Hours in BCD 00-23
   377             0000FE6B   RTC_ALARM_DYDT  .EQU    RTC_IDE_BASE+$0B        ;Alarm Day/Date in BCD 0-7 1-31
   378             0000FE6C   RTC_WTCHDOG_01  .EQU    RTC_IDE_BASE+$0C        ;Watchdog 0.1 / 0.01 Seconds in BCD 00-99
   379             0000FE6D   RTC_WTCHDOG_10  .EQU    RTC_IDE_BASE+$0D        ;Watchdog 10 / 1 Seconds in BCD 00-99
   380                        ;
   381             0000FE6E   RTC_CONTROL_A   .EQU    RTC_IDE_BASE+$0E        ;Control A
   382             0000FE6F   RTC_CONTROL_B   .EQU    RTC_IDE_BASE+$0F        ;Control B
   383             0000FE70   RTC_RAM_ADDR    .EQU    RTC_IDE_BASE+$10        ;Extended RAM address
   384             0000FE73   RTC_RAM_DATA    .EQU    RTC_IDE_BASE+$13        ;Extended RAM data
   385                        ;
   386                        ; Adding BIOS definitions for 16-bit IDE interface
   387                        ; uses two addresses for Upper Byte Latch read / write
   388                        ; uses eight addresses for Command Block Registers
   389                        ; uses two addresses for Control Block Registers
   390                        ;
   391             0000FE74   IDE_16_READ     .EQU    RTC_IDE_BASE+$14        ;Upper byte Read address
   392             0000FE75   IDE_16_WRITE    .EQU    RTC_IDE_BASE+$15        ;Upper byte Write address
   393                        ;
   394                        ; Adding BIOS definitions for IDE Controller (HARD DISK, Flash Module, etc.)
   395                        ; Hardware Adapter provides a 16-bit IDE Port per:
   396                        ;  Seagate ATA Interface Reference Manual 36111-001, Rev. C (21st May 1993)
   397                        ;
   398                        ; Control Block Registers
   399             0000FE76   IDE_ALT_STATUS  .EQU    RTC_IDE_BASE+$16        ;Alternate Status Register (READ)
   400             0000FE76   IDE_DEV_CTRL    .EQU    RTC_IDE_BASE+$16        ;Device Control Register (WRITE)
   401             0000FE77   IDE_DRV_ADDR    .EQU    RTC_IDE_BASE+$17        ;Drive Address Register (READ)
   402                        ;
   403                        ; Command Block Registers
   404             0000FE78   IDE_DATA        .EQU    RTC_IDE_BASE+$18        ;Data Register (R/W)
   405             0000FE79   IDE_ERROR       .EQU    RTC_IDE_BASE+$19        ;Error Register (READ)
   406             0000FE79   IDE_FEATURE     .EQU    RTC_IDE_BASE+$19        ;Feature Register (WRITE)
   407             0000FE7A   IDE_SCT_CNT     .EQU    RTC_IDE_BASE+$1A        ;Sector Count Register
   408             0000FE7B   IDE_SCT_NUM     .EQU    RTC_IDE_BASE+$1B        ;Sector Number Register
   409             0000FE7C   IDE_CYL_LOW     .EQU    RTC_IDE_BASE+$1C        ;Cylinder Low Register
   410             0000FE7D   IDE_CYL_HIGH    .EQU    RTC_IDE_BASE+$1D        ;Cylinder High Register
   411             0000FE7E   IDE_DRV_HEAD    .EQU    RTC_IDE_BASE+$1E        ;Drive/Head Register
   412             0000FE7F   IDE_STATUS      .EQU    RTC_IDE_BASE+$1F        ;Status Register (READ)
   413             0000FE7F   IDE_COMMAND     .EQU    RTC_IDE_BASE+$1F        ;Command Register (WRITE)
   414                        ;
   415                        ;**************************************************************************************************
   416                                .END
    82                        ;
  Mon Apr  3 2023 13:43                                                                                                    Page 9


    83                        ;**************************************************************************************************
    84                        ;       - Monitor JUMP table: 32 JUMP calls are Defined, with one Call (02) currently Reserved.
    85                        ;
    86             0000E000   M_COLD_MON      .EQU    $E000           ;Call 00        Monitor Cold Start
    87             0000E003   M_WARM_MON      .EQU    $E003           ;Call 01        Monitor Warm Start
    88                        ;
    89             0000E006   M_RESERVE2      .EQU    $E006           ;Call 02        Reserved
    90                        ;
    91             0000E009   M_MOVE_RAM      .EQU    $E009           ;Call 03        Move Memory
    92             0000E00C   M_FILL_LP       .EQU    $E00C           ;Call 04        Fill Memory
    93             0000E00F   M_BSOUT         .EQU    $E00F           ;Call 05        Send Backspace
    94             0000E012   M_XMDM_SAVE     .EQU    $E012           ;Call 06        Xmodem Save Entry
    95             0000E015   M_XMDM_LOAD     .EQU    $E015           ;Call 07        Xmodem Load Entry
    96             0000E018   M_BENCH         .EQU    $E018           ;Call 08        Benchmark Start
    97             0000E01B   M_QUITB         .EQU    $E01B           ;Call 09        Benchmark Stop/End
    98             0000E01E   M_TIME          .EQU    $E01E           ;Call 10        System Date/Time
    99             0000E021   M_PRSTAT1       .EQU    $E021           ;Call 11        CPU Status Display
   100             0000E024   M_DIS_LINE      .EQU    $E024           ;Call 12        Disassemble Line of Code
   101             0000E027   M_INCINDEX      .EQU    $E027           ;Call 13        Increment Index by 1
   102             0000E02A   M_DECINDEX      .EQU    $E02A           ;Call 14        Decrement Index by 1
   103             0000E02D   M_RDLINE        .EQU    $E02D           ;Call 15        Read Line from Terminal
   104             0000E030   M_RDCHAR        .EQU    $E030           ;Call 16        Read Character from Terminal
   105             0000E033   M_HEXIN2        .EQU    $E033           ;Call 17        Hex input 2 characters
   106             0000E036   M_HEXIN4        .EQU    $E036           ;Call 18        Hex input 4 characters
   107             0000E039   M_HEX2ASC       .EQU    $E039           ;Call 19        Convert Hex to ASCII
   108             0000E03C   M_BIN2ASC       .EQU    $E03C           ;Call 20        Convert Binary to ASCII
   109             0000E03F   M_ASC2BIN       .EQU    $E03F           ;Call 21        Convert ASCII to Binary
   110             0000E042   M_BEEP          .EQU    $E042           ;Call 22        Send BEEP to Terminal
   111             0000E045   M_DOLLAR        .EQU    $E045           ;Call 23        Send $ to Terminal
   112             0000E048   M_CROUT         .EQU    $E048           ;Call 24        Send C/R to Terminal
   113             0000E04B   M_SPC           .EQU    $E04B           ;Call 25        Send ASCII Space to Terminal
   114             0000E04E   M_PRBYTE        .EQU    $E04E           ;Call 26        Print Byte to Terminal
   115             0000E051   M_PRWORD        .EQU    $E051           ;Call 27        Print Word to Terminal
   116             0000E054   M_PRASC         .EQU    $E054           ;Call 28        Print ASCII to Terminal
   117             0000E057   M_PROMPT        .EQU    $E057           ;Call 29        Send Message by number to Terminal
   118             0000E05A   M_PROMPTR       .EQU    $E05A           ;Call 30        Send Message by address to Terminal
   119             0000E05D   M_CONTINUE      .EQU    $E05D           ;Call 31        Y/N Prompt to Continue Command
   120                        ;
   121                        ;**************************************************************************************************
   122                                .ORG    $F800   ;2KB reserved for BIOS, I/O device selects (160 bytes)                    *
   123                        ;**************************************************************************************************
   124                        ;                               START OF BIOS CODE                                                *
   125                        ;**************************************************************************************************
   126                        ;C02BIOS version used here is 4.02 (updated release)
   127                        ; Contains the base BIOS routines in top 2KB of EEPROM
   128                        ; - Input/Feedback from "BDD" - modified CHRIN/CHROUT I/O routines - saves 12 bytes
   129                        ; - $F800 - $F9FF 512 bytes for BIOS SC28L92, NMI Panic routine
   130                        ; - $FA00 - $FDFF reserved for BIOS expansion (1KB)
   131                        ; - $FE00 - $FE7F reserved for HW (4-I/O selects, 32 bytes wide)
   132                        ; - $FE80 - $FE9F SC28L92 DUART (32 bytes wide, only 16 bytes used)
   133                        ; - $FEA0 - $FEFF used for Vector and Hardware configuration data
   134                        ; - $FF00 - $FFFF JMP table, CPU startup, NMI/BRK/IRQ pre-post routines, Page $03 init, BIOS msg
   135                        ;
   136                        ; UPDATES:
   137                        ; Note: C02BIOS 3.04 is the base for 4.0x.
   138                        ;
   139                        ; Fixed IRQ enable for IDE controller. Also streamlined some startup routines. 11th Oct 2020
   140                        ; Eliminates IDE byte swapping to ensure compatibility with standard formats. 20th January 2021
   141                        ; Allocate $0400-$04FF for second UART buffer space. 5th February 2021
   142                        ; Default RTC NVRAM buffer space at $0500-$05FF. 5th February 2021
   143                        ; Default IDE Block buffer at $0600-$07FF. 5th February 2021
   144                        ; Panic Routine changed, no longer saves multiple pages, just restores system. 5th February 2021
   145                        ; New routine to Start Benchmark Counter. Allows counter Start/Stop (pause). 5th February 2021
  Mon Apr  3 2023 13:43                                                                                                    Page 10


   146                        ; Some minor cleanup and fixed a few bugs in the RTC and IDE routines. 14th May 2021
   147                        ; Update Init and ISR routines to support NXP SC28L92 DUART, both ports and timer. 31st August 2021
   148                        ; Update Character I/O routines for Serial Ports. Supports on-chip FIFOs Rcv/Xmt. 14th October 2021
   149                        ; Updates to support IDE as Hitachi MicroDrive (3.3V prototype). 9th August 2021
   150                        ; Bios 4.00 and later now support multiple block transfers to/from IDE device. 13th September 2021
   151                        ; Removed Extended Delay (XLdelay) routine, not ever used except for testing. 
   152                        ;
   153                        ; Note: C02BIOS 4.01 Updates 17th October, 2021
   154                        ;
   155                        ; Streamlined IDE Detection, Initialize and Reset routines.
   156                        ; - Recalibrate Command removed from Detection, Diagnostics only are run.
   157                        ; - Likewise, Diagnositcs removed from Reset command, Recalibrate only is done.
   158                        ; - Removed detection for LBA support, as the Hitachi 3K8 Microdrive supports this natively.
   159                        ;
   160                        ; Added support for Receive/Transmit FIFOs for SC28L92 DUART.
   161                        ;
   162                        ; Note: C02BIOS 4.02 Updates 31st May, 2022
   163                        ;
   164                        ; Rearranged the ISR for the DUART, the two comm ports are now shorter handlers by a few clock
   165                        ; cycles and the code itself is 12 bytes shorter. The Counter/Timer handler is increased by
   166                        ; 3 clock cycles. Minor change to RTC ISR, saves a byte and 2 clock cycles ;-)
   167                        ;
   168                        ; Minor change to RTC/IDE Inits... saves another 4 bytes ;-)
   169                        
   170                        ; NOTE: C02BIOS 4.02 Updates 15th August, 2022
   171                        ; - No actual code changes!
   172                        ; - Slight restructuring of routines to minimze any page boundary impacts on clock cycles!
   173                        ;
   174                        ; NOTE: C02BIOS 4.02 Updates 15th February, 2023
   175                        ; - No actual code changes!
   176                        ; - Slight changes in Page Zero locations. As two bytes were freed up for the SC28L92 BIOS,
   177                        ;   the two free locations have been moved and labeled near the top of Page Zero, now marked as:
   178                        ;   SPARE_B0 and SPARE_B1
   179                        ;**************************************************************************************************
   180                        ; The following 32 functions are provided by BIOS via the JMP Table
   181                        ; $FF48 - Reserved for future expansion (1 available)
   182                        ;
   183                        ; $FF00 IDE_RESET       ;Reset IDE Controller (Recalibrate Command)
   184                        ; $FF03 IDE_GET_STAT    ;Get Status and Error code
   185                        ; $FF06 IDE_IDENTIFY    ;Load IDE Identity Data at $0600
   186                        ; $FF09 IDE_READ_LBA    ;Read LBA into memory
   187                        ; $FF0C IDE_WRITE_LBA   ;Write LBA from memory
   188                        ; $FF0F IDE_VERFY_LBA   ;Verify LBA from last Read/Write
   189                        ; $FF12 IDE_SET_LBA     ;Set LBA number (24-bit support only)
   190                        ; $FF15 IDE_SET_ADDR    ;Set LBA transfer address (16-bit plus block count)
   191                        ; $FF18 IDE_EN_CACHE    ;Enable IDE Write Cache
   192                        ; $FF1B DIS_CACHE JMP   ;Disable IDE Write Cache
   193                        ;
   194                        ; $FF1E RTC_NVRD        ;Read NVRAM (256 bytes) from RTC to memory (16-bit)
   195                        ; $FF21 RTC_NVWR        ;Write NVRAM (256 bytes) from memory to RTC (16-bit)
   196                        ; $FF24 RTC_INIT        ;Initialize software RTC from hardware RTC
   197                        ;
   198                        ; $FF27 CHRIN2          ;Data input from aux port
   199                        ; $FF2A CHROUT2         ;Data output to aux port
   200                        ;
   201                        ; $FF2D CNT_INIT        ;Reset Benchmark timing counters/Start 10ms benchmark timer
   202                        ; $FF30 CNT_STRT        ;Start 10ms benchmark timing counter
   203                        ; $FF33 CNT_STOP        ;Stop 10ms benchmark timing counter
   204                        ;
   205                        ; $FF36 CHRIN_NW        ;Data input from console, no waiting, clear carry if none
   206                        ; $FF39 CHRIN           ;Data input from console
   207                        ; $FF3C CHROUT          ;Data output to console
   208                        ;
  Mon Apr  3 2023 13:43                                                                                                    Page 11


   209                        ; $FF3F SET_DLY         ;Set delay value for milliseconds and 16-bit counter
   210                        ; $FF42 EXE_MSDLY       ;Execute millisecond delay 1-256 * 10 milliseconds
   211                        ; $FF45 EXE_LGDLY       ;Execute long delay; millisecond delay * 16-bit count
   212                        
   213                        ; $FF48 Reserved        ;Reserved for future expansion
   214                        ;
   215                        ; $FF4B INIT_VEC        ;Initialize soft vectors at $0300 from ROM
   216                        ; $FF4E INIT_CFG        ;Initialize soft config values at $0320 from ROM
   217                        ;
   218                        ; $FF51 INIT_28L92      ;Initialize SC28L92 - Port A as console at 115.2K, 8-N-1 RTS/CTS
   219                        ; $FF54 RESET_28L92     ;Reset SC28L92 - called before INIT_28L92
   220                        ;
   221                        ; $FF57 MONWARM         ;Monitor warm start - jumps to page $03
   222                        ; $FF5A MONCOLD         ;Monitor cold start - jumps to page $03
   223                        ; $FF5D COLDSTRT        ;System cold start - RESET vector for 65C02
   224                        ;**************************************************************************************************
   225                        ;               Data In and Out routines for Console I/O buffer                                   *
   226                        ;**************************************************************************************************
   227                        ;Data Input A routines
   228                        ;CHRIN_NW uses CHRIN, returns if data is not available from the buffer with carry flag clear,
   229                        ; else returns with data in A Reg and carry flag set. CHRIN waits for data to be in the buffer,
   230                        ; then returns with carry flag set. Receive is IRQ driven/buffered with a size of 128 bytes.
   231                        ; Note: CHRIN_NW is only on Port A, which is used for a Console.
   232                        ;
   233 00:F800: 18           CHRIN_NW        CLC                     ;Clear Carry flag for no data (2)
   234 00:F801: A5 D7                        LDA     ICNT_A          ;Get buffer count (4)
   235 00:F803: D0 05                        BNE     GET_CH          ;Branch if buffer is not empty (2/3)
   236 00:F805: 60                           RTS                     ;Or return to caller (6)
   237                        ;
   238 00:F806: A5 D7        CHRIN           LDA     ICNT_A          ;Get data count (3)
   239 00:F808: F0 FC                        BEQ     CHRIN           ;If zero (no data, loop back) (2/3)
   240                        ;
   241 00:F80A: 5A           GET_CH          PHY                     ;Save Y Reg (3)
   242 00:F80B: A4 D8                        LDY     IHEAD_A         ;Get the buffer head pointer (3)
   243 00:F80D: B9 00 02                     LDA     IBUF_A,Y        ;Get the data from the buffer (4)
   244 00:F810: E6 D8                        INC     IHEAD_A         ;Increment head pointer (5)
   245 00:F812: 77 D8                        RMB7    IHEAD_A         ;Strip off bit 7, 128 bytes only (5)
   246 00:F814: C6 D7                        DEC     ICNT_A          ;Decrement the buffer count (5)
   247                        ;
   248 00:F816: 7A                           PLY                     ;Restore Y Reg (4)
   249 00:F817: 38                           SEC                     ;Set Carry flag for data available (2)
   250 00:F818: 60                           RTS                     ;Return to caller with data in A Reg (6)
   251                        ;
   252                        ;Data Output A routine: puts the data in the A Reg into the xmit buffer, data in
   253                        ; A Reg is preserved on exit. Transmit is IRQ driven/buffered with a size of 128 bytes.
   254                        ;
   255 00:F819: 5A           CHROUT          PHY                     ;Save Y Reg (3)
   256 00:F81A: A4 DA        OUTCH           LDY     OCNT_A          ;Get data output count in buffer (3)
   257 00:F81C: 30 FC                        BMI     OUTCH           ;Check buffer full, if yes, check Xmit on (2/3)
   258                        ;
   259 00:F81E: A4 DC                        LDY     OTAIL_A         ;Get the buffer tail pointer (3)
   260 00:F820: 99 80 02                     STA     OBUF_A,Y        ;Place data in the buffer (5)
   261 00:F823: E6 DC                        INC     OTAIL_A         ;Increment Tail pointer (5)
   262 00:F825: 77 DC                        RMB7    OTAIL_A         ;Strip off bit 7, 128 bytes only (5)
   263 00:F827: E6 DA                        INC     OCNT_A          ;Increment data count (5)
   264                        ;
   265 00:F829: A0 04                        LDY     #%00000100      ;Get mask for xmit on (2)
   266 00:F82B: 8C 82 FE                     STY     UART_COMMAND_A  ;Turn on xmit (4)
   267                        ;
   268 00:F82E: 7A                           PLY                     ;Restore Y Reg (4)
   269 00:F82F: 60                           RTS                     ;Return to caller (6)
   270                        ;
   271                        ;Data Input B routine
  Mon Apr  3 2023 13:43                                                                                                    Page 12


   272                        ; CHRIN waits for data to be in the buffer, then returns with data in A reg.
   273                        ; Receive is IRQ driven/buffered with a size of 128 bytes.
   274                        ;
   275 00:F830: A5 DD        CHRIN2          LDA     ICNT_B          ;Get data count (3)
   276 00:F832: F0 FC                        BEQ     CHRIN2          ;If zero (no data, loop back) (2/3)
   277                        ;
   278 00:F834: 5A                           PHY                     ;Save Y Reg (3)
   279 00:F835: A4 D8                        LDY     IHEAD_A         ;Get the buffer head pointer (3)
   280 00:F837: B9 00 04                     LDA     IBUF_B,Y        ;Get the data from the buffer (4)
   281 00:F83A: E6 DE                        INC     IHEAD_B         ;Increment head pointer (5)
   282 00:F83C: 77 DE                        RMB7    IHEAD_B         ;Strip off bit 7, 128 bytes only (5)
   283 00:F83E: C6 DD                        DEC     ICNT_B          ;Decrement the buffer count (5)
   284                        ;
   285 00:F840: 7A                           PLY                     ;Restore Y Reg (4)
   286 00:F841: 60                           RTS                     ;Return to caller with data in A Reg (6)
   287                        ;
   288                        ;Data Output B routine: puts the data in the A Reg into the xmit buffer, data in
   289                        ; A Reg is preserved on exit. Transmit is IRQ driven/buffered with a size of 128 bytes.
   290                        ;
   291 00:F842: 5A           CHROUT2         PHY                     ;Save Y Reg (3)
   292 00:F843: A4 E0        OUTCH2          LDY     OCNT_B          ;Get data output count in buffer (3)
   293 00:F845: 30 FC                        BMI     OUTCH2          ;Check against limit, loop back if full (2/3)
   294                        ;
   295 00:F847: A4 E2                        LDY     OTAIL_B         ;Get the buffer tail pointer (3)
   296 00:F849: 99 80 04                     STA     OBUF_B,Y        ;Place data in the buffer (5)
   297 00:F84C: E6 E2                        INC     OTAIL_B         ;Increment Tail pointer (5)
   298 00:F84E: 77 E2                        RMB7    OTAIL_B         ;Strip off bit 7, 128 bytes only (5)
   299 00:F850: E6 E0                        INC     OCNT_B          ;Increment data count (5)
   300                        ;
   301 00:F852: A0 04                        LDY     #%00000100      ;Get mask for xmit on (2)
   302 00:F854: 8C 8A FE                     STY     UART_COMMAND_B  ;Turn on xmit (4)
   303                        ;
   304 00:F857: 7A                           PLY                     ;Restore Y Reg (4)
   305 00:F858: 60                           RTS                     ;Return to caller (6)
   306                        ;
   307                        ;**************************************************************************************************
   308                        ;START of IDE Routines for Hitachi 3K8 MicroDrive                                                 *
   309                        ;**************************************************************************************************
   310                        ;
   311                        IDE_READ_LBA                            ;Read a Block of data from IDE device
   312                        ;
   313                        ; This routine requires loading the requested LBA into the appropriate registers and
   314                        ; issuing the READ command 20h. The LBA limit supported for the BIOS are bits 0-23,
   315                        ; so bits 24-27 are always set to 0. This provides access to IDE devices up to 8GB.
   316                        ;
   317                        ; Once the registers/parameters are setup, the Read Block command is issued.
   318                        ; This results in an interrupt being generated. The ISR handles the transfer of LBA
   319                        ; data from the IDE Drive to memory.
   320                        ;
   321                        ; BIOS 4.00 and later supports multiple block transfers, increasing performance.
   322                        ;
   323                        ; The registers used are the same for read/write/verify. These are:
   324                        ;
   325                        ;       IDE_COMMAND = function requested (20h = READ LBA command)
   326                        ;       IDE_DRV_HEAD = (Upper 4 bits) used as:
   327                        ;               bit 7 = 1 per Seagate documentation
   328                        ;               bit 6 = 1 for LBA mode
   329                        ;               bit 5 = 1 per Seagate documentation
   330                        ;               bit 4 = 0 for Drive 0
   331                        ;       IDE_DRV_HEAD = LBA Address bits 27-24 (lower 4 bits) - not used, always 0000
   332                        ;       IDE_CYL_HIGH = LBA Address bits 23-16
   333                        ;       IDE_CYL_LOW = LBA Address bits 15-8
   334                        ;       IDE_SCT_NUM = LBA Address bits 7-0
  Mon Apr  3 2023 13:43                                                                                                    Page 13


   335                        ;       IDE_SCT_CNT = number of blocks to read
   336                        ;
   337 00:F859: 20 EF F8                     JSR     IDE_SET_PARMS   ;Setup required parameters (6)
   338 00:F85C: A9 20                        LDA     #$20            ;Get Read LBA command (2)
   339                        IDENT_READ                              ;Identify Command jumps here to complete
   340 00:F85E: B7 FF                        SMB3    MATCH           ;Set Read LBA bit (5)
   341 00:F860: 8D 7F FE                     STA     IDE_COMMAND     ;Send command to IDE Controller (4)
   342                        ;
   343                        LBA_RD_CMD
   344 00:F863: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   345 00:F866: 30 FB                        BMI     LBA_RD_CMD      ;Loop until IDE controller not Busy (2/3)
   346                        ;
   347                        LBA_RD_WAIT
   348 00:F868: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   349 00:F86B: C9 50                        CMP     #$50            ;Compare for ready (2)
   350 00:F86D: D0 04                        BNE     LBA_RD_ERR      ;If not, check for error condition (2/3)
   351                        LBA_RD_OK
   352 00:F86F: BF FF FD                     BBS3    MATCH,LBA_RD_OK ;Wait for Read completed via ISR (5/6)
   353 00:F872: 60                           RTS                     ;Return to caller (status in A Reg) (6)
   354                        LBA_RD_ERR
   355 00:F873: 4A                           LSR     A               ;Shift error bit to carry (2)
   356 00:F874: 90 F2                        BCC     LBA_RD_WAIT     ;If clear, loop back and continue waiting (2/3)
   357                        ;
   358 00:F876: 37 FF                        RMB3    MATCH           ;Reset Read LBA bit (no ISR invoked) (5)
   359                        IDE_RWV_FIN
   360 00:F878: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   361 00:F87B: 85 FC                        STA     IDE_STATUS_RAM  ;Update RAM Status Register (3)
   362 00:F87D: 60                           RTS                     ;Return to caller (6)
   363                        ;
   364                        IDE_WRITE_LBA                           ;Write a block of data to LBA
   365                        ;
   366                        ; This routine requires loading the requested LBA into the appropriate registers and
   367                        ; issuing the WRITE command 30h. The LBA limit supported for the BIOS are bits 0-23,
   368                        ; so bits 24-27 are always set to 0. This provides access to IDE devices up to 8GB.
   369                        ;
   370                        ; The registers used are the same for read/write/verify. These are:
   371                        ;
   372                        ;       IDE_COMMAND = function requested (30h = WRITE LBA command)
   373                        ;       IDE_DRV_HEAD = (Upper 4 bits) used as:
   374                        ;               bit 7 = 1 per Seagate documentation
   375                        ;               bit 6 = 1 for LBA mode
   376                        ;               bit 5 = 1 per Seagate documentation
   377                        ;               bit 4 = 0 for Drive 0
   378                        ;       IDE_DRV_HEAD = LBA Address bits 27-24 (lower 4 bits) - not used, always 0000
   379                        ;       IDE_CYL_HIGH = LBA Address bits 23-16
   380                        ;       IDE_CYL_LOW = LBA Address bits 15-8
   381                        ;       IDE_SCT_NUM = LBA Address bits 7-0
   382                        ;       IDE_SCT_CNT = number of blocks to write
   383                        ;
   384 00:F87E: 20 EF F8                     JSR     IDE_SET_PARMS   ;Setup required parameters (6)
   385                        ;
   386 00:F881: A7 FF                        SMB2    MATCH           ;Set Write LBA bit (5)
   387 00:F883: A9 30                        LDA     #$30            ;Get Write LBA command (2)
   388 00:F885: 8D 7F FE                     STA     IDE_COMMAND     ;Send command to IDE Controller (4)
   389                        LBA_WR_CMD
   390 00:F888: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   391 00:F88B: 30 FB                        BMI     LBA_WR_CMD      ;Loop until IDE controller not Busy (2/3)
   392 00:F88D: 4A                           LSR     A               ;Shift Error bit into Carry flag (2)
   393 00:F88E: B0 30                        BCS     IDE_WRITE_ERR   ;If Carry set, IDE error (2/3)
   394                        ;
   395                        ; Write Block routine integrated into IDE_WRITE_LBA
   396                        ;
   397                        ; - High byte needs to be loaded into the latch before the
  Mon Apr  3 2023 13:43                                                                                                    Page 14


   398                        ;   low byte is loaded into the Data Register!
   399                        ;
   400                        IDE_WRITE_BLK                           ;Write a block of data
   401 00:F890: 5A                           PHY                     ;Save Y reg (3)
   402 00:F891: A0 01                        LDY     #$01            ;Set offset for high byte latch (2)
   403                        ;
   404                        IDE_WRITE_LOOP
   405 00:F893: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   406 00:F896: 29 08                        AND     #%00001000      ;Check for DRQ active (2)
   407 00:F898: F0 18                        BEQ     IDE_WR_FIN      ;If not active, exit (below) (2/3)
   408                        IDE_WR_WBLK
   409 00:F89A: B1 F9                        LDA     (BIOS_XFERL),Y  ;Get first byte of buffer+1 (5)
   410 00:F89C: 8D 75 FE                     STA     IDE_16_WRITE    ;Place into high byte latch (4)
   411 00:F89F: B2 F9                        LDA     (BIOS_XFERL)    ;Get first byte of buffer (5)
   412 00:F8A1: 8D 78 FE                     STA     IDE_DATA        ;Write buffer to IDE (writes a word) (4)
   413                        ;
   414                        ; - Buffer index needs to be incremented twice
   415                        ;
   416 00:F8A4: E6 F9                        INC     BIOS_XFERL      ;Increment pointers once (5)
   417 00:F8A6: D0 02                        BNE     IDE_WR_BLK1     ; (2/3)
   418 00:F8A8: E6 FA                        INC     BIOS_XFERH      ; (5)
   419                        IDE_WR_BLK1
   420 00:F8AA: E6 F9                        INC     BIOS_XFERL      ;Increment pointers again (5)
   421 00:F8AC: D0 E5                        BNE     IDE_WRITE_LOOP  ; (2/3)
   422 00:F8AE: E6 FA                        INC     BIOS_XFERH      ; (5)
   423 00:F8B0: 80 E1                        BRA     IDE_WRITE_LOOP  ;Loop back for 256 words (3)
   424                        ;
   425                        IDE_WR_FIN
   426                        ; when DRQ ends, 512 bytes have been sent to IDE controller. Controller then sets BUSY,
   427                        ; when finished processing data, controller clears BUSY and generates an interrupt.
   428                        ; So, we test for BUSY first and wait until the block is written.
   429                        ;
   430 00:F8B2: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   431 00:F8B5: 30 FB                        BMI     IDE_WR_FIN      ;Loop until BUSY bit is clear (2/3)
   432                        ;
   433 00:F8B7: C6 FB                        DEC     BIOS_XFERC      ;Decrement Block Count to transfer (5)
   434 00:F8B9: D0 D8                        BNE     IDE_WRITE_LOOP  ;If not zero, branch back to write next LBA (2/3)
   435                        ;
   436                        WR_WAIT
   437 00:F8BB: AF FF FD                     BBS2    MATCH,WR_WAIT   ;Wait for Write completed via ISR (5,6)
   438 00:F8BE: 7A                           PLY                     ;Restore Y reg (4)
   439 00:F8BF: 60                           RTS                     ;Return to caller (6)
   440                        IDE_WRITE_ERR
   441 00:F8C0: 27 FF                        RMB2    MATCH           ;Reset Write LBA bit (no ISR) (5)
   442 00:F8C2: 80 B4                        BRA     IDE_RWV_FIN     ;Branch and finish up (3)
   443                        ;
   444                        IDE_VERIFY_LBA                          ;Verify LBA after write
   445                        ;
   446                        ; This routine requires loading the requested LBA into the appropriate registers and
   447                        ; issuing the VERIFY command 40h. The LBA limit supported for the BIOS are bits 0-23,
   448                        ; so bits 24-27 are always set to 0. This provides access to IDE devices up to 8GB.
   449                        ;
   450                        ; It is identical to a Read Block command except no Data is transferred, only verified.
   451                        ; Also, no DRQ is set, but an interrupt is generated after the Verify is completed.
   452                        ;
   453                        ; The registers used are the same for read/write/verify. These are:
   454                        ;
   455                        ;       IDE_COMMAND = function requested (40h = Verify LBA command)
   456                        ;       IDE_DRV_HEAD = (Upper 4 bits) used as:
   457                        ;               bit 7 = 1 per Seagate documentation
   458                        ;               bit 6 = 1 for LBA mode
   459                        ;               bit 5 = 1 per Seagate documentation
   460                        ;               bit 4 = 0 for Drive 0
  Mon Apr  3 2023 13:43                                                                                                    Page 15


   461                        ;       IDE_DRV_HEAD = LBA Address bits 27-24 (lower 4 bits) - not used, always 0000
   462                        ;       IDE_CYL_HIGH = LBA Address bits 23-16
   463                        ;       IDE_CYL_LOW = LBA Address bits 15-8
   464                        ;       IDE_SCT_NUM = LBA Address bits 7-0
   465                        ;       IDE_SCT_CNT = number of blocks to verify
   466                        ;
   467 00:F8C4: 20 EF F8                     JSR     IDE_SET_PARMS   ;Setup required parameters (6)
   468                        ;
   469 00:F8C7: 97 FF                        SMB1    MATCH           ;Set Verify LBA bit (5)
   470 00:F8C9: A9 40                        LDA     #$40            ;Get Verify LBA command (2)
   471 00:F8CB: 8D 7F FE                     STA     IDE_COMMAND     ;Send command to IDE Controller (4)
   472                        LBA_VF_CMD
   473 00:F8CE: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   474 00:F8D1: 30 FB                        BMI     LBA_VF_CMD      ;Loop until IDE controller not Busy (2/3)
   475 00:F8D3: 4A                           LSR     A               ;Shift Error bit into Carry flag (2)
   476 00:F8D4: 90 04                        BCC     VF_FINISH       ;If Carry clear, no error (2/3)
   477                        ;
   478 00:F8D6: 17 FF                        RMB1    MATCH           ;Reset Verify LBA bit (no ISR) (5)
   479 00:F8D8: 80 9E                        BRA     IDE_RWV_FIN     ;Branch and finish up (3)
   480                        ;
   481                        VF_FINISH
   482 00:F8DA: 20 1C F9                     JSR     TST_IDE_RDY     ;Wait for IDE Controller ready (6)
   483                        VF_WAIT
   484 00:F8DD: 9F FF FD                     BBS1    MATCH,VF_WAIT   ;Wait for Verify to complete via ISR (5,6)
   485 00:F8E0: 60                           RTS                     ;Return to caller (6)
   486                        ;
   487                        IDE_SET_ADDRESS                         ;Set Address for LBA (read/write)
   488                        ;
   489                        ; This routine uses the A,Y,X registers to setup the address in memory that a block
   490                        ; will be read to or written from (16-bit address), along with the block count.
   491                        ; The Register usage is as follows:
   492                        ;       A Register = Memory address low byte
   493                        ;       Y Register = Memory address high byte
   494                        ;       X Register = Block count to transfer (device dependent)
   495 00:F8E1: 85 F3                        STA     LBA_ADDR_LOW    ;Set LBA low byte address (3)
   496 00:F8E3: 84 F4                        STY     LBA_ADDR_HIGH   ;Set LBA high byte address (3)
   497 00:F8E5: 86 F5                        STX     LBA_XFER_CNT    ;Set LBA Block count for xfer (3)
   498 00:F8E7: 60                           RTS                     ;Return to caller (6)
   499                        ;
   500                        IDE_SET_LBA                             ;Set LBA block for transfer (read/write)
   501                        ;
   502                        ; This routine sets the variables used to select the starting LBA for transfer.
   503                        ; The Register usage is as follows:
   504                        ;       A Register = LBA Address bits 7-0
   505                        ;       Y Register = LBA Address bits 15-8
   506                        ;       X Register = LBA Address bits 23-16
   507 00:F8E8: 85 F6                        STA     LBA_LOW_BYTE    ;Store Address bits 0-7 (3)
   508 00:F8EA: 84 F7                        STY     LBA_HIGH_BYTE   ;Store Address bits 8-15 (3)
   509 00:F8EC: 86 F8                        STX     LBA_EXT_BYTE    ;Store Address bits 16-23 (3)
   510 00:F8EE: 60                           RTS                     ;Return to caller (6)
   511                        ;
   512                        IDE_SET_PARMS                           ;Set All parameters for LBA transfers
   513                        ;
   514                        ; This routine sets the LBA number used for all transfers.
   515                        ; - The IDE Controller is checked first to ensure it's ready to receive parameters
   516                        ; - then the requested LBA (stored in Page Zero variables) are loaded into the
   517                        ; - IDE Controller registers, followed by the required Mode parameters.
   518                        ; - Last, the transfer address is setup which points to the location in memory that
   519                        ; - will be used to transfer Data to or from.
   520                        ;
   521 00:F8EF: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   522 00:F8F2: 30 FB                        BMI     IDE_SET_PARMS   ;Loop until BUSY bit is clear (2/3)
   523                        ;
  Mon Apr  3 2023 13:43                                                                                                    Page 16


   524                        ; The following code loop saves space for transferring parameter data over to the
   525                        ; working memory locations. However, the savings in ROM space incures a penalty in
   526                        ; clock cycles (64 vs 28) for execution. This does impact the actual data transfer
   527                        ; rate acheived. It's commented out here and can be used if ROM space becomes
   528                        ; too tight, otherwise just use the inline code below to set the parameters.
   529                        ;
   530                        ;                PHX                     ;Save X register (3)
   531                        ;                LDX     #$04            ;Set Index count for 4 (2)
   532                        ;PARM_XFER_LP
   533                        ;                LDA     LBA_XFER_CNT-1,X        ;Get the parameters (4)
   534                        ;                STA     IDE_SCT_CNT-1,X ;Store to IDE registers (5)
   535                        ;                DEX                     ;Decrement count (2)
   536                        ;                BNE     PARM_XFER_LP    ;Loop back till done (2/3)
   537                        ;                PLX                     ;Restore X register (4)
   538                        ;
   539                        ; Fastest code to transfer parameters to working memory!
   540                        ;
   541 00:F8F4: A5 F8                        LDA     LBA_EXT_BYTE    ;Set LBA bits 23-16 (3)
   542 00:F8F6: 8D 7D FE                     STA     IDE_CYL_HIGH    ;Send to IDE (4)
   543 00:F8F9: A5 F7                        LDA     LBA_HIGH_BYTE   ;Set LBA bits 15-8 (3)
   544 00:F8FB: 8D 7C FE                     STA     IDE_CYL_LOW     ;Send to IDE (4)
   545 00:F8FE: A5 F6                        LDA     LBA_LOW_BYTE    ;Get LBA bits 7-0 (3)
   546 00:F900: 8D 7B FE                     STA     IDE_SCT_NUM     ;Send to IDE (4)
   547 00:F903: A5 F5                        LDA     LBA_XFER_CNT    ;Get Block count to read (3)
   548 00:F905: 8D 7A FE                     STA     IDE_SCT_CNT     ;Send to IDE (4)
   549                        ;
   550                        IDE_SET_PARMS2                          ;Set partial parameters (non LBA xfer commands)
   551                        ;
   552 00:F908: A9 E0                        LDA     #%11100000      ;Set Drive 0, LBA mode, LBA bits 27-24 as 0 (2)
   553 00:F90A: 8D 7E FE                     STA     IDE_DRV_HEAD    ;Send to IDE controller (4)
   554                        ;
   555 00:F90D: A5 F3                        LDA     LBA_ADDR_LOW    ;Setup buffer address (3)
   556 00:F90F: 85 F9                        STA     BIOS_XFERL      ;Store low byte (3)
   557 00:F911: A5 F4                        LDA     LBA_ADDR_HIGH   ;Block Buffer Address (3)
   558 00:F913: 85 FA                        STA     BIOS_XFERH      ;Store high byte (3)
   559 00:F915: A5 F5                        LDA     LBA_XFER_CNT    ;Get Block count to read (3)
   560 00:F917: 85 FB                        STA     BIOS_XFERC      ;Set BIOS Block count to Xfer (3)
   561 00:F919: 64 FC                        STZ     IDE_STATUS_RAM  ;Clear RAM Status Register, ISR updates it (3)
   562 00:F91B: 60                           RTS                     ;Return to caller (6)
   563                        ;
   564                        TST_IDE_RDY
   565                        ;
   566                        ;Test for IDE Controller Ready
   567                        ; This routine tests that the IDE Controller is ready and can accept a command for execution.
   568                        ; There are two bits in the status to qualify this:
   569                        ; Bit 6 is for Ready and bit 4 is for Seek Complete. Both should be active to qualify the
   570                        ; drive as being ready (per Hitachi Microdrive documentation).
   571                        ; Note: It's also possible that bit 0 might be set, which indicates an error condition.
   572                        ; If an error has occurred, we should test for this as well, and set the carry flag to
   573                        ; ensure proper drive sensing.
   574                        ;
   575 00:F91C: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   576 00:F91F: C9 51                        CMP     #$51            ;Test for Ready and Error bits on (2)
   577 00:F921: F0 06                        BEQ     TST_IDE_ERR     ;If yes, branch to exit (2/3)
   578 00:F923: C9 50                        CMP     #$50            ;Test for Ready bits on (2)
   579 00:F925: D0 F5                        BNE     TST_IDE_RDY     ;If not, loop back until ready (2/3)
   580 00:F927: 18                           CLC                     ;Safety to ensure Carry is not set (2)
   581 00:F928: 60                           RTS                     ;Return to Caller (6)
   582 00:F929: 38           TST_IDE_ERR     SEC                     ;Set Carry to indicate Error bit set (2)
   583 00:F92A: 60                           RTS                     ;Return to Caller (6)
   584                        ;
   585                        ;**************************************************************************************************
   586                        ;Delay Routines: SET_DLY sets up the MSDELAY value and also sets the 16-bit Long Delay
  Mon Apr  3 2023 13:43                                                                                                    Page 17


   587                        ; On entry, A Reg = 10-millisecond count, X Reg = High multiplier, Y Reg = Low multiplier
   588                        ; these values are used by the EXE_MSDLY and EXE_LGDLY routines. Minimum delay is 10ms
   589                        ; values for MSDELAY are $00-$FF ($00 = 256 times)
   590                        ; values for Long Delay are $0000-$FFFF (0-65535 times MSDELAY)
   591                        ; longest delay is 65,535*256*10ms = 16,776,960 * 0.01 = 167,769.60 seconds
   592                        ;
   593                        ;NOTE: All delay execution routines preserve registers (EXE_MSDLY, EXE_LGDLY, EXE_XLDLY)
   594                        ;
   595 00:F92B: 85 ED        SET_DLY         STA     SETMS           ;Save Millisecond count (3)
   596 00:F92D: 84 EE                        STY     DELLO           ;Save Low multiplier (3)
   597 00:F92F: 86 EF                        STX     DELHI           ;Save High multiplier (3)
   598 00:F931: 60                           RTS                     ;Return to caller (6)
   599                        ;
   600                        ;EXE MSDELAY routine is the core delay routine. It sets the MSDELAY count value from the
   601                        ; SETMS variable, enables the MATCH flag, then waits for the MATCH flag to clear.
   602                        ;
   603 00:F932: 48           EXE_MSDLY       PHA                     ;Save A Reg (3)
   604 00:F933: F7 FF                        SMB7    MATCH           ;Set MATCH flag bit (5)
   605 00:F935: A5 ED                        LDA     SETMS           ;Get delay seed value (3)
   606 00:F937: 85 EC                        STA     MSDELAY         ;Set MS delay value (3)
   607                        ;
   608 00:F939: FF FF FD     MATCH_LP        BBS7    MATCH,MATCH_LP  ;Test MATCH flag, loop until cleared (5,6)
   609 00:F93C: 68                           PLA                     ;Restore A Reg (4)
   610 00:F93D: 60                           RTS                     ;Return to caller (6)
   611                        ;
   612                        ;EXE LONG Delay routine is the 16-bit multiplier for the MSDELAY routine.
   613                        ; It loads the 16-bit count from DELLO/DELHI, then loops the MSDELAY routine
   614                        ; until the 16-bit count is decremented to zero.
   615                        ;
   616 00:F93E: DA           EXE_LGDLY       PHX                     ;Save X Reg (3)
   617 00:F93F: 5A                           PHY                     ;Save Y Reg (3)
   618 00:F940: A6 EF                        LDX     DELHI           ;Get high byte count (3)
   619 00:F942: E8                           INX                     ;Increment by one (checks for $00 vs $FF) (2)
   620 00:F943: A4 EE                        LDY     DELLO           ;Get low byte count (3)
   621 00:F945: F0 06                        BEQ     SKP_DLL         ;If zero, skip to high count (2/3)
   622 00:F947: 20 32 F9     DO_DLL          JSR     EXE_MSDLY       ;Call millisecond delay (6)
   623 00:F94A: 88                           DEY                     ;Decrement low count (2)
   624 00:F94B: D0 FA                        BNE     DO_DLL          ;Branch back until done (2/3)
   625                        ;
   626 00:F94D: CA           SKP_DLL         DEX                     ;Decrement high byte index (2)
   627 00:F94E: D0 F7                        BNE     DO_DLL          ;Loop back to D0_DLL (will run 256 times) (2/3)
   628 00:F950: 7A                           PLY                     ;Restore Y Reg (4)
   629 00:F951: FA                           PLX                     ;Restore X Reg (4)
   630 00:F952: 60                           RTS                     ;Return to caller (6)
   631                        ;
   632                        ;**************************************************************************************************
   633                        ;COUNTER BENCHMARK TIMING ROUTINES
   634                        ; To enable a level of benchmarking, three routines are part of C02BIOS version 4.0x
   635                        ; Using the existing 10ms Jiffy Clock, three bytes of Page zero are used to hold variables;
   636                        ; MS10_CNT - a 10ms count variable for 0.01 resolution of timing - resets at 100 counts (1 second)
   637                        ; SECL_CNT - a low byte seconds count
   638                        ; SECH_CNT - a high byte seconds count
   639                        ; This provides up to 65,535.99 seconds of timing with 0.01 seconds resolution
   640                        ; - NOTE: the count variables reset to zero after 65,535.99 seconds!
   641                        ;
   642                        ;CNT_INIT is used to zero the timing pointers and start the benchmark timer
   643                        ;CNT_STRT is used to start the timing by setting bit 6 of the MATCH flag
   644                        ;CNT_STOP is used to stop the timing by clearing bit 6 of the MATCH flag
   645                        ; the interrupt handler for the DUART timer increments the timing variables when bit 6 of the
   646                        ; MATCH flag is active.
   647                        ;
   648 00:F953: 67 FF        CNT_INIT        RMB6    MATCH           ;Clear bit 6 of MATCH flag, ensure timing is disabled (5)
   649 00:F955: 64 F0                        STZ     MS10_CNT        ;Zero 10ms timing count (3)
  Mon Apr  3 2023 13:43                                                                                                    Page 18


   650 00:F957: 64 F1                        STZ     SECL_CNT        ;Zero low byte of seconds timing count (3)
   651 00:F959: 64 F2                        STZ     SECH_CNT        ;Zero high byte of seconds timing count (3)
   652                        ;
   653 00:F95B: E7 FF        CNT_STRT        SMB6    MATCH           ;Set bit 6 of MATCH flag to enable timing (5)
   654 00:F95D: 60                           RTS                     ;Return to caller (6)
   655                        ;
   656 00:F95E: 67 FF        CNT_STOP        RMB6    MATCH           ;Clear bit 6 of MATCH flag to disable timing (5)
   657 00:F960: 60                           RTS                     ;Return to caller (6)
   658                        ;
   659                        ;**************************************************************************************************
   660                        ;START of Realtime Clock Routines to access NVRAM                                                 *
   661                        ;**************************************************************************************************
   662                        ;
   663                        ;RTC Routines to Read and Write Non-Volatile RAM - 256 Bytes
   664                        ; To use either routine, the starting memory address needs to be
   665                        ; loaded into the A/Y registers. A reg = low byte, Y reg = high byte
   666                        ;
   667 00:F961: 20 7F F9     RTC_NVRD        JSR     RTC_NVSET       ;Setup for transfer (6)
   668 00:F964: AD 73 FE     RTC_RD_LOOP     LDA     RTC_RAM_DATA    ;Get NVRAM Data (4)
   669 00:F967: 91 F9                        STA     (BIOS_XFERL),Y  ;Save into RAM (6)
   670 00:F969: C8                           INY                     ;Increment Y Index (2)
   671 00:F96A: D0 F8                        BNE     RTC_RD_LOOP     ;Loop back reading NVRAM (2/3)
   672 00:F96C: 80 0B                        BRA     CLEAR_BMI       ;Clear Burst Mode, exit (3)
   673                        ;
   674 00:F96E: 20 7F F9     RTC_NVWR        JSR     RTC_NVSET       ;Setup for transfer (6)
   675 00:F971: B1 F9        RTC_WR_LOOP     LDA     (BIOS_XFERL),Y  ;Get RAM Data (5)
   676 00:F973: 8D 73 FE                     STA     RTC_RAM_DATA    ;Write to NVRAM (4)
   677 00:F976: C8                           INY                     ;Increment Y Index (2)
   678 00:F977: D0 F8                        BNE     RTC_WR_LOOP     ;Loop back writing NVRAM (2/3)
   679 00:F979: A9 20        CLEAR_BMI       LDA     #%00100000      ;Get Burst Mode Increment bit (2)
   680 00:F97B: 1C 6F FE                     TRB     RTC_CONTROL_B   ;Clear Burst Mode for NVRAM (6)
   681 00:F97E: 60                           RTS                     ;Return to caller (6)
   682                        ;
   683 00:F97F: 85 F9        RTC_NVSET       STA     BIOS_XFERL      ;Save Low Address location (3)
   684 00:F981: 84 FA                        STY     BIOS_XFERH      ;Save High Address location (3)
   685 00:F983: A9 20                        LDA     #%00100000      ;Get Burst Mode Increment bit (2)
   686 00:F985: 0C 6F FE                     TSB     RTC_CONTROL_B   ;Set Burst Mode for NVRAM (6)
   687 00:F988: 9C 70 FE                     STZ     RTC_RAM_ADDR    ;Set NVRAM Address to Zero (4)
   688 00:F98B: A0 00                        LDY     #$00            ;Zero Y reg - Index (2)
   689 00:F98D: 60                           RTS                     ;Return to caller (6)
   690                        ;
   691                        ;**************************************************************************************************
   692                        ;Initializing the SC28L92 DUART as a Console.
   693                        ;An anomaly in the W65C02 processor requires a different approach in programming the SC28L92
   694                        ; for proper setup/operation. The SC28L92 uses three Mode Registers which are accessed at the same
   695                        ; register in sequence. There is a command that Resets the Mode Register pointer (to MR0) that is
   696                        ; issued first. Then MR0/1/2 are loaded in sequence. The problem with the W65C02 is a false read of
   697                        ; the register when using indexed addressing (i.e., STA UART_REGISTER,X). This results in the Mode
   698                        ; Register pointer being moved to the next register, so the write to next MRx never happens. While
   699                        ; the indexed list works fine for all other register functions/commands, the loading of the
   700                        ; Mode Registers need to be handled separately.
   701                        ;
   702                        ;NOTE: the W65C02 will function normally "if" a page boundary is crossed as part of the STA
   703                        ; (i.e., STA $FDFF,X) where the value of the X Register is high enough to cross the page boundary.
   704                        ; Programming in this manner would be confusing and require modification if the base I/O address
   705                        ; is changed for a different hardware I/O map.
   706                        ;
   707                        ;There are two routines called to setup the 28L92 DUART:
   708                        ;
   709                        ;The first routine is a RESET of the DUART.
   710                        ; It issues the following sequence of commands:
   711                        ;  1- Reset Break Change Interrupts
   712                        ;  2- Reset Receivers
  Mon Apr  3 2023 13:43                                                                                                    Page 19


   713                        ;  3- Reset Transmitters
   714                        ;  4- Reset All errors
   715                        ;
   716                        ;The second routine initializes the 28L92 DUART for operation. It uses two tables of data; one for
   717                        ; the register offset and the other for the register data. The table for register offsets is
   718                        ; maintained in ROM. The table for register data is copied to page $03, making it soft data. If
   719                        ; needed, operating parameters can be altered and the DUART re-initialized via the ROM routine.
   720                        ;
   721                        ; Note: A hardware reset will reset the SC28L92 and the default ROM config will be initialized.
   722                        ; Also note that the Panic routine invoked by a NMI trigger will also reset the DUART to the
   723                        ; default ROM config.
   724                        ;
   725 00:F98E: 20 C2 F9     INIT_IO         JSR     RESET_28L92     ;Reset of SC28L92 DUART (both channels) (6)
   726 00:F991: A9 64                        LDA     #DF_TICKS       ;Get divider for jiffy clock (100x10ms = 1 second) (2)
   727 00:F993: 85 E4                        STA     TICKS           ;Preload TICK count (3)
   728                        ;
   729                        ;This routine sets the initial operating mode of the DUART
   730                        ;
   731 00:F995: 78           INIT_28L92      SEI                     ;Disable interrupts (2)
   732                        ;
   733 00:F996: A2 0F                        LDX     #INIT_DUART_E-INIT_DUART ;Get the Init byte count (2)
   734 00:F998: BD 1F 03     28L92_INT       LDA     LOAD_28L92-1,X  ;Get Data for 28L92 Register (4)
   735 00:F99B: BC E4 FE                     LDY     INIT_OFFSET-1,X ;Get Offset for 28L92 Register (4)
   736 00:F99E: 99 80 FE                     STA     SC28L92_BASE,Y  ;Store Data to selected register (5)
   737 00:F9A1: CA                           DEX                     ;Decrement count (2)
   738 00:F9A2: D0 F4                        BNE     28L92_INT       ;Loop back until all registers are loaded (2/3)
   739                        ;
   740                        ; Mode Registers are NOT reset to MR0 by above INIT_28L92!
   741                        ; The following resets the MR pointers for both channels, then sets the MR registers
   742                        ; for each channel. Note: the MR index is incremented to the next location after the write.
   743                        ; NOTE: These writes can NOT be done via indexed addressing modes!
   744                        ;
   745 00:F9A4: A9 B0                        LDA     #%10110000      ;Get mask for MR0 Reset (2)
   746 00:F9A6: 8D 82 FE                     STA     UART_COMMAND_A  ;Reset Pointer for Port A (4)
   747 00:F9A9: 8D 8A FE                     STA     UART_COMMAND_B  ;Reset Pointer for Port B (4)
   748                        ;
   749 00:F9AC: A2 03                        LDX     #$03            ;Set index for 3 bytes to xfer (2)
   750 00:F9AE: BD 2F 03     MR_LD_LP        LDA     LOAD_28L92+15,X ;Get MR data for Port A (4)
   751 00:F9B1: 8D 80 FE                     STA     UART_MODEREG_A  ;Send to 28L92 Port A (4)
   752 00:F9B4: BD 32 03                     LDA     LOAD_28L92+18,X ;Get MR data for Port B (4)
   753 00:F9B7: 8D 88 FE                     STA     UART_MODEREG_B  ;Send to 28L92 Port B (4)
   754 00:F9BA: CA                           DEX                     ;Decrement index to next data (2)
   755 00:F9BB: D0 F1                        BNE     MR_LD_LP        ;Branch back till done (2/3)
   756                        ;
   757 00:F9BD: 58                           CLI                     ;Enable interrupts (2)
   758                        ;
   759                        ; Start Counter/Timer
   760                        ;
   761 00:F9BE: AD 8E FE                     LDA     UART_START_CNT  ;Read register to start counter/timer (4)
   762 00:F9C1: 60                           RTS                     ;Return to caller (6)
   763                        ;
   764                        ; This routine does a Reset of the SC28L92
   765                        ;
   766 00:F9C2: A2 04        RESET_28L92     LDX     #UART_RDATAE-UART_RDATA1 ;Get the Reset commands byte count (2)
   767 00:F9C4: BD E0 FE     UART_RES1       LDA     UART_RDATA1-1,X ;Get Reset commands (4)
   768 00:F9C7: 8D 82 FE                     STA     UART_COMMAND_A  ;Send to UART A CR (4)
   769 00:F9CA: 8D 8A FE                     STA     UART_COMMAND_B  ;Send to UART B CR (4)
   770 00:F9CD: CA                           DEX                     ;Decrement the command list index (2)
   771 00:F9CE: D0 F4                        BNE     UART_RES1       ;Loop back until all are sent (2/3)
   772 00:F9D0: 60                           RTS                     ;Return to caller (6)
   773                        ;
   774                        ;**************************************************************************************************
   775                        ;START OF PANIC ROUTINE
  Mon Apr  3 2023 13:43                                                                                                    Page 20


   776                        ;The Panic routine is for debug of system problems, i.e., a crash. The hardware design requires a
   777                        ; debounced NMI trigger button which is manually operated when the system crashes or malfunctions.
   778                        ;
   779                        ;User presses the NMI (panic) button. The NMI vectored routine will perform the following tasks:
   780                        ; 1- Save CPU registers in page zero locations
   781                        ; 2- Reset the MicroDrive and disable interrupts
   782                        ; 3- Clear all Console I/O buffer pointers
   783                        ; 4- Call the ROM routines to init the vectors and config data (page $03)
   784                        ; 5- Call the ROM routines to reset/init the DUART (SC28L92)
   785                        ; 6- Enter the Monitor via the warm start vector
   786                        ;
   787                        ; Note: The additional hardware detection (RTC/IDE) are NOT executed with the Panic routine!
   788                        ; The interrupt vectors are restored without including the additional ISR for the IDE controller.
   789                        ;
   790                        ; Note: no memory is cleared except the required pointers/vectors to restore the system.
   791                        ;
   792 00:F9D1: 78           NMI_VECTOR      SEI                     ;Disable interrupts (2)
   793 00:F9D2: 85 D6                        STA     AREG            ;Save A Reg (3)
   794 00:F9D4: 86 D5                        STX     XREG            ;Save X Reg (3)
   795 00:F9D6: 84 D4                        STY     YREG            ;Save Y Reg (3)
   796 00:F9D8: 68                           PLA                     ;Get Processor Status (4)
   797 00:F9D9: 85 D2                        STA     PREG            ;Save in PROCESSOR STATUS preset/result (3)
   798 00:F9DB: BA                           TSX                     ;Get Stack pointer (4)
   799 00:F9DC: 86 D3                        STX     SREG            ;Save STACK POINTER (3)
   800 00:F9DE: 68                           PLA                     ;Pull RETURN address from STACK (4)
   801 00:F9DF: 85 D0                        STA     PCL             ;Store Low byte (3)
   802 00:F9E1: 68                           PLA                     ;Pull high byte (4)
   803 00:F9E2: 85 D1                        STA     PCH             ;Store High byte (3)
   804                        ;
   805 00:F9E4: A9 06                        LDA     #%00000110      ;Get mask for MicroDrive Reset/IRQ disable (2)
   806 00:F9E6: 8D 76 FE                     STA     IDE_DEV_CTRL    ;Send to MicroDrive (4)
   807                        ;
   808 00:F9E9: 9C 85 FE                     STZ     UART_IMR        ;Disable ALL interrupts from UART (4)
   809                        ;
   810 00:F9EC: A2 0C                        LDX     #$0C            ;Set count for 12 (2)
   811 00:F9EE: 74 D6        PAN_LP1         STZ     ICNT_A-1,X      ;Clear DUART I/O pointers (3)
   812 00:F9F0: CA                           DEX                     ;Decrement index (2)
   813 00:F9F1: D0 FB                        BNE     PAN_LP1         ;Branch back till done (2/3)
   814                        ;
   815 00:F9F3: 20 9C FF                     JSR     INIT_PG03       ;Xfer default Vectors/HW Config to $0300 (6)
   816 00:F9F6: 20 8E F9                     JSR     INIT_IO         ;Reset and Init the UART for Console (6)
   817                        ;
   818 00:F9F9: A9 02                        LDA     #%00000010      ;Get mask for MicroDrive Reset off (2)
   819 00:F9FB: 8D 76 FE                     STA     IDE_DEV_CTRL    ;Send to MicroDrive (4)
   820                        ;
   821 00:F9FE: 6C 06 03     DO_NMI0         JMP     (NMIRTVEC0)     ;Jump to NMI Return Vector (Monitor Warm Start) (6)
   822                        ;
   823                        ;**************************************************************************************************
   824                        ;
   825                        ;BRK/IRQ Interrupt service routines
   826                        ;The pre-process routine located in page $FF soft-vectors to INTERUPT0/BRKINSTR0 below
   827                        ;       These are the routines that handle BRK and IRQ functions
   828                        ;       The BRK handler saves CPU details for register display
   829                        ;       - A Monitor can provide a disassembly of the last executed instruction
   830                        ;       - A Received Break is also handled here (ExtraPutty/Windows or Serial/OSX)
   831                        ;
   832                        ; SC28L92 handler
   833                        ;       The 28L92 IRQ routine handles Transmit, Receive, Timer and Received-Break interrupts
   834                        ;       - Transmit and Receive each have a 128 byte circular FIFO buffer in memory per channel
   835                        ;       - Xmit IRQ is controlled (On/Off) by the handler and the CHROUT(2) routine
   836                        ;
   837                        ; The 28L92 Timer resolution is 10ms and used as a Jiffy Clock for RTC, delays and benchmarking
   838                        ;
  Mon Apr  3 2023 13:43                                                                                                    Page 21


   839                        ;**************************************************************************************************
   840                        ;
   841                        ;BIOS routines to handle interrupt-driven I/O for the SC28L92
   842                        ;NOTE: IP0 Pin is used for RTS, which is automatically handled in the chip. As a result,
   843                        ; the upper 2 bits of the ISR are not used in the handler. The Lower 5 bits are used, but
   844                        ; the lower two are used to determine when to disable transmit after the buffer is empty.
   845                        ;
   846                        ;The DUART_ISR bits are defined as follows:
   847                        
   848                        ; Bit7          ;Input Change Interrupt
   849                        ; Bit6          ;Change Break B Interrupt
   850                        ; Bit5          ;RxRDY B Interrupt
   851                        ; Bit4          ;TxRDY B Interrupt
   852                        ; Bit3          ;Counter Ready Interrupt
   853                        ; Bit2          ;Change Break A Interrupt
   854                        ; Bit1          ;RxRDY A Interrupt
   855                        ; Bit0          ;TxRDY A Interrupt
   856                        ;
   857                        ; SC8L92 uses all bits in the Status Register!
   858                        ; - for Receive Buffer full, we set a bit in the SC28L92 Misc. Register, one for each Port.
   859                        ; Note that the Misc. Register in the SC28L92 is a free byte for storing the flags, as it's
   860                        ; not used when the DUART is configured in Intel mode! Freebie Register for us to use ;-)
   861                        ;
   862                        ; BOTE: The entry point for the BRK/IRQ handler is below at label INTERUPT0
   863                        ;
   864                        ;**************************************************************************************************
   865                        ;
   866                        ;ISR Routines for SC28L92 Port B
   867                        ;
   868                        ; The operation is the same as Port A below, sans the fact that the Break detection only resets
   869                        ; the DUART channel and returns, while Port A uses Break detection for other functions within
   870                        ; the BIOS structure, and processes the BRK routine shown further down.
   871                        ;
   872 00:FA01: A4 DD        UARTB_RCV       LDY     ICNT_B          ;Get input buffer count (3)
   873 00:FA03: 30 41                        BMI     BUFFUL_B        ;Check against limit ($80), branch if full (2/3)
   874                        ;
   875 00:FA05: AD 89 FE     UARTB_RCVLP     LDA     UART_STATUS_B   ;Get Status Register (4)
   876 00:FA08: 89 01                        BIT     #%00000001      ;Check RxRDY active (2)
   877 00:FA0A: F0 10                        BEQ     UARTB_CXMT      ;If RxRDY not set, FIFO is empty, check Xmit (2/3)
   878                        
   879 00:FA0C: AD 8B FE                     LDA     UART_RECEIVE_B  ;Else, get data from 28L92 (4)
   880 00:FA0F: A4 DF                        LDY     ITAIL_B         ;Get the tail pointer to buffer (3)
   881 00:FA11: 99 00 04                     STA     IBUF_B,Y        ;Store into buffer (5)
   882 00:FA14: E6 DF                        INC     ITAIL_B         ;Increment tail pointer (5)
   883 00:FA16: 77 DF                        RMB7    ITAIL_B         ;Strip off bit 7, 128 bytes only (5)
   884 00:FA18: E6 DD                        INC     ICNT_B          ;increment data count (5)
   885 00:FA1A: 10 E9                        BPL     UARTB_RCVLP     ;If input buffer not full, check for more FIFO data (2/3)
   886                        ;
   887 00:FA1C: AD 85 FE     UARTB_CXMT      LDA     UART_ISR        ;Get 28L92 ISR Reg (4)
   888 00:FA1F: 89 10                        BIT     #%00010000      ;Check for Xmit B active (2)
   889 00:FA21: F0 20                        BEQ     REGEXT_B        ;Exit if inactive (2/3)
   890                        ;
   891                        ; To take advantage of the onboard FIFO, we test the TxRDY bit in the Status Register.
   892                        ; If the bit is set, then there is more room in the FIFO. The ISR routine here will
   893                        ; attempt to fill the FIFO from the Output Buffer. This saves processing time in the
   894                        ; ISR itself.
   895                        ;
   896 00:FA23: A5 E0        UARTB_XMT       LDA     OCNT_B          ;Get output buffer count, any data to xmit? (3)
   897 00:FA25: F0 17                        BEQ     NODATA_B        ;If zero, no data left, turn off xmit (2/3)
   898                        ;
   899 00:FA27: AD 89 FE     UARTB_XMTLP     LDA     UART_STATUS_B   ;Get Status Register (4)
   900 00:FA2A: 89 04                        BIT     #%00000100      ;Check TxRDY active (2)
   901 00:FA2C: F0 15                        BEQ     REGEXT_B        ;If TxRDY not set, FIFO is full, exit ISR (2/3)
  Mon Apr  3 2023 13:43                                                                                                    Page 22


   902                        ;
   903 00:FA2E: A4 E1                        LDY     OHEAD_B         ;Get the head pointer to buffer (3)
   904 00:FA30: B9 80 04                     LDA     OBUF_B,Y        ;Get the next data (4)
   905 00:FA33: 8D 8B FE                     STA     UART_TRANSMIT_B ;Send the data to 28L92 (4)
   906 00:FA36: E6 E1                        INC     OHEAD_B         ;Increment head pointer (5)
   907 00:FA38: 77 E1                        RMB7    OHEAD_B         ;Strip off bit 7, 128 bytes only (5)
   908 00:FA3A: C6 E0                        DEC     OCNT_B          ;Decrement counter (5)
   909 00:FA3C: D0 E9                        BNE     UARTB_XMTLP     ;If more data, loop back to send it (2/3)
   910                        ;
   911                        ;No more buffer data to send, check SC28L92 TxEMT and disable transmit if empty.
   912                        ; Note: If the TxEMT bit is set, then the FIFO is empty and all data has been sent.
   913                        ;
   914 00:FA3E: A0 08        NODATA_B        LDY     #%00001000      ;Else, get mask for xmit off (2)
   915 00:FA40: 8C 8A FE                     STY     UART_COMMAND_B  ;Turn off xmit (4)
   916 00:FA43: 6C 0A 03     REGEXT_B        JMP     (IRQRTVEC0)     ;Return to Exit/ROM IRQ handler (6)
   917                        ;
   918 00:FA46: A0 10        BUFFUL_B        LDY     #%00010000      ;Get Mask for Buffer full (2)
   919 00:FA48: 8C 8C FE                     STY     UART_MISC       ;Save into 28L92 Misc. Register (4)
   920 00:FA4B: 80 F6                        BRA     REGEXT_B        ;Exit IRQ handler (3)
   921                        ;
   922                        ;Received Break handler for Port B
   923                        ;
   924 00:FA4D: AD 89 FE     UARTB_BRK       LDA     UART_STATUS_B   ;Get DUART Status Register (4)
   925 00:FA50: 30 0D                        BMI     BREAKEY_B       ;If bit 7 set, received Break was detected (2/3)
   926                        ;
   927                        ; If a received Break was not the cause, we should reset the DUART Port as the cause
   928                        ; could have been a receiver error, i.e., parity or framing
   929                        ;
   930 00:FA52: A2 05                        LDX     #UART_RDATAE-UART_RDATA ;Get index count (2)
   931 00:FA54: BD DF FE     UARTB_RST1      LDA     UART_RDATA-1,X  ;Get Reset commands (4)
   932 00:FA57: 8D 8A FE                     STA     UART_COMMAND_B  ;Send to DUART CR (4)
   933 00:FA5A: CA                           DEX                     ;Decrement the command list (2)
   934 00:FA5B: D0 F7                        BNE     UARTB_RST1      ;Loop back until all are sent (2/3)
   935 00:FA5D: 80 E4                        BRA     REGEXT_B        ;Exit (3)
   936                        ;
   937                        ; A received Break was the cause. Just reset the receiver and return.
   938                        ;
   939 00:FA5F: A9 40        BREAKEY_B       LDA     #%01000000      ;Get Reset Received Break command (2)
   940 00:FA61: 8D 8A FE                     STA     UART_COMMAND_B  ;Send to DUART to reset (4)
   941 00:FA64: A9 50                        LDA     #%01010000      ;Get Reset Break Interrupt command (2)
   942 00:FA66: 8D 8A FE                     STA     UART_COMMAND_B  ;Send to DUART to reset (4)
   943 00:FA69: 80 D8                        BRA     REGEXT_B        ;Exit (3)
   944                        ;
   945                        ;**************************************************************************************************
   946                        ;
   947                        ;This is the IRQ handler entry point for the SC28L92 DUART.
   948                        ; This is the first IRQ handler unless an IDE device is found during cold start.
   949                        ; By default, it will take 25 clock cycles to arrive here after an interrupt is
   950                        ; generated. If an IDE device is present, the IDE handler will be processed
   951                        ; first. If no IDE interrupt is active, it will take an additional 33 cycles to
   952                        ; arrive here.
   953                        ;
   954                        ; C02BIOS 4.02 has re-arranged the interrupt handler for the SC28L92 DUART.
   955                        ; - The second port is checked first for active data, as it could be used for a
   956                        ; - high-speed transfer from another device. The first port is used for the
   957                        ; - console (which can also be used for data transfer) and is checked second.
   958                        ; - The Counter/Timer is checked first, to maintain benchmark and delay accuracy.
   959                        ;
   960                        INTERUPT0                               ;Interrupt 0 to handle the SC28L92 DUART
   961 00:FA6B: AD 85 FE                     LDA     UART_ISR        ;Get the UART Interrupt Status Register (4)
   962 00:FA6E: F0 1E                        BEQ     REGEXT_0        ;If no bits are set, exit handler (2/3)
   963                        ;
   964 00:FA70: 89 08                        BIT     #%00001000      ;Test for Counter ready (RTC) (2)
  Mon Apr  3 2023 13:43                                                                                                    Page 23


   965 00:FA72: D0 1D                        BNE     UART_RTC        ;If yes, go increment RTC variables (2/3)
   966                        ;
   967 00:FA74: 89 40                        BIT     #%01000000      ;Test for Break on B (2)
   968 00:FA76: D0 D5                        BNE     UARTB_BRK       ;If yes, Reset the DUART receiver (2/3)
   969                        ;
   970 00:FA78: 89 20                        BIT     #%00100000      ;Test for RHR B having data (2)
   971 00:FA7A: D0 85                        BNE     UARTB_RCV       ;If yes, put the data in the buffer (2/3)
   972                        ;
   973 00:FA7C: 89 10                        BIT     #%00010000      ;Test for THR B ready to receive data (2)
   974 00:FA7E: D0 A3                        BNE     UARTB_XMT       ;If yes, get data from the buffer (2/3)
   975                        ;
   976 00:FA80: 89 04                        BIT     #%00000100      ;Test for Break on A (2)
   977 00:FA82: D0 5C                        BNE     UARTA_BRK       ;If yes, Reset the DUART receiver (2/3)
   978                        ;
   979 00:FA84: 89 02                        BIT     #%00000010      ;Test for RHR A having data (2)
   980 00:FA86: D0 0C                        BNE     UARTA_RCV       ;If yes, put the data in the buffer (2/3)
   981                        ;
   982 00:FA88: 89 01                        BIT     #%00000001      ;Test for THR A ready to receive data (2)
   983 00:FA8A: D0 2A                        BNE     UARTA_XMT       ;If yes, get data from the buffer (2/3)
   984                        ;
   985                        ; if none of the above bits caused the IRQ, the only bit left is the change input port.
   986                        ; just save it in the temp IRT register in page zero and exit.
   987                        ;
   988 00:FA8C: 85 E3                        STA     UART_IRT        ;Save the 28L92 ISR for later use (3)
   989 00:FA8E: 6C 0A 03     REGEXT_0        JMP     (IRQRTVEC0)     ;Return to Exit/ROM IRQ handler (6)
   990                        ;
   991 00:FA91: 4C 32 FB     UART_RTC        JMP     UART_RTC0       ;Jump to RTC handler (3)
   992                        ;
   993                        ;**************************************************************************************************
   994                        ;
   995                        ;ISR Routines for SC28L92 Port A
   996                        ;
   997                        ; The Receive Buffer is checked first to ensure there is open space in the buffer.
   998                        ; By loadng the input count, bit7 will be set if it is full, which will set the "N"
   999                        ; flag in the CPU status register. If this is the case, we exit to BUFFUL_A and set
  1000                        ; a bit the SC28L92 Misc. Register. If the buffer has space, we continue.
  1001                        ; 
  1002                        ; To take advantage of the onboard FIFO, we test the RxRDY bit in the Status Register.
  1003                        ; If the bit is set, the FIFO has data and the routine moves data from the FIFO into
  1004                        ; the Receive buffer. We loop back and contnue moving data from the FIFO to the buffer
  1005                        ; until the RxRDY bit is cleared (FIFO empty). If the FIFO is empty, we branch and
  1006                        ; check for a pending Transmit interrupt, just to save some ISR time.
  1007                        ;
  1008                        ; NOTE: the receiver is configured to use the Watchdog function. This will generate a
  1009                        ; receiver interrupt within 64 bit times once data is received (and the FIFO has not
  1010                        ; reached it's configured fill level). This provides the required operation for use
  1011                        ; as a console, as single character commands are common and would not fill the FIFO,
  1012                        ; which generates an interrupt based on the configured FIFO fill level.
  1013                        ;
  1014 00:FA94: A4 D7        UARTA_RCV       LDY     ICNT_A          ;Get input buffer count (3)
  1015 00:FA96: 30 41                        BMI     BUFFUL_A        ;Check against limit ($80), branch if full (2/3)
  1016                        ;
  1017 00:FA98: AD 81 FE     UARTA_RCVLP     LDA     UART_STATUS_A   ;Get Status Register (4)
  1018 00:FA9B: 89 01                        BIT     #%00000001      ;Check RxRDY active (2)
  1019 00:FA9D: F0 10                        BEQ     UARTA_CXMT      ;If RxRDY not set, FIFO is empty, check Xmit (2/3)
  1020                        
  1021 00:FA9F: AD 83 FE                     LDA     UART_RECEIVE_A  ;Else, get data from 28L92 (4)
  1022 00:FAA2: A4 D9                        LDY     ITAIL_A         ;Get the tail pointer to buffer (3)
  1023 00:FAA4: 99 00 02                     STA     IBUF_A,Y        ;Store into buffer (5)
  1024 00:FAA7: E6 D9                        INC     ITAIL_A         ;Increment tail pointer (5)
  1025 00:FAA9: 77 D9                        RMB7    ITAIL_A         ;Strip off bit 7, 128 bytes only (5)
  1026 00:FAAB: E6 D7                        INC     ICNT_A          ;Increment input bufffer count (5)
  1027 00:FAAD: 10 E9                        BPL     UARTA_RCVLP     ;If input buffer not full, check for more FIFO data (2/3)
  Mon Apr  3 2023 13:43                                                                                                    Page 24


  1028                        ;
  1029 00:FAAF: AD 85 FE     UARTA_CXMT      LDA     UART_ISR        ;Get 28L92 ISR Reg (4)
  1030 00:FAB2: 89 01                        BIT     #%00000001      ;Check for Xmit A active (2)
  1031 00:FAB4: F0 20                        BEQ     REGEXT_A        ;Exit if inactive, else drop into Xmit code (2/3)
  1032                        ;
  1033                        ;To take advantage of the onboard FIFO, we test the TxRDY bit in the Status Register.
  1034                        ; If the bit is set, then there is more room in the FIFO. The ISR routine here will
  1035                        ; attempt to fill the FIFO from the Output Buffer. This saves processing time in the
  1036                        ; ISR itself.
  1037                        ;
  1038 00:FAB6: A5 DA        UARTA_XMT       LDA     OCNT_A          ;Get output buffer count, any data to xmit? (3)
  1039 00:FAB8: F0 17                        BEQ     NODATA_A        ;If zero, no data left, turn off xmit (2/3)
  1040                        ;
  1041 00:FABA: AD 81 FE     UARTA_XMTLP     LDA     UART_STATUS_A   ;Get Status Register (4)
  1042 00:FABD: 89 04                        BIT     #%00000100      ;Check TxRDY active (2)
  1043 00:FABF: F0 15                        BEQ     REGEXT_A        ;If TxRDY not set, FIFO is full, exit ISR (2/3)
  1044                        ;
  1045 00:FAC1: A4 DB                        LDY     OHEAD_A         ;Get the head pointer to buffer (3)
  1046 00:FAC3: B9 80 02                     LDA     OBUF_A,Y        ;Get the next data (4)
  1047 00:FAC6: 8D 83 FE                     STA     UART_TRANSMIT_A ;Send the data to 28L92 (4)
  1048 00:FAC9: E6 DB                        INC     OHEAD_A         ;Increment head pointer (5)
  1049 00:FACB: 77 DB                        RMB7    OHEAD_A         ;Strip off bit 7, 128 bytes only (5)
  1050 00:FACD: C6 DA                        DEC     OCNT_A          ;Decrement output buffer count (5)
  1051 00:FACF: D0 E9                        BNE     UARTA_XMTLP     ;If more data, loop back to send it (2/3)
  1052                        ;
  1053                        ;No more buffer data to send, check SC28L92 TxEMT and disable transmit if empty.
  1054                        ; Note: If the TxEMT bit is set, then the FIFO is empty and all data has been sent.
  1055                        ;
  1056 00:FAD1: A0 08        NODATA_A        LDY     #%00001000      ;Else, get mask for xmit off (2)
  1057 00:FAD3: 8C 82 FE                     STY     UART_COMMAND_A  ;Turn off xmit (4)
  1058 00:FAD6: 6C 0A 03     REGEXT_A        JMP     (IRQRTVEC0)     ;Return to Exit/ROM IRQ handler (6)
  1059                        ;
  1060 00:FAD9: A0 01        BUFFUL_A        LDY     #%00000001      ;Get Mask for Buffer full (2)
  1061 00:FADB: 8C 8C FE                     STY     UART_MISC       ;Save into 28L92 Misc. Register (4)
  1062 00:FADE: 80 F6                        BRA     REGEXT_A        ;Exit IRQ handler (3)
  1063                        ;
  1064                        ;Received Break handler for Port A
  1065                        ;
  1066 00:FAE0: AD 81 FE     UARTA_BRK       LDA     UART_STATUS_A   ;Get DUART Status Register (4)
  1067 00:FAE3: 30 0D                        BMI     BREAKEY_A       ;If bit 7 set, received Break was detected (2/3)
  1068                        ;
  1069                        ; If a received Break was not the cause, we should reset the DUART Port as the cause
  1070                        ; could have been a receiver error, i.e., parity or framing
  1071                        ;
  1072 00:FAE5: A2 05                        LDX     #UART_RDATAE-UART_RDATA ;Get index count (2)
  1073 00:FAE7: BD DF FE     UARTA_RST1      LDA     UART_RDATA-1,X  ;Get Reset commands (4)
  1074 00:FAEA: 8D 82 FE                     STA     UART_COMMAND_A  ;Send to DUART CR (4)
  1075 00:FAED: CA                           DEX                     ;Decrement the command list (2)
  1076 00:FAEE: D0 F7                        BNE     UARTA_RST1      ;Loop back until all are sent (2/3)
  1077 00:FAF0: 80 E4                        BRA     REGEXT_A        ;Exit (3)
  1078                        ;
  1079                        ; A received Break was the cause. Reset the receiver and process the BRK routine.
  1080                        ;
  1081 00:FAF2: A9 40        BREAKEY_A       LDA     #%01000000      ;Get Reset Received Break command (2)
  1082 00:FAF4: 8D 82 FE                     STA     UART_COMMAND_A  ;Send to DUART to reset (4)
  1083 00:FAF7: A9 50                        LDA     #%01010000      ;Get Reset Break Interrupt command (2)
  1084 00:FAF9: 8D 82 FE                     STA     UART_COMMAND_A  ;Send to DUART to reset (4)
  1085                        ;
  1086 00:FAFC: 58           BREAKEY         CLI                     ;Enable IRQ, drop into BRK handler (2)
  1087                        ;
  1088                        ;**************************************************************************************************
  1089                        ;
  1090                        ; BRK Vector defaults to here
  Mon Apr  3 2023 13:43                                                                                                    Page 25


  1091                        ;
  1092 00:FAFD: 7A           BRKINSTR0       PLY                     ;Restore Y Reg (4)
  1093 00:FAFE: FA                           PLX                     ;Restore X Reg (4)
  1094 00:FAFF: 68                           PLA                     ;Restore A Reg (4)
  1095 00:FB00: 85 D6                        STA     AREG            ;Save A Reg (3)
  1096 00:FB02: 86 D5                        STX     XREG            ;Save X Reg (3)
  1097 00:FB04: 84 D4                        STY     YREG            ;Save Y Reg (3)
  1098 00:FB06: 68                           PLA                     ;Get Processor Status (4)
  1099 00:FB07: 85 D2                        STA     PREG            ;Save in PROCESSOR STATUS preset/result (3)
  1100 00:FB09: BA                           TSX                     ;Xfer STACK pointer to X Reg (2)
  1101 00:FB0A: 86 D3                        STX     SREG            ;Save STACK pointer (3)
  1102                        ;
  1103 00:FB0C: FA                           PLX                     ;Pull Low RETURN address from STACK then save it (4)
  1104 00:FB0D: 86 D0                        STX     PCL             ;Store program counter Low byte (3)
  1105 00:FB0F: 86 B0                        STX     INDEXL          ;Seed Indexl for DIS_LINE (3)
  1106 00:FB11: 7A                           PLY                     ;Pull High RETURN address from STACK then save it (4)
  1107 00:FB12: 84 D1                        STY     PCH             ;Store program counter High byte (3)
  1108 00:FB14: 84 B1                        STY     INDEXH          ;Seed Indexh for DIS_LINE (3)
  1109 00:FB16: 4F D2 0C                     BBR4    PREG,DO_NULL    ;Check for BRK bit set (5,6)
  1110                        ;
  1111                        ; The following three subroutines are contained in the base C02 Monitor code. These calls
  1112                        ; do a register display and disassembles the line of code that caused the BRK to occur
  1113                        ;
  1114 00:FB19: 20 21 E0                     JSR     M_PRSTAT1       ;Display CPU status (6)
  1115 00:FB1C: 20 2A E0                     JSR     M_DECINDEX      ;Decrement Index to BRK ID Byte (6)
  1116 00:FB1F: 20 2A E0                     JSR     M_DECINDEX      ;Decrement Index to BRK instruction (6)
  1117 00:FB22: 20 24 E0                     JSR     M_DIS_LINE      ;Disassemble BRK instruction (6)
  1118                        ;
  1119                        ; Note: This routine only clears Port A, as it is used for the Console
  1120                        ;
  1121 00:FB25: A9 00        DO_NULL         LDA     #$00            ;Clear all Processor Status Register bits (2)
  1122 00:FB27: 48                           PHA                     ;Push it to Stack (3)
  1123 00:FB28: 28                           PLP                     ;Pull it to Processor Status (4)
  1124 00:FB29: 64 D9                        STZ     ITAIL_A         ;Clear input buffer pointers (3)
  1125 00:FB2B: 64 D8                        STZ     IHEAD_A         ; (3)
  1126 00:FB2D: 64 D7                        STZ     ICNT_A          ; (3)
  1127 00:FB2F: 6C 08 03                     JMP     (BRKRTVEC0)     ;Done BRK service process, re-enter monitor (6)
  1128                        ;
  1129                        ;**************************************************************************************************
  1130                        ;
  1131                        ;Entry for ISR to service the timer/counter interrupt.
  1132                        ;
  1133                        ; NOTE: Stop timer cmd resets the interrupt flag, counter continues to generate interrupts.
  1134                        ; NOTE: 38 clock cycles to here from INTERUPT0 - 68 in total
  1135                        ;
  1136 00:FB32: AD 8F FE     UART_RTC0       LDA     UART_STOP_CNT   ;Get Command mask for stop timer (4)
  1137                        ;
  1138                        ; Check the MATCH flag bit7 to see if a Delay is active. If yes, decrement the MSDELAY
  1139                        ; variable once each pass until it is zero, then clear the MATCH flag bit7
  1140                        ;
  1141 00:FB35: 7F FF 06                     BBR7    MATCH,SKIP_DLY  ;Skip Delay if bit7 is clear (5,6)
  1142 00:FB38: C6 EC                        DEC     MSDELAY         ;Decrement Millisecond delay variable (5)
  1143 00:FB3A: D0 02                        BNE     SKIP_DLY        ;If not zero, skip (2/3)
  1144 00:FB3C: 77 FF                        RMB7    MATCH           ;Else clear MATCH flag (5)
  1145                        ;
  1146                        ; Check the MATCH flag bit6 to see if Benchmarking is active. If yes, increment the
  1147                        ; variables once each pass until the MATCH flag bit6 is inactive.
  1148                        ;
  1149 00:FB3E: 6F FF 10     SKIP_DLY        BBR6    MATCH,SKIP_CNT  ;Skip Count if bit6 is clear (5,6)
  1150 00:FB41: E6 F0                        INC     MS10_CNT        ;Else, increment 10ms count (5)
  1151 00:FB43: A5 F0                        LDA     MS10_CNT        ;Load current value (3)
  1152 00:FB45: C9 64                        CMP     #100            ;Compare for 1 second elapsed time (2)
  1153 00:FB47: 90 08                        BCC     SKIP_CNT        ;If not, skip to RTC update (2/3)
  Mon Apr  3 2023 13:43                                                                                                    Page 26


  1154 00:FB49: 64 F0                        STZ     MS10_CNT        ;Else, zero 10ms count (3)
  1155 00:FB4B: E6 F1                        INC     SECL_CNT        ;Increment low byte elapsed seconds (5)
  1156 00:FB4D: D0 02                        BNE     SKIP_CNT        ;If no overflow, skip to RTC update (2/3)
  1157 00:FB4F: E6 F2                        INC     SECH_CNT        ;Else, increment high byte elapsed seconds (5)
  1158                        ;
  1159 00:FB51: C6 E4        SKIP_CNT        DEC     TICKS           ;Decrement RTC tick count (5)
  1160 00:FB53: D0 44                        BNE     REGEXT_RTC      ;Exit if not zero (2/3)
  1161 00:FB55: A9 64                        LDA     #DF_TICKS       ;Get default tick count (2)
  1162 00:FB57: 85 E4                        STA     TICKS           ;Reset tick count (3)
  1163                        ;
  1164 00:FB59: E6 E5                        INC     SECS            ;Increment seconds (5)
  1165 00:FB5B: A5 E5                        LDA     SECS            ;Load it to A reg (3)
  1166 00:FB5D: C9 3C                        CMP     #60             ;Check for 60 seconds (2)
  1167 00:FB5F: 90 38                        BCC     REGEXT_RTC      ;If not, exit (2/3)
  1168 00:FB61: 64 E5                        STZ     SECS            ;Else, reset seconds, inc Minutes (3)
  1169                        ;
  1170 00:FB63: E6 E6                        INC     MINS            ;Increment Minutes (5)
  1171 00:FB65: A5 E6                        LDA     MINS            ;Load it to A reg (3)
  1172 00:FB67: C9 3C                        CMP     #60             ;Check for 60 minutes (2)
  1173 00:FB69: 90 2E                        BCC     REGEXT_RTC      ;If not, exit (2/3)
  1174 00:FB6B: 64 E6                        STZ     MINS            ;Else, reset Minutes, inc Hours (3)
  1175                        ;
  1176 00:FB6D: E6 E7                        INC     HOURS           ;Increment Hours (5)
  1177 00:FB6F: A5 E7                        LDA     HOURS           ;Load it to A reg (3)
  1178 00:FB71: C9 18                        CMP     #24             ;Check for 24 hours (2)
  1179 00:FB73: 90 24                        BCC     REGEXT_RTC      ;If not, exit (2/3)
  1180 00:FB75: 64 E7                        STZ     HOURS           ;Else, reset hours, inc Days (3)
  1181                        ;
  1182                        ;This is the tricky part ;-)
  1183                        ; One variable holds the Day of the week and the Date of the Month!
  1184                        ; First, update the Day of the Week, which is the upper 3 bits of the variable
  1185                        ; Valid days are 1 to 7. Mask off the upper 3 bits, and add #%00100000 to it,
  1186                        ; if the result is zero, it was #%11100000, so start over by making the Day
  1187                        ; #%00100000, then save it to RTC_TEMP variable.
  1188                        ;
  1189                        ;Once that's done, load the variable again, mask off the Date and increase by
  1190                        ; one, then check against days of the month, update as required and check for
  1191                        ; Leap year and February 29th stuff. When all updated, OR in the Day from the
  1192                        ; RTC_TEMP variable and finish updating the DAY_DATE variable.
  1193                        ;
  1194 00:FB77: A5 E8                        LDA     DAY_DATE        ;Get Day and Date variable (3)
  1195 00:FB79: 29 E0                        AND     #%11100000      ;Mask off for Day of Week (1-7) (2)
  1196 00:FB7B: 18                           CLC                     ;Clear carry for add (2)
  1197 00:FB7C: 69 20                        ADC     #%00100000      ;Add effective "1" to Day of week (2)
  1198 00:FB7E: D0 02                        BNE     NO_DAY_ADD      ;If non-zero, don't reset to "1" (2/3)
  1199 00:FB80: A9 20                        LDA     #%00100000      ;Else, reset Day to "1" (2)
  1200 00:FB82: 85 EB        NO_DAY_ADD      STA     RTC_TEMP        ;Store the updated Day into temp (3)
  1201                        ;
  1202                        ;Get the Month and Year variable, move the upper 4-bits down to get the
  1203                        ; current Month. Xfer it the X reg, then get the Date, increment by one
  1204                        ; and check against the number of days in that month.
  1205                        ;
  1206 00:FB84: A5 E9                        LDA     MONTH_CENTURY   ;Get Month and Year variable (3)
  1207 00:FB86: 4A                           LSR     A               ;Shift Month to lower 4 bits (2)
  1208 00:FB87: 4A                           LSR     A               ; (2)
  1209 00:FB88: 4A                           LSR     A               ; (2)
  1210 00:FB89: 4A                           LSR     A               ; (2)
  1211 00:FB8A: AA                           TAX                     ;Move to X reg (2)
  1212 00:FB8B: A5 E8                        LDA     DAY_DATE        ;Get Day and Date variable (3)
  1213 00:FB8D: 29 1F                        AND     #%00011111      ;Mask off for Date of Month (1-31) (2)
  1214 00:FB8F: 1A                           INC     A               ;Increment by one (2)
  1215 00:FB90: DD F3 FE                     CMP     MAX_DATE-1,X    ;Check for Max Day per Month+1 (4)
  1216 00:FB93: B0 07                        BCS     MONTH_ADD       ;Branch if we need to update the Month (2/3)
  Mon Apr  3 2023 13:43                                                                                                    Page 27


  1217 00:FB95: 05 EB        DO_29           ORA     RTC_TEMP        ;Else OR in updated Day to updated Date (3)
  1218 00:FB97: 85 E8                        STA     DAY_DATE        ;Update Day and Date variable (3)
  1219 00:FB99: 6C 0A 03     REGEXT_RTC      JMP     (IRQRTVEC0)     ;Then exit IRQ handler (6)
  1220                        ;
  1221 00:FB9C: E0 02        MONTH_ADD       CPX     #$02            ;Check for Month = February (2)
  1222 00:FB9E: D0 0F                        BNE     MONTH_INC       ;If not, increment Month (2/3)
  1223 00:FBA0: A5 EA                        LDA     YEAR            ;Else, Get current year low byte (3)
  1224 00:FBA2: 29 03                        AND     #%00000011      ;Mask off lower 2 bits (2)
  1225 00:FBA4: D0 09                        BNE     MONTH_INC       ;If not a Leap Year, continue on (2/3)
  1226 00:FBA6: A5 E8                        LDA     DAY_DATE        ;Get Day and Date variable (3)
  1227 00:FBA8: 29 1F                        AND     #%00011111      :Mask off Date (2)
  1228 00:FBAA: 1A                           INC     A               ;Increment by one (2)
  1229 00:FBAB: C9 1E                        CMP     #30             ;Check for 29th+1 Day for Leap Year (2)
  1230 00:FBAD: 90 E6                        BCC     DO_29           ;Save Date as 29th and exit IRQ handler (2/3)
  1231                        ;
  1232 00:FBAF: A5 EB        MONTH_INC       LDA     RTC_TEMP        ;Get updated Day (Date is effective zero) (3)
  1233 00:FBB1: 09 01                        ORA     #%00000001      ;OR in the 1st Day of the Month (2)
  1234 00:FBB3: 85 E8                        STA     DAY_DATE        ;Save updated Day and Date of the Month (3)
  1235                        ;
  1236 00:FBB5: A5 E9                        LDA     MONTH_CENTURY   ;Get Month and Year variable (3)
  1237 00:FBB7: 18                           CLC                     ;Clear Carry for add (2)
  1238 00:FBB8: 69 10                        ADC     #$10            ;Add "1" to Month (upper 4 bits) (2)
  1239 00:FBBA: 85 EB                        STA     RTC_TEMP        ;Save it to work temp (3)
  1240 00:FBBC: 29 F0                        AND     #%11110000      ;Mask off Century (lower 4 bits) (2)
  1241 00:FBBE: C9 D0                        CMP     #$D0            ;Check for "13" (December + 1) (2)
  1242 00:FBC0: B0 06                        BCS     YEAR_ADD        ;If 13 go add to YEAR (2/3)
  1243 00:FBC2: A5 EB                        LDA     RTC_TEMP        ;Else, Get updated Month and Century (3)
  1244 00:FBC4: 85 E9                        STA     MONTH_CENTURY   ;Save it (3)
  1245 00:FBC6: 80 D1                        BRA     REGEXT_RTC      ;Exit IRQ Handler (3)
  1246                        ;
  1247 00:FBC8: A5 E9        YEAR_ADD        LDA     MONTH_CENTURY   ;Get Month and Century (3)
  1248 00:FBCA: 29 0F                        AND     #%00001111      ;Mask off old month (2)
  1249 00:FBCC: 09 10                        ORA     #%00010000      ;OR in $10 for January (2)
  1250 00:FBCE: 85 E9                        STA     MONTH_CENTURY   ;Save updated Month and existing upper 4 bits (3)
  1251 00:FBD0: E6 EA                        INC     YEAR            ;Increment Year low byte (0-255) (5)
  1252 00:FBD2: D0 C5                        BNE     REGEXT_RTC      ;If no rollover, exit ISR (2/3)
  1253 00:FBD4: A5 E9                        LDA     MONTH_CENTURY   ;Get Month and Year variable (3)
  1254 00:FBD6: AA                           TAX                     ;Save to X reg (2)
  1255 00:FBD7: 29 F0                        AND     #%11110000      ;Mask off upper 4-bits for year (2)
  1256 00:FBD9: 85 EB                        STA     RTC_TEMP        ;Save it in the temp area (3)
  1257 00:FBDB: 8A                           TXA                     ;Get the Month and Year back (2)
  1258 00:FBDC: 29 0F                        AND     #%00001111      ;Mask off the month (2)
  1259 00:FBDE: 18                           CLC                     ;Clear carry for add (2)
  1260 00:FBDF: 69 01                        ADC     #$01            ;Add 1 to upper 4 bits (2)
  1261 00:FBE1: 05 EB                        ORA     RTC_TEMP        ;OR in the Month (3)
  1262 00:FBE3: 85 E9                        STA     MONTH_CENTURY   ;Update Month and Century variable (3)
  1263 00:FBE5: 80 B2                        BRA     REGEXT_RTC      ;If no rollover, then exit IRQ handler (3)
  1264                        ;
  1265                        ;**************************************************************************************************
  1266                        ;
  1267                        ;Core routines that are used to detect and configure additional I/O devices.
  1268                        ; The I/O adapter supported by the 4.0x Release of C02BIOS contains two I/O devices:
  1269                        ; - A Maxim DS15x1 Realtime Clock
  1270                        ; - An IDE Device, i.e., IBM/Hitachi MicroDrive
  1271                        ;
  1272                        ; The first routine is to detect the DS15x1 RTC. This is done by reading the NVRAM section
  1273                        ; and testing for the Signature at the end of NVRAM. Obviously, this is something that needs
  1274                        ; to be setup before it can be detected. There is a separate utility that is used to configure
  1275                        ; the RTC for Time/Date, NVRAM usage and the two-byte signature. This utility must be run first
  1276                        ; to properly configure the RTC. Once completed, the BIOS will detect the RTC and read the
  1277                        ; Date and Time to set the BIOS variables accordingly.
  1278                        ;
  1279                        ; The second routine is to detect the IDE device. This can be a bit tricky...
  Mon Apr  3 2023 13:43                                                                                                    Page 28


  1280                        ; The first step is to load the status register and check it's contents. If there is no device
  1281                        ; attached, the contents will be a "phantom" I/O address, which is $FE.
  1282                        ; If this happens, simply bypass any additional testing and setup.
  1283                        ; If the contents are other than the "phantom" I/O address, we take additional steps to sense
  1284                        ; the IDE Controller, run Diagnostics, initialize it and add it's ISR into the chain.
  1285                        ;
  1286                        ;**************************************************************************************************
  1287                        ;
  1288                        ;This routine detects the DS15x1 RTC.
  1289                        ; While there's really no standard method to detect the RTC, the NVRAM is initialized
  1290                        ; during the configuration for Date, Time, etc. The last two bytes of the NVRAM will
  1291                        ; contain a 2-byte signature of "KM", in honor of the author ;-)
  1292                        ; If the signature is found, the INIT_RTC routine is called, which will setup the
  1293                        ; RTC variables in Page Zero, where the current Date and Time will be maintained.
  1294                        ;
  1295                        DETECT_RTC
  1296 00:FBE7: A2 FF                        LDX     #$FF            ;Load NVRAM Offset (2)
  1297 00:FBE9: 8E 70 FE                     STX     RTC_RAM_ADDR    ;Set index to 2nd byte of signature (4)
  1298 00:FBEC: AD 73 FE                     LDA     RTC_RAM_DATA    ;Get NVRAM Data (4)
  1299 00:FBEF: C9 4D                        CMP     #"M"            ;Check for "M" (2)
  1300 00:FBF1: D0 0A                        BNE     SET_EPOCH       ;If not found, set EPOCH as default (2/3)
  1301 00:FBF3: CE 70 FE                     DEC     RTC_RAM_ADDR    ;Decrement index to 1st signature byte (5)
  1302 00:FBF6: AD 73 FE                     LDA     RTC_RAM_DATA    ;Get NVRAM Data (4)
  1303 00:FBF9: C9 4B                        CMP     #"K"            ;Check for "K" (2)
  1304 00:FBFB: F0 0B                        BEQ     FOUND_RTC       ;If good, go Init RTC and return (2/3)
  1305                        ;
  1306                        ;If RTC not found, preload Date variables as EPOCH time (Thursday, 1st January, 1970)
  1307                        ; Note: all Time variables default to zero from a cold start.
  1308                        ;
  1309                        SET_EPOCH
  1310 00:FBFD: A2 03                        LDX     #$03            ;Get Index of 3 (2)
  1311 00:FBFF: BD 9E FD     EPOCH_LP        LDA     EPOCH-1,X       ;Get Preload data (4)
  1312 00:FC02: 95 E7                        STA     DAY_DATE-1,X    ;Store in RTC variables (4)
  1313 00:FC04: CA                           DEX                     ;Decrement Index (2)
  1314 00:FC05: D0 F8                        BNE     EPOCH_LP        ;Loop back until done (2/3)
  1315 00:FC07: 60                           RTS                     ;Return, no RTC found (6)
  1316                        ;
  1317                        FOUND_RTC
  1318 00:FC08: E8                           INX                     ;Increment Index ($FF -> $00) (2)
  1319 00:FC09: BD B4 FF                     LDA     RTC_MSG,X       ;Get BIOS init msg (4)
  1320 00:FC0C: F0 05                        BEQ     INIT_RTC        ;If zero, msg done, go Init RTC (2/3)
  1321 00:FC0E: 20 19 F8                     JSR     CHROUT          ;Send to console (6)
  1322 00:FC11: 80 F5                        BRA     FOUND_RTC       ;Loop back until done (3)
  1323                        ;
  1324                        ;This routine reads the BCD registers from the DS15x1 RTC, converts BCD to Binary and loads the
  1325                        ; BIOS RTC variables. Note that some of the variables are shared to conserve Page Zero space.
  1326                        ; Note: Buffer area used for init is also used by C02 Monitor for hex input and code conversion,
  1327                        ; but is initialized as needed before usage, so we can clobber it here when configuring the BIOS.
  1328                        ;
  1329                        ;As there is a period of time required to get the data from the RTC, convert from BCD, then format
  1330                        ; into the Page Zero locations used, we need to manage the existing Timer/Counter status to ensure
  1331                        ; the best accuracy in time once the routine finishes. In short, the best we can manage accuracy
  1332                        ; is within one second, as the RTC internal update of the registers we read are halted.
  1333                        ;
  1334                        ;To help minimize the timing transfer, we first set the BIOS tick count to it's default value
  1335                        ; to ensure that the software RTC values are not updated during loading from the hardware RTC.
  1336                        ;
  1337                        ; The time to detect and load the current time/date is less than 5000 clock cycles. However, the
  1338                        ; overall accuracy can only be within one second. After the RTC values are transferred, the
  1339                        ; software RTC tick count will not have reached zero, as the entire timing is less than 1ms to
  1340                        ; to read the RTC, convert the BCD data and load the software clock variable in Page Zero. This
  1341                        ; results in software RTC timing starting a 1 second countdown from when the RTC is detected.
  1342                        ; - Note: A Coldstart wouldn't need to reset the Tick Count, but this routine can also be called
  Mon Apr  3 2023 13:43                                                                                                    Page 29


  1343                        ;         via the BIOS JMP table, so we reset it here as a safety.
  1344                        ;
  1345                        INIT_RTC
  1346 00:FC13: A2 64                        LDX     #DF_TICKS       ;Get BIOS default Tick count (2)
  1347 00:FC15: 86 E4                        STX     TICKS           ;Reset the Tick count (3)
  1348 00:FC17: A2 00                        LDX     #$00            ;Set X reg to zero for indexing below (2)
  1349 00:FC19: A9 80                        LDA     #%10000000      ;Get TE Bit mask (2)
  1350 00:FC1B: 1C 6F FE                     TRB     RTC_CONTROL_B   ;Turn off TE Bit to disable update (6)
  1351                        ;
  1352                        RTC_LOAD_LOOP
  1353 00:FC1E: BD 60 FE                     LDA     RTC_SECONDS,X   ;Get Data from RTC (4)
  1354 00:FC21: 95 A0                        STA     BUFF_PG0,X      ;Store into RAM (4)
  1355 00:FC23: E8                           INX                     ;Increment register count (2)
  1356 00:FC24: E0 08                        CPX     #$08            ;Check for all 8 moved (2)
  1357 00:FC26: D0 F6                        BNE     RTC_LOAD_LOOP   :Loop back until all registers are read (2/3)
  1358                        ;
  1359 00:FC28: A9 80                        LDA     #%10000000      ;Get TE Bit mask (2)
  1360 00:FC2A: 0C 6F FE                     TSB     RTC_CONTROL_B   ;Turn on TE Bit to enable update (6)
  1361                        ;
  1362                        ;Now convert BCD to Binary (X reg = $08)
  1363                        ;
  1364 00:FC2D: B5 9F        BCD_LOOP        LDA     BUFF_PG0-1,X    ;Get BCD Data from Buffer (4)
  1365                        ;
  1366 00:FC2F: A8                           TAY                     ;Save BCD value (2)
  1367 00:FC30: 29 F0                        AND     #$F0            ;Mask for high nibble (2)
  1368 00:FC32: 4A                           LSR     A               ;Shift right (/2) (2)
  1369 00:FC33: 85 EB                        STA     RTC_TEMP        ;Save in temp (3)
  1370 00:FC35: 4A                           LSR     A               ;Shift over (/4) (2)
  1371 00:FC36: 4A                           LSR     A               ;Shift over (/8) -Carry is clear (2)
  1372 00:FC37: 65 EB                        ADC     RTC_TEMP        ;Add in temp (3)
  1373 00:FC39: 85 EB                        STA     RTC_TEMP        ;Store it back (3)
  1374 00:FC3B: 98                           TYA                     ;Get BCD back (2)
  1375 00:FC3C: 29 0F                        AND     #$0F            ;Mask for low nibble (2)
  1376 00:FC3E: 65 EB                        ADC     RTC_TEMP        ;Add in temp (upper converted nibble) (3)
  1377                        ;
  1378 00:FC40: 95 9F                        STA     BUFF_PG0-1,X    ;Save Binary Data back to Buffer (4)
  1379 00:FC42: CA                           DEX                     ;Decrement Index (2)
  1380 00:FC43: D0 E8                        BNE     BCD_LOOP        ;Loop back until done (2/3)
  1381                        ;
  1382                        ;Now take the binary data for the RTC, and format it for the BIOS RTC variables:
  1383                        ; Seconds, Minutes and Hours are fine as they are, so they simply move over.
  1384                        ; The Day (of the week) and the Date (of the Month) are combined into a single variable.
  1385                        ; Note: Day (of the week) is variable and decided by the user. In honor of my past, I'm
  1386                        ; declaring Saturday as the 1st day of the week, an IBM tradition.
  1387                        ; The Month is also kept in the upper 4 bits of the Century variable.
  1388                        ; Note: The Century and Year are two BCD digits each. As 4 BCD digits, these need to be
  1389                        ; converted to a 16-bit binary integer. Only 12-bits are needed, which frees the upper
  1390                        ; 4-bits to be used for the Month.
  1391                        ;
  1392 00:FC45: A5 A3                        LDA     BUFF_PG0+3      ;Get the Day count (3)
  1393 00:FC47: 0A                           ASL     A               ;Shift to upper 3 bits (2)
  1394 00:FC48: 0A                           ASL     A               ; (2)
  1395 00:FC49: 0A                           ASL     A               ; (2)
  1396 00:FC4A: 0A                           ASL     A               ; (2)
  1397 00:FC4B: 0A                           ASL     A               ; (2)
  1398 00:FC4C: 05 A4                        ORA     BUFF_PG0+4      ;OR in the Date variable (3)
  1399 00:FC4E: 85 A3                        STA     BUFF_PG0+3      ;Save to the Day variable (3)
  1400                        ;
  1401 00:FC50: A5 A5                        LDA     BUFF_PG0+5      ;Get the Month variable (3)
  1402 00:FC52: 0A                           ASL     A               ;Shift to upper 4 bits (2)
  1403 00:FC53: 0A                           ASL     A               ; (2)
  1404 00:FC54: 0A                           ASL     A               ; (2)
  1405 00:FC55: 0A                           ASL     A               ; (2)
  Mon Apr  3 2023 13:43                                                                                                    Page 30


  1406 00:FC56: 85 A4                        STA     BUFF_PG0+4      ;Save it (lower nibble = 0) (3)
  1407                        ;
  1408                        ; The easiest way to create the 16-bit Year is to take the high binary digit
  1409                        ; and multiply it by 100, then add the low binary digit. We do the multiply
  1410                        ; by adding it to the 16-bit variable 100 times ;-)
  1411                        ;
  1412 00:FC58: A2 64                        LDX     #100            ;Get the index count for 100 (2)
  1413 00:FC5A: 64 A8                        STZ     BUFF_PG0+8      ;Zero Temp low byte (3)
  1414 00:FC5C: 64 A9                        STZ     BUFF_PG0+9      ;Zero Temp high byte (3)
  1415                        ;
  1416 00:FC5E: A5 A7        RTC_ADD         LDA     BUFF_PG0+7      ;Get Year value (3)
  1417 00:FC60: 20 7F FC                     JSR     ADD_16          ;Go add it... (6)
  1418 00:FC63: CA                           DEX                     ;Decrement count (2)
  1419 00:FC64: D0 F8                        BNE     RTC_ADD         ;Loop back until done (2/3)
  1420                        ;
  1421 00:FC66: A5 A6                        LDA     BUFF_PG0+6      ;Get Year lower digit (3)
  1422 00:FC68: 20 7F FC                     JSR     ADD_16          ;Add it into the Temp (6)
  1423                        ;
  1424 00:FC6B: A5 A8                        LDA     BUFF_PG0+8      ;Get lower byte for year (3)
  1425 00:FC6D: 85 A5                        STA     BUFF_PG0+5      ;Save it (3)
  1426 00:FC6F: A5 A9                        LDA     BUFF_PG0+9      ;Get upper byte for year (3)
  1427 00:FC71: 05 A4                        ORA     BUFF_PG0+4      ;OR in Month (upper 4 bits) (3)
  1428 00:FC73: 85 A4                        STA     BUFF_PG0+4      ;Save it (3)
  1429                        ;
  1430                        ; Now transfer the buffer contents to the Page Zero RTC variables
  1431                        ;
  1432 00:FC75: A2 06                        LDX     #$06            ;Set count for 6 (2)
  1433 00:FC77: B5 9F        RTC_XFER        LDA     BUFF_PG0-1,X    ;Get the buffer data (4)
  1434 00:FC79: 95 E4                        STA     SECS-1,X        ;Save to RTC variables (4)
  1435 00:FC7B: CA                           DEX                     ;Decrement count (2)
  1436 00:FC7C: D0 F9                        BNE     RTC_XFER        ;Loop back till done (2/3)
  1437 00:FC7E: 60                           RTS                     ;Return to caller (6)
  1438                        ;
  1439 00:FC7F: 18           ADD_16          CLC                     ;Clear carry flag (2)
  1440 00:FC80: 65 A8                        ADC     BUFF_PG0+8      ;Add to Temp low byte (3)
  1441 00:FC82: 85 A8                        STA     BUFF_PG0+8      ;And save it (3)
  1442 00:FC84: A5 A9                        LDA     BUFF_PG0+9      ;Get high byte (3)
  1443 00:FC86: 69 00                        ADC     #$00            ;Add carry to Temp high byte (2)
  1444 00:FC88: 85 A9                        STA     BUFF_PG0+9      ;And save it (3)
  1445 00:FC8A: 60                           RTS                     ;Return to caller (6)
  1446                        ;
  1447                        ;**************************************************************************************************
  1448                        ;
  1449                        ;This routine detects the IDE Port
  1450                        ; To detect the IDE controller, it can be a bit tricky. It might take several seconds
  1451                        ; from a physical Reset of the IDE Controller before the Busy flag goes off.
  1452                        ; During this time, any commands sent to the IDE controller will fail. As I like to say,
  1453                        ; "timing is everything". After quite a bit of testing, the easy way to detect the IDE
  1454                        ; controller present is to load the IDE_STATUS register. If an IDE Controller is not
  1455                        ; present, the A Reg will show a phantom address of $FE (high order IDE hardware address)
  1456                        ; and any initialization can be bypassed.
  1457                        ;
  1458                        ; If the IDE controller is present, the IDE_STATUS read may be invalid, so it's necessary
  1459                        ; to test the BUSY flag of the status register. Once the IDE Controller is no longer busy,
  1460                        ; the controller can be initialized. This does create an obvious pause in the startup, but
  1461                        ; ensures that the IDE controller can be reliably detected and initialized at boot time.
  1462                        ;
  1463                        ; A change has been made in the IDE_SETUP routine. As the interrupts were disabled on the
  1464                        ; IDE Controller initially, it needs to be re-enabled before the setup is completed. The short
  1465                        ; bit of code that does this is also called by the Reset-Diag function (JMP $FF00).
  1466                        ;
  1467                        DETECT_IDE
  1468 00:FC8B: AD 7F FE                     LDA     IDE_STATUS      ;Get the IDE Status (4)
  Mon Apr  3 2023 13:43                                                                                                    Page 31


  1469 00:FC8E: C9 FE                        CMP     #$FE            ;Check for an empty (phantom) address (2)
  1470 00:FC90: D0 01                        BNE     IDE_INIT        ;If not #$FE, try to Init the IDE controller (2/3)
  1471 00:FC92: 60           NO_IDE          RTS                     ;Return to caller, no IDE controller found (6)
  1472                        ;
  1473                        ;Init the IDE controller
  1474                        ; First, test for the IDE controller ready. If that works, execute the IDE device
  1475                        ; Diagnostics and check for successful completion. If it fails, exit without linking
  1476                        ; the IDE controller into the IRQ chain. Else, link IRQ chain and show message that
  1477                        ; the IDE device is found.
  1478                        ;
  1479                        IDE_INIT
  1480 00:FC93: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
  1481 00:FC96: 30 FB                        BMI     IDE_INIT        ;Loop until BUSY bit is clear (2/3)
  1482                        
  1483 00:FC98: 20 21 FD                     JSR     IDE_DIAG        ;Run the self diagnostic (6)
  1484 00:FC9B: C9 50                        CMP     #$50            ;Check for $50 on A reg (drive ready) (2)
  1485 00:FC9D: D0 F3                        BNE     NO_IDE          ;If not, no IDE present (2/3)
  1486 00:FC9F: E0 01                        CPX     #$01            ;X Reg will show #$01 if diags successful (2)
  1487 00:FCA1: D0 EF                        BNE     NO_IDE          ;If failed, exit (2/3)
  1488                        ;
  1489                        ; IDE Controller found and passed initial self diagnostics test.
  1490                        ; Send IDE Found message to terminal, note: X reg = $01.
  1491                        ;
  1492 00:FCA3: BD BF FF     IDE_MSG_LP      LDA     IDE_MSG-1,X     ;Get BIOS init msg (minus 1 for X reg=1) (4)
  1493 00:FCA6: F0 06                        BEQ     IDE_SETUP       ;If zero, msg done, go setup IDE (2/3)
  1494 00:FCA8: 20 19 F8                     JSR     CHROUT          ;Send to console (6)
  1495 00:FCAB: E8                           INX                     ;Increment Index (2)
  1496 00:FCAC: 80 F5                        BRA     IDE_MSG_LP      ;Loop back until done (3)
  1497                        ;
  1498                        ;IDE Setup
  1499                        ; This will insert the IDE Controller ISR into the Interrupt Handler chain.
  1500                        ;
  1501                        ; First, disable interrupts, capture the current IRQ exit vector address
  1502                        ; and save it to the first Insert Vector. Second, load the IDE ISR routine
  1503                        ; address and store it to the main IRQ exit vector, then re-enable interrupts.
  1504                        ;
  1505                        ; Second, this routine will execute an Identify IDE command to load the Soft
  1506                        ; Config Data for the maximum LBA Count accessible by the current IDE device.
  1507                        ;
  1508                        ; Note: Two routines are below, use only one! They allow a choice to insert
  1509                        ; the IDE ISR before or after the main Interrupt Handler. By default, loading
  1510                        ; is before the main ISR. Despite the high speed of the data transfers, the
  1511                        ; interrupt rate is not that high.
  1512                        ;
  1513 00:FCAE: 78           IDE_SETUP       SEI                     ;Disable interrupts (2)
  1514                        ;
  1515                        ; To load the IDE ISR Handler BEFORE the existing DUART ISR Handler:
  1516                        ;
  1517 00:FCAF: AD 04 03                     LDA     IRQVEC0         ;Get low byte of current IRQ Exit (4)
  1518 00:FCB2: AC 05 03                     LDY     IRQVEC0+1       ;Get high byte of current IRQ Exit (4)
  1519 00:FCB5: 8D 10 03                     STA     VECINSRT0       ;Save low byte of IRQ Exit to insert 0 (4)
  1520 00:FCB8: 8C 11 03                     STY     VECINSRT0+1     ;Save high byte of IRQ Exit to insert 0 (4)
  1521                        ;
  1522 00:FCBB: A9 4F                        LDA     #<INTERUPT1     ;Get low byte of IDE ISR (2)
  1523 00:FCBD: A0 FD                        LDY     #>INTERUPT1     ;Get high byte of IDE ISR (2)
  1524 00:FCBF: 8D 04 03                     STA     IRQVEC0         ;Save low byte of IRQ Exit (4)
  1525 00:FCC2: 8C 05 03                     STY     IRQVEC0+1       ;Save high byte of IRQ Exit (4)
  1526                        ;
  1527                        ; To load the IDE ISR Handler AFTER the existing DUART ISR Handler:
  1528                        ;
  1529                        ;                LDA     IRQRTVEC0       ;Get low byte of IRQ Exit
  1530                        ;                LDY     IRQRTVEC0+1     ;Get high byte of IRQ Exit
  1531                        ;                STA     VECINSRT0       ;Save low byte of IRQ Exit
  Mon Apr  3 2023 13:43                                                                                                    Page 32


  1532                        ;                STY     VECINSRT0+1     ;Save high byte of IRQ Exit
  1533                        ;
  1534                        ;                LDA     #<INTERUPT1     ;Get low byte of IDE ISR
  1535                        ;                LDY     #>INTERUPT1     ;Get high byte of IDE ISR
  1536                        ;                STA     IRQRTVEC0       ;Save low byte of IRQ Exit
  1537                        ;                STY     IRQRTVEC0+1     ;Save high byte of IRQ Exit
  1538                        ;
  1539 00:FCC5: 58                           CLI                     ;Enable interrupts (2)
  1540 00:FCC6: 20 46 FD                     JSR     IDE_EN_IRQ      ;Enable IDE Controller interrupt (6)
  1541                        ;
  1542                        ; Drop into Identify Drive routine
  1543                        ;
  1544                        IDE_IDENTIFY                            ;Identify Device
  1545                        ;
  1546                        ; This requests a 512-byte block of data that shows capabilities, CHS (not used), LBA Count, etc.
  1547                        ; The format is similar to Read LBA, except no LBA parameter is required. It effectively works as
  1548                        ; a Read Block operation and the data transferred is handled by the ISR for a Read Block.
  1549                        ; NOTE: The Identify Command is coded to load into LBA_BUFFER (address $0600).
  1550                        ;
  1551 00:FCC9: A9 00                        LDA     #<LBA_BUFFER    ;Set Address low byte (2)
  1552 00:FCCB: A0 06                        LDY     #>LBA_BUFFER    ;Set Address high byte (2)
  1553 00:FCCD: A2 01                        LDX     #$01            ;Set Block count to 1 (2)
  1554 00:FCCF: 20 E1 F8                     JSR     IDE_SET_ADDRESS ;Set Xfer address and block count (6)
  1555                        IDENT_WAIT
  1556 00:FCD2: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
  1557 00:FCD5: 30 FB                        BMI     IDENT_WAIT      ;Loop until BUSY bit is clear (2/3)
  1558                        
  1559                        
  1560 00:FCD7: 20 08 F9                     JSR     IDE_SET_PARMS2  ;Setup required parameters (no LBA parameter) (6)
  1561                        ;
  1562 00:FCDA: A9 EC                        LDA     #$EC            ;Get Identify Command (2)
  1563 00:FCDC: 20 5E F8                     JSR     IDENT_READ      ;Use READ_LBA routine to finish (6)
  1564                        ;
  1565                        ; Identify data loaded in buffer. Now extract LBA count and store to Soft Config Data for usage
  1566                        ; by access routines (Read/Write/Verify). Four bytes are used and the format from the Identify
  1567                        ; Command are Low-order Word / High-order Word, where each word is in Big Endian. We will store
  1568                        ; the LBA count as Little Endian, Low-order Word / High-order Word.
  1569                        ; The offset from the buffer are Words 60-61 (decimal).
  1570                        ;
  1571                        ; A table is used to index the offset of bytes to move into consecutive soft data.
  1572                        ;
  1573 00:FCDF: A2 04                        LDX     #$04            ;Set count for 4 bytes (2)
  1574 00:FCE1: BC CB FF     LBA_SIZE        LDY     LBA_OFFSET-1,X  ;Get Offset to LBA count (4)
  1575 00:FCE4: B1 F3                        LDA     (LBA_ADDR_LOW),Y        ;Load LBA Data (5)
  1576 00:FCE6: 9D 3B 03                     STA     LOAD_IDE-1,X    ;Store to Soft Config Data (5)
  1577 00:FCE9: CA                           DEX                     ;Decrement count (2)
  1578 00:FCEA: D0 F5                        BNE     LBA_SIZE        ;Loop back until done (2/3)
  1579                        ;
  1580                        ; Enable Write Cache for Microdrive, performance improvement ;-)
  1581                        IDE_EN_CACHE
  1582 00:FCEC: A9 02                        LDA     #$02            ;Get Enable Write Cache Feature (2)
  1583                        IDE_CACHE_CMD
  1584 00:FCEE: 8D 79 FE                     STA     IDE_FEATURE     ;Send to IDE controller (4)
  1585 00:FCF1: A9 E0                        LDA     #%11100000      ;Get Drive 0, LBA. mode, etc. (2)
  1586 00:FCF3: 8D 7E FE                     STA     IDE_DRV_HEAD    ;Send to IDE controller (4)
  1587 00:FCF6: A9 EF                        LDA     #$EF            ;Get Set Features Command (2)
  1588 00:FCF8: 8D 7F FE                     STA     IDE_COMMAND     ;Send Command to set feature (4)
  1589 00:FCFB: 20 1C F9                     JSR     TST_IDE_RDY     ;Test for Drive ready (6)
  1590 00:FCFE: AD 7F FE                     LDA     IDE_STATUS      ;Get Status (4)
  1591 00:FD01: AE 79 FE                     LDX     IDE_ERROR       ;Get Error (if any) (4)
  1592 00:FD04: 60                           RTS                     ;Return to Caller (6)
  1593                        ;
  1594                        ; Disable Write Cache for Microdrive, NO performance improvement;-(
  Mon Apr  3 2023 13:43                                                                                                    Page 33


  1595                        IDE_DIS_CACHE
  1596 00:FD05: A9 82                        LDA     #$82            ;Get Disable Write Cache Feature (2)
  1597 00:FD07: 80 E5                        BRA     IDE_CACHE_CMD   ;Finish Command above (3)
  1598                        ;
  1599                        ; Reset IDE Controller and run Diagnostics
  1600                        ; The RECAL routine disables the IRQ function, so the routine to enable the IRQ
  1601                        ; is called, then drops into the get status routine before returning.
  1602                        ;
  1603                        IDE_RESET                               ;Do a Reset of IDE device
  1604 00:FD09: 20 25 FD                     JSR     IDE_RECAL       ;Call IDE_RESET (set LBA mode) (6)
  1605 00:FD0C: 20 EC FC                     JSR     IDE_EN_CACHE    ;Enable Write Cache (6)
  1606 00:FD0F: 20 1C F9                     JSR     TST_IDE_RDY     ;Wait until Drive ready (6)
  1607 00:FD12: 20 46 FD                     JSR     IDE_EN_IRQ      ;Re-enable IDE Controller interrupt (6)
  1608                        ;
  1609                        ; Drop into Get Status routine after Diagnostics are run
  1610                        ;
  1611                        IDE_GET_STATUS                          ;Get Status/Error registers from the IDE controller
  1612                        ;
  1613                        ; This routine gets the current status of the IDE Controller and can be issued at any time.
  1614                        ; It does not rely on any interrupt capability as it's a simple read of the Status and the
  1615                        ; Error registers from the IDE Controller.
  1616                        ;
  1617                        ; Note: This routine should be called whenever an Error has occurred, as it returns the
  1618                        ; contents of the Error Register in the X Register and the contents of the Status Register
  1619                        ; in the A Register.
  1620                        ;
  1621                        ; Details for the Registers are:
  1622                        ;
  1623                        ; Error Register:
  1624                        ;Bit 7 - CRC Error or Bad Block error
  1625                        ;Bit 6 - Uncorrectable Data Error
  1626                        ;Bit 5 - 0 (not used) MC (used for Removable-Media drives)
  1627                        ;Bit 4 - ID Not Found
  1628                        ;Bit 3 - 0 (not used) MCR (used for Removable-Media drives)
  1629                        ;Bit 2 - Aborted Command error
  1630                        ;Bit 1 - Track Zero not found error
  1631                        ;Bit 0 - Data Address Mark Not Found
  1632                        ;
  1633                        ; Status Register:
  1634                        ;Bit 7 - Busy - IDE Controller is Busy (all other bits invalid)
  1635                        ;Bit 6 - Drive Ready (IDE Controller Ready to accept Commands)
  1636                        ;Bit 5 - Drive Write Fault - Write Fault error has occurred
  1637                        ;Bit 4 - Drive Seek Complete - is active when the drive is not seeking
  1638                        ;Bit 3 - Data Request - bit set when the IDE Controller has Data to transfer (R/W)
  1639                        ;Bit 2 - Correctable Data - bit set when bad data was found and corrected (ECC)
  1640                        ;Bit 1 - Index - bit toggled from 0 to 1 once per disk revolution
  1641                        ;Bit 0 - Error - bit set when previous command ended with some sort of error
  1642                        ;
  1643 00:FD15: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
  1644 00:FD18: 30 FB                        BMI     IDE_GET_STATUS  ;Loop until BUSY bit is clear (2/3)
  1645                        
  1646 00:FD1A: AD 7F FE                     LDA     IDE_STATUS      ;Get IDE Status Register (4)
  1647 00:FD1D: AE 79 FE                     LDX     IDE_ERROR       ;Get IDE Error Register (4)
  1648 00:FD20: 60                           RTS                     ;Return to Caller (6)
  1649                        ;
  1650                        IDE_DIAG                                ;Run internal Diagnostics on the IDE controller
  1651                        ;
  1652                        ; This is a basic self test within the IDE controller.
  1653                        ; This runs some internal tests for the IDE controller and returns with drive ready bits
  1654                        ; active ($50) and the error register as $01 if successful.
  1655                        ; For Diagnostics, the Error Register contains unique codes as follows:
  1656                        ;
  1657                        ;01h - No error Detected
  Mon Apr  3 2023 13:43                                                                                                    Page 34


  1658                        ;02h - Formatter device error
  1659                        ;03h - Sector Buffer error
  1660                        ;04h - ECC Circuitry error
  1661                        ;05h - Controller Microprocessor error
  1662                        ;8xH - Device 1 failed (not valid with a single drive system)
  1663                        ;       Note: 80h ORed in for the Slave Drive, lower bit definitions are the same!
  1664                        ;
  1665                        ; To send this command, a common routine is used to save ROM space.
  1666                        ;
  1667 00:FD21: A9 90                        LDA     #$90            ;Get Diagnostic Command (2)
  1668 00:FD23: 80 02                        BRA     IDE_SEND_CMD    ;Branch and send Command to IDE (3)
  1669                        ;
  1670                        IDE_RECAL                               ;Recalibrate Command
  1671                        ;
  1672                        ;This is the Recalibrate Command ($1x). Upon issue the IDE controller will move the heads to
  1673                        ; Cylinder 0 and read Head 0, Sector 1. If unsuccessful, an error will be posted.
  1674                        ;
  1675 00:FD25: A9 10                        LDA     #$10            ;Get Recalibrate Command (2)
  1676                        ;
  1677                        ; Drop into Send Command routine
  1678                        ;
  1679                        IDE_SEND_CMD                            ;Send a Command to the IDE controller
  1680                        ;
  1681                        ;Accepts a Command code via the A reg and sets up the necessary IDE Controller
  1682                        ; registers to accept it. It also tests to ensure the controller is ready
  1683                        ; to accept the command and get the Status and Error registers on return.
  1684                        ;
  1685                        ; NOTE: this routine turns off the interrupt capability as it is called
  1686                        ; during initial setup, where the interrupt handler has not been setup yet.
  1687                        ; A separate routine is called to enable the interrupt capability.
  1688                        ;
  1689 00:FD27: 78                           SEI                     ;Disable Interrupts (2)
  1690 00:FD28: AA                           TAX                     ;Save Command to X Reg (2)
  1691 00:FD29: 20 1C F9                     JSR     TST_IDE_RDY     ;Wait for IDE to be ready (6)
  1692 00:FD2C: A9 0A                        LDA     #%00001010      ;Get Mask to disable IRQ (2)
  1693 00:FD2E: 8D 76 FE                     STA     IDE_DEV_CTRL    ;Send to control register (4)
  1694 00:FD31: A9 E0                        LDA     #%11100000      ;Get Select Mask (LBA Mode, Drive 0) (2)
  1695 00:FD33: 8D 7E FE                     STA     IDE_DRV_HEAD    ;Select Drive 0 (4)
  1696                        ;
  1697 00:FD36: 8E 7F FE                     STX     IDE_COMMAND     ;Send command to IDE (4)
  1698                        SEND_CMD_LP
  1699 00:FD39: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
  1700 00:FD3C: 30 FB                        BMI     SEND_CMD_LP     ;Loop until BUSY bit is clear (2/3)
  1701                        
  1702                        ;
  1703 00:FD3E: AD 7F FE                     LDA     IDE_STATUS      ;Get IDE Status Register (4)
  1704 00:FD41: AE 79 FE                     LDX     IDE_ERROR       ;Get IDE Error Register (4)
  1705 00:FD44: 58                           CLI                     ;Enable interrupts (2)
  1706 00:FD45: 60                           RTS                     ;Return to caller (6)
  1707                        ;
  1708                        ; Enable Interrupts on the IDE Controller.
  1709                        ; This needs to be executed during initial setup and anytime the Reset/Diag BIOS function
  1710                        ; is called.
  1711                        ;
  1712                        IDE_EN_IRQ                              ;Enable IDE Controller interrupt
  1713 00:FD46: 20 1C F9                     JSR     TST_IDE_RDY     ;Wait for IDE to be ready (6)
  1714 00:FD49: A9 08                        LDA     #%00001000      ;Get Mask to enable IRQ (2)
  1715 00:FD4B: 8D 76 FE                     STA     IDE_DEV_CTRL    ;Send to control register (4)
  1716 00:FD4E: 60                           RTS                     ;Return to caller (6)
  1717                        ;
  1718                        ;**************************************************************************************************
  1719                        ;
  1720                        ;Interrupt 1 - This is the ISR which is responsible for servicing the IDE controller.
  Mon Apr  3 2023 13:43                                                                                                    Page 35


  1721                        ; The RTC does not require any ISR capabilities as no Alarm functions are being used in the BIOS.
  1722                        ; There are extra inserts which can be used if needed at a later date.
  1723                        ; The only functions that might make sense would be to add the Alarm function at a future date.
  1724                        ; Once the IDE controller BIOS has matured, if there's any room left in the allocated ROM area,
  1725                        ; I'll revisit it.
  1726                        ;
  1727                        ;The ISR for the IDE controller will handle the data transfer for LBA read/write/verify functions
  1728                        ; and handle any error functions. By design, the 16-bit Data Transfer feature is used for:
  1729                        ; Reading, Writing and Verifying of all LBA block data and the IDE Identification data.
  1730                        ;
  1731                        ;The BIOS is using the Alternate Status register to determine if DRQ (Data Request) is active.
  1732                        ; This works as a handshake for 16-bit data transfers without issue. Note that the normal Status
  1733                        ; register resets the interrupt when read, so this is only done once in the ISR per loop.
  1734                        ;
  1735                        ;Update: This ISR has been moved to the front of the ISR chain, i.e., this ISR routine gets
  1736                        ; serviced first, then jumps to the next ISR, which services the DUART. This makes a noticeable
  1737                        ; improvement in data transfer from the IDE controller. Note that overhead for this routine will
  1738                        ; add 33 clock cycles if it just exits (IDE controller did not generate an interrupt).
  1739                        ;
  1740                        ;To check if an interrupt has been generated by the IDE controller, the Alternate Status register
  1741                        ; will be read. This contains the same information as the standard Status register but will NOT
  1742                        ; reset the interrupt on the IDE controller. By reading the Alternate Status register first, we
  1743                        ; can determine what the status of the IDE controller is and take action if required.
  1744                        ; Note that not all bit settings imply an interrupt was generated. Specifically, looking at the
  1745                        ; bit definitions below, Bits 6 and 4 are set when the IDE is ready, hence a normal condition
  1746                        ; where nothing requires any attention. Also, a Busy condition can imply the IDE controller is
  1747                        ; working on a command but may not have generated an interrupt yet. If The Busy bit (7) is set,
  1748                        ; then all other bits are invalid per Seagate documentation, so we test for that first.
  1749                        ;
  1750                        ;One annoying feature of IDE is "when" interrupts are generated. For any Read operation, once
  1751                        ; the command has been accepted, data is placed into the IDE buffer, followed by generating
  1752                        ; an interrupt to the system. Once this is done, the system will read the data. By accessing the
  1753                        ; Status register, the interrupt will be reset. This is normal operation. For a write operation,
  1754                        ; The command is sent, then DRQ goes active, which requires the data be sent to the IDE Device.
  1755                        ; Once the data is written, an interrupt is generated after it's writing completed.
  1756                        ; As a result, there's little value of having an ISR for servicing the write function.
  1757                        ; As interrupts are enabled for the IDE Controller, all generated interrupts must be handled.
  1758                        ;
  1759                        ; Status Register bits as defined as follows:
  1760                        ;       - Bit 7 = Busy (a Command has been accepted)
  1761                        ;       - Bit 6 = Ready (IDE controller is ready to accept a command)
  1762                        ;       - Bit 5 = Write Fault (A write command failed against the media)
  1763                        ;       - Bit 4 = DSC (is set when a Seek is completed)
  1764                        ;       - Bit 3 = Data Request (set when there is data to transfer, read or write)
  1765                        ;       - Bit 2 = Correction (set when a recoverable data error was corrected)
  1766                        ;       - Bit 1 = 0 (not used)
  1767                        ;       - Bit 0 = Error (set when the previous command had an unrecoverable error)
  1768                        ;
  1769                        ;       NOTE: 25 clock cycles to here if DUART ISR is second!
  1770                        ;
  1771                        INTERUPT1                               ;Interrupt 1 (IDE)
  1772 00:FD4F: AD 76 FE                     LDA     IDE_ALT_STATUS  ;Get Alternate Status Register (4)
  1773 00:FD52: 30 3C                        BMI     REGEXT01        ;If Busy bit active, just exit (2/3)
  1774                        ;
  1775                        ; - Check for Data Request (DRQ), as the Read LBA operation is the main function
  1776                        ;   of the ISR, which will handle the data transfer from the IDE controller to store the
  1777                        ;   data into memory. This ISR will handle single and multiple block transfers.
  1778                        ;
  1779 00:FD54: AD 7F FE                     LDA     IDE_STATUS      ;Get Status (resets IRQ) (4)
  1780 00:FD57: 29 08                        AND     #%00001000      ;Check for DRQ (2)
  1781 00:FD59: D0 08                        BNE     IDE_READ_BLK    ;Branch if active (2/3)
  1782                        ;
  1783                        ; - If no DRQ is sensed, the other possibilities are:
  Mon Apr  3 2023 13:43                                                                                                    Page 36


  1784                        ; 1- A LBA Write has occurred and the interrupt was generated after the transfer.
  1785                        ; 2- A Verify operation has occurred and the interrupt was generated after the verify.
  1786                        ; So we check for these two options and branch accordingly.
  1787                        ;
  1788 00:FD5B: AF FF 35                     BBS2    MATCH,IDE_WRIT_BLK      ;If Bit 2 set, Write operation (5,6)
  1789 00:FD5E: 9F FF 3A                     BBS1    MATCH,IDE_VRFY_BLK      ;If Bit 1 set, Verify operation (5,6)
  1790 00:FD61: 80 2D                        BRA     REGEXT01                ;Exit ISR handler (3)
  1791                        ;
  1792                        IDE_READ_BLK                            ;IDE Read a Block of data
  1793                        ;
  1794                        ;Note: Arrival here means that the DRQ bit in the status register is active.
  1795                        ; This implies that:
  1796                        ;  1- A LBA Block Read is in progress. If so, the data transfer will be handled below.
  1797                        ;     This also handles multiple LBA Reads and manages the pointers and such. It also
  1798                        ;     clears the LBA Read bit in the MATCH Flag when completed.
  1799                        ;
  1800                        ;  2- A LBA Block Write with multilpe blocks is in progress. If so, the actual data
  1801                        ;     transfer is handled via the IDE WRITE Block routine. An interrupt is generated
  1802                        ;     at the end of each LBA transfer, so that is monitored here and the LBA Write bit
  1803                        ;     in the MATCH Flag is cleared when there are no more blocks to transfer.
  1804                        ;
  1805                        ;Also realize that this ISR will be executed every time the DUART generates an interrupt.
  1806                        ; This will happen every 10ms for the Jiffy-Clock timer and for character transmit and receive.
  1807                        ;
  1808 00:FD63: 3F FF 2A                     BBR3    MATCH,REGEXT01  ;If Bit 3 clear, IDE Write (5,6)
  1809                        ;
  1810 00:FD66: AD 76 FE     LBA_XFER        LDA     IDE_ALT_STATUS  ;Get Status (clears IRQ) (4)
  1811 00:FD69: 29 08                        AND     #%00001000      ;Check for DRQ (2)
  1812 00:FD6B: F0 18                        BEQ     IDE_RD_DONE     ;If not active, done, exit (2/3)
  1813                        ;
  1814                        IDE_RD_RBLK
  1815 00:FD6D: AD 78 FE                     LDA     IDE_DATA        ;Read low byte (high byte in latch) (4)
  1816 00:FD70: 92 F9                        STA     (BIOS_XFERL)    ;Store low byte (5)
  1817 00:FD72: E6 F9                        INC     BIOS_XFERL      ;Increment pointers (5)
  1818 00:FD74: D0 02                        BNE     IDE_RD_BLK1     ; (2/3)
  1819 00:FD76: E6 FA                        INC     BIOS_XFERH      ; (5)
  1820                        IDE_RD_BLK1
  1821 00:FD78: AD 74 FE                     LDA     IDE_16_READ     ;Read high byte from latch (4)
  1822 00:FD7B: 92 F9                        STA     (BIOS_XFERL)    ;Store high byte (5)
  1823 00:FD7D: E6 F9                        INC     BIOS_XFERL      ;Increment pointers (5)
  1824 00:FD7F: D0 E5                        BNE     LBA_XFER        ;Loop back to Xfer, saves 3 clock cycles (2/3)
  1825 00:FD81: E6 FA                        INC     BIOS_XFERH      ; (5)
  1826                        IDE_RD_BLK2
  1827 00:FD83: 80 E1                        BRA     LBA_XFER        ;Loop back till no more DRQs (3)
  1828                        ;
  1829 00:FD85: C6 FB        IDE_RD_DONE     DEC     BIOS_XFERC      ;Decrement Block Count to transfer (5)
  1830 00:FD87: D0 02                        BNE     IDE_ALL_DONE    ;Branch around Flag Reset until all blocks moved (2/3)
  1831 00:FD89: 37 FF                        RMB3    MATCH           ;Clear Read Block flag (5)
  1832                        ;
  1833 00:FD8B: AD 76 FE     IDE_ALL_DONE    LDA     IDE_ALT_STATUS  ;Get Alternate Status Register (4)
  1834 00:FD8E: 85 FC                        STA     IDE_STATUS_RAM  ;Save it to RAM location (3)
  1835 00:FD90: 6C 10 03     REGEXT01        JMP     (VECINSRT0)     ;Exit ISR handler (6)
  1836                        ;
  1837                        IDE_WRIT_BLK                            ;IDE Write a Block of data
  1838 00:FD93: A5 FB                        LDA     BIOS_XFERC      ;Check Block Count to transfer (3)
  1839 00:FD95: D0 F4                        BNE     IDE_ALL_DONE    ;Branch to exit if more blocks need to be moved (2/3)
  1840 00:FD97: 27 FF                        RMB2    MATCH           ;Clear Write Block flag (5)
  1841 00:FD99: 80 F0                        BRA     IDE_ALL_DONE    ;Branch and finish ISR (3)
  1842                        ;
  1843                        IDE_VRFY_BLK                            ;IDE Verify a Block of data
  1844 00:FD9B: 17 FF                        RMB1    MATCH           ;Clear Verify Block flag (5)
  1845 00:FD9D: 80 EC                        BRA     IDE_ALL_DONE    ;Branch and finish ISR (3)
  1846                        ;
  Mon Apr  3 2023 13:43                                                                                                    Page 37


  1847                        ;**************************************************************************************************
  1848                        ;
  1849                        ; EPOCH time (Unix) starts on Thursday, 1st January, 1970.
  1850                        ; If no RTC is detected, preload the EPOCH Date as a start.
  1851                        ; Note: No time of day is preloaded, time is 00:00:00 after a cold start.
  1852                        ;
  1853 00:FD9F: C1           EPOCH           .DB     %11000001       ;Day 6 / Date 1
  1854 00:FDA0: 17                           .DB     %00010111       ;Month 1  High byte (nibble) of 1970
  1855 00:FDA1: B2                           .DB     %10110010       ;Low byte of 1970 ($B2)
  1856                        ;
  1857                        ;END OF BIOS CODE for Pages $F8 through $FD
  1858                        ;**************************************************************************************************
  1859                                .ORG    $FE00   ;Reserved for I/O space - do NOT put code here
  1860                        ;There are 5- I/O Selects, each is 32-bytes wide.
  1861                        ; I/O-0 = $FE00-$FE1F  Available on BUS expansion connector
  1862                        ; I/O-1 = $FE20-$FE3F  Available on BUS expansion connector
  1863                        ; I/O-2 = $FE40-$FE5F  Available on BUS expansion connector
  1864                        ; I/O-3 = $FE60-$FE7F  Available on BUS expansion connector - Used for RTC-IDE Adapter!
  1865                        ; I/O-4 = $FE80-$FE9F  SC28L92 DUART resides here (only 16 bytes used)
  1866                        ;
  1867                        ; NOTE: The above hardware selects may well change with C02 Pocket SBC 3!
  1868                        ;**************************************************************************************************
  1869                                .ORG    $FEA0   ;Reserved space for Soft Vector and I/O initialization data
  1870                        ;START OF BIOS DEFAULT VECTOR DATA AND HARDWARE CONFIGURATION DATA
  1871                        ;
  1872                        ;There are 96 bytes of ROM space remaining on page $FE from $FEA0 - $FEFF
  1873                        ; 64 bytes of this are copied to page $03 and used for soft vectors/hardware soft configuration.
  1874                        ; 32 bytes are for vectors and 32 bytes are for hardware config. The last 32 bytes are only held
  1875                        ; in ROM and are used for hardware configuration that should not be changed.
  1876                        ;
  1877                        ;The default location for the NMI/BRK/IRQ Vector data is at $0300. They are defined at the top of
  1878                        ; the source file. There are 8 defined vectors and 8 vector inserts, all are free for base config.
  1879                        ;
  1880                        ;The default location for the hardware configuration data is at $0320. It is a freeform table which
  1881                        ; is copied from ROM to page $03. The allocated size for the hardware config table is 32 bytes.
  1882                        ;
  1883                        VEC_TABLE      ;Vector table data for default ROM handlers
  1884                        ;
  1885 00:FEA0: D1 F9                        .DW     NMI_VECTOR      ;NMI Location in ROM
  1886 00:FEA2: FD FA                        .DW     BRKINSTR0       ;BRK Location in ROM
  1887 00:FEA4: 6B FA                        .DW     INTERUPT0       ;IRQ Location in ROM
  1888                        ;
  1889 00:FEA6: 03 E0                        .DW     M_WARM_MON      ;NMI return handler in ROM
  1890 00:FEA8: 03 E0                        .DW     M_WARM_MON      ;BRK return handler in ROM
  1891 00:FEAA: 98 FF                        .DW     IRQ_EXIT0       ;IRQ return handler in ROM
  1892                        ;
  1893 00:FEAC: 00 E0                        .DW     M_COLD_MON      ;Monitor Cold start
  1894 00:FEAE: 03 E0                        .DW     M_WARM_MON      ;Monitor Warm start
  1895                        ;
  1896                        ;Vector Inserts (total of 8)
  1897                        ; These can be used as required. Note that the IDE init routine will use Insert 0 if a valid
  1898                        ; IDE controller is found and successfully initialized.
  1899                        ; Also, the NMI/BRK/IRQ and the Monitor routines are vectored, so these can also be extended,
  1900                        ; if needed, by using reserved vector locations.
  1901                        ;
  1902 00:FEB0: FF FF                        .DW     $FFFF           ;Insert 0 Location (used if IDE is found)
  1903 00:FEB2: FF FF                        .DW     $FFFF           ;Insert 1 Location
  1904 00:FEB4: FF FF                        .DW     $FFFF           ;Insert 2 Location
  1905 00:FEB6: FF FF                        .DW     $FFFF           ;Insert 3 Location
  1906 00:FEB8: FF FF                        .DW     $FFFF           ;Insert 4 Location
  1907 00:FEBA: FF FF                        .DW     $FFFF           ;Insert 5 Location
  1908 00:FEBC: FF FF                        .DW     $FFFF           ;Insert 6 Location
  1909 00:FEBE: FF FF                        .DW     $FFFF           ;Insert 7 Location
  Mon Apr  3 2023 13:43                                                                                                    Page 38


  1910                        ;
  1911                        ;Configuration Data - The following tables contains the default data used for:
  1912                        ; - Reset of the SC28L92 (RESET_28L92 routine)
  1913                        ; - Init of the SC28L92 (INIT_28L92 routine)
  1914                        ; - Basic details for register definitions are below, consult SC28L92 DataSheet
  1915                        ; - Note: Output Port bits OP0/OP1 must be set for RTS to work on Ports A and B
  1916                        ;
  1917                        ;Mode Register 0 definition
  1918                        ; Bit7          ;Rx Watchdog Control
  1919                        ; Bit6          ;RX-Int(2) Select
  1920                        ; Bit5/4        ;Tx-Int fill level
  1921                        ; Bit3          ;FIFO size
  1922                        ; Bit2          ;Baud Rate Extended II
  1923                        ; Bit1          ;Test 2 (don't use)
  1924                        ; Bit0          ;Baud Rate Extended I
  1925                        ;
  1926                        ;Mode Register 1 definition
  1927                        ; Bit7          ;RxRTS Control - 1 = Yes
  1928                        ; Bit6          ;RX-Int(1) Select
  1929                        ; Bit5          ;Error Mode - 0 = Character
  1930                        ; Bit4/3        ;Parity Mode - 10 = No Parity
  1931                        ; Bit2          ;Parity Type - 0 = Even (doesn't matter)
  1932                        ; Bit1/0        ;Bits Per Character - 11 = 8
  1933                        ;
  1934                        ;Mode Register 2 Definition
  1935                        ; Bit7/6        ;Channel Mode   - 00 = Normal
  1936                        ; Bit5          ;TxRTS Control - 0 = Yes
  1937                        ; Bit4          ;TxCTS Enable - 1 = Yes
  1938                        ; Bit3-0        ;Stop Bits - 0111 = 1 Stop Bit
  1939                        ;
  1940                        ;Baud Rate Clock Definition (Extended Mode I)
  1941                        ; Upper 4 bits = Receive Baud Rate
  1942                        ; Lower 4 bits = Transmit Baud Rate
  1943                        ; for 115.2K setting is %11001100
  1944                        ; Also set ACR Bit7 = 1 for extended rates (115.2K)
  1945                        ;
  1946                        ;Command Register Definition
  1947                        ; Bit7-4        ;Special commands
  1948                        ; Bit3          ;Disable Transmit
  1949                        ; Bit2          ;Enable Transmit
  1950                        ; Bit1          ;Disable Receive
  1951                        ; Bit0          ;Enable Receive
  1952                        ;
  1953                        ;Aux Control Register Definition
  1954                        ; Bit7          ;BRG Set Select - 1 = Extended
  1955                        ; Bit6-5-4      ;Counter/Timer operating mode 110 = Counter mode from XTAL
  1956                        ; Bit3-2-1-0    ;Enable IP3-2-1-0 Change Of State (COS) IRQ
  1957                        ;
  1958                        ;Interrupt Mask Register Definition
  1959                        ; Bit7          ;Input Change Interrupt 1 = On
  1960                        ; Bit6          ;Change Break B Interrupt 1 = On
  1961                        ; Bit5          ;RxRDY B Interrupt 1 = On
  1962                        ; Bit4          ;TxRDY B Interrupt 1 = On
  1963                        ; Bit3          ;Counter Ready Interrupt 1 = On
  1964                        ; Bit2          ;Change Break A Interrupt 1 = On
  1965                        ; Bit1          ;RxRDY A Interrupt 1 = On
  1966                        ; Bit0          ;TxRDY A Interrupt 1 = On
  1967                        ;
  1968                        CFG_TABLE       ;Configuration table for hardware devices
  1969                        ;
  1970                        ;Data commands are sent in reverse order from list. This list is the default initialization for
  1971                        ; the DUART as configured for use as a Console connected to either ExtraPutty(WIN) or Serial(OSX)
  1972                        ; The data here is copied to page $03 and is used to configure the DUART during boot up. The soft
  Mon Apr  3 2023 13:43                                                                                                    Page 39


  1973                        ; data can be changed and the core INIT_28L92 routine can be called to reconfigure the DUART.
  1974                        ; NOTE: the register offset data is not kept in soft config memory as the initialization
  1975                        ; sequence should not be changed!
  1976                        ;
  1977                        ; Both serial ports are configured at startup!
  1978                        ; - Port A is used as the console.
  1979                        ; - Port B is in idle mode.
  1980                        ;
  1981                        INIT_DUART       ;Start of DUART Initialization Data
  1982 00:FEC0: 03                           .DB     %00000011       ;Enable OP0/1 for RTS control Port A/B
  1983 00:FEC1: 0A                           .DB     %00001010       ;Disable Receiver/Disable Transmitter B
  1984 00:FEC2: 09                           .DB     %00001001       ;Enable Receiver/Disable Transmitter A
  1985 00:FEC3: 0F                           .DB     %00001111       ;Interrupt Mask Register setup
  1986 00:FEC4: E0                           .DB     %11100000       ;Aux Register setup for Counter/Timer
  1987 00:FEC5: 48                           .DB     %01001000       ;Counter/Timer Upper Preset
  1988 00:FEC6: 00                           .DB     %00000000       ;Counter/Timer Lower Preset
  1989 00:FEC7: CC                           .DB     %11001100       ;Baud Rate clock for Rcv/Xmt - 115.2K B
  1990 00:FEC8: CC                           .DB     %11001100       ;Baud Rate clock for Rcv/Xmt - 115.2K A
  1991 00:FEC9: 30                           .DB     %00110000       ;Reset Transmitter B
  1992 00:FECA: 20                           .DB     %00100000       ;Reset Receiver B
  1993 00:FECB: 30                           .DB     %00110000       ;Reset Transmitter A
  1994 00:FECC: 20                           .DB     %00100000       ;Reset Receiver A
  1995 00:FECD: 00                           .DB     %00000000       ;Interrupt Mask Register setup
  1996 00:FECE: F0                           .DB     %11110000       ;Command Register A - disable Power Down
  1997                        INIT_DUART_E    ;End of DUART Initialization Data
  1998                        ;
  1999 00:FECF: FF                           .DB     $FF             ;Spare byte for offset to MR data
  2000                        ;
  2001                        ;Mode Register Data is defined separately. Using the loop routine above to send this data to
  2002                        ; the DUART does not work properly. See the description of the problem using Indexed addressing
  2003                        ; to load the DUART registers above. This data is also kept in soft config memory in page $03.
  2004                        ; Note that this data is also in reverse order for loading into MRs!
  2005                        ;
  2006 00:FED0: 17           MR2_DAT_A       .DB     %00010111       ;Mode Register 2 data
  2007 00:FED1: D3           MR1_DAT_A       .DB     %11010011       ;Mode Register 1 Data
  2008 00:FED2: F9           MR0_DAT_A       .DB     %11111001       ;Mode Register 0 Data
  2009                        ;
  2010 00:FED3: 17           MR2_DAT_B       .DB     %00010111       ;Mode Register 2 data
  2011 00:FED4: D3           MR1_DAT_B       .DB     %11010011       ;Mode Register 1 Data
  2012 00:FED5: C1           MR0_DAT_B       .DB     %11000001       ;Mode Register 0 Data
  2013                        ;
  2014                        ;Reserved for additional I/O devices (10 bytes free)
  2015                        ;
  2016 00:FED6: FF FF FF FF                  .DB     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
       00:FEDA: FF FF FF FF 
       00:FEDE: FF FF 
  2017                        ;
  2018                        ;Reset DUART Data is listed here. The sequence and commands do not require changes for any reason.
  2019                        ; These are maintained in ROM only. A total of 32 bytes are available for hard configuration data.
  2020                        ; These are the register offsets and Reset data for the DUART
  2021                        ;
  2022                        UART_RDATA      ;DUART Reset Data for Received Break (ExtraPutty/Serial Break)
  2023 00:FEE0: 01                           .DB     %00000001       ;Enable Receiver
  2024                        ;
  2025                        UART_RDATA1     ;Smaller list for entry level Reset (RESET_28L92)
  2026 00:FEE1: 40                           .DB     %01000000       ;Reset All Errors
  2027 00:FEE2: 30                           .DB     %00110000       ;Reset Transmitter
  2028 00:FEE3: 20                           .DB     %00100000       ;Reset Receiver
  2029 00:FEE4: 50                           .DB     %01010000       ;Reset Break Change Interrupt
  2030                        UART_RDATAE     ;End of DUART Reset Data
  2031                        ;
  2032                        INIT_OFFSET     ;Start of DUART Initialization Register Offsets
  2033 00:FEE5: 0E                           .DB     $0E             ;Set Output Port bits
  Mon Apr  3 2023 13:43                                                                                                    Page 40


  2034 00:FEE6: 0A                           .DB     $0A             ;Command Register B
  2035 00:FEE7: 02                           .DB     $02             ;Command Register A
  2036 00:FEE8: 05                           .DB     $05             ;Interrupt Mask Register
  2037 00:FEE9: 04                           .DB     $04             ;Aux Command Register
  2038 00:FEEA: 06                           .DB     $06             ;Counter Preset Upper
  2039 00:FEEB: 07                           .DB     $07             ;Counter Preset Lower
  2040 00:FEEC: 09                           .DB     $09             ;Baud Clock Register B
  2041 00:FEED: 01                           .DB     $01             ;Baud Clock Register A
  2042 00:FEEE: 0A                           .DB     $0A             ;Command Register Port B
  2043 00:FEEF: 0A                           .DB     $0A             ;Command Register Port B
  2044 00:FEF0: 02                           .DB     $02             ;Command Register Port A
  2045 00:FEF1: 02                           .DB     $02             ;Command Register Port A
  2046 00:FEF2: 05                           .DB     $05             ;Interrupt Mask Register
  2047 00:FEF3: 02                           .DB     $02             ;Command Register Port A
  2048                        INIT_OFFSETE    ;End of DUART Initialization Register Offsets
  2049                        ;
  2050                        ; BIOS 4.0x Data space for software RTC.
  2051                        ;
  2052                        MAX_DATE                                ;Maximum days per Month+1
  2053 00:FEF4: 20 1D 20 1F                  .DB     32,29,32,31,32,31,32,32,31,32,31,32
       00:FEF8: 20 1F 20 20 
       00:FEFC: 1F 20 1F 20 
  2054                        ;
  2055                        ;END OF BIOS VECTOR DATA AND HARDWARE DEFAULT CONFIGURATION DATA
  2056                        ;**************************************************************************************************
  2057                        ;START OF TOP PAGE - DO NOT MOVE FROM THIS ADDRESS!! JUMP Table starts here.
  2058                        ; - BIOS calls are listed below - total of 32, Reserved calls are for future hardware support
  2059                        ; - "B_" JUMP Tables entries are for BIOS routines, provides isolation between Monitor and BIOS
  2060                        ; - Two new calls used for Benchmark Timer, calls 16/17 starting with CO2BIOS 2.02
  2061                        ; - One additional Benchmark Timer call to allow start/stop of timer without resetting it
  2062                        ; - New calls added for IDE Controller and RTC starting with C02BIOS 3.04
  2063                        ; - New calls added for second serial port starting with C02BIOS 4.00
  2064                        ; - New calls added to Enable/Disable IDE Write Cache (Hitachi 3K8 Microdrive) C02BIOS 4.00
  2065                        ; - EXE_XLDLY has been removed, not really used, frees a Page Zero location used for IDE now
  2066                        ;
  2067                        ; NOTE: All Jump table calls add 3 clock cycles to execution time for each BIOS function.
  2068                        ;
  2069                                .ORG    $FF00   ;BIOS JMP Table, Cold Init and Vector handlers
  2070                        ;
  2071 00:FF00: 4C 09 FD     B_IDE_RESET     JMP     IDE_RESET       ;Call 00 $FF00 (3)
  2072 00:FF03: 4C 15 FD     B_IDE_GET_STAT  JMP     IDE_GET_STATUS  ;Call 01 $FF03 (3)
  2073 00:FF06: 4C C9 FC     B_IDE_IDENTIFY  JMP     IDE_IDENTIFY    ;Call 02 $FF06 (3)
  2074 00:FF09: 4C 59 F8     B_IDE_READ_LBA  JMP     IDE_READ_LBA    ;Call 03 $FF09 (3)
  2075 00:FF0C: 4C 7E F8     B_IDE_WRITE_LBA JMP     IDE_WRITE_LBA   ;Call 04 $FF0C (3)
  2076 00:FF0F: 4C C4 F8     B_IDE_VERFY_LBA JMP     IDE_VERIFY_LBA  ;Call 05 $FF0F (3)
  2077 00:FF12: 4C E8 F8     B_IDE_SET_LBA   JMP     IDE_SET_LBA     ;Call 06 $FF12 (3)
  2078 00:FF15: 4C E1 F8     B_IDE_SET_ADDR  JMP     IDE_SET_ADDRESS ;Call 07 $FF15 (3)
  2079 00:FF18: 4C EC FC     B_IDE_EN_CACHE  JMP     IDE_EN_CACHE    ;Call 08 $FF18 (3)
  2080 00:FF1B: 4C 05 FD     B_IDE_DIS_CACHE JMP     IDE_DIS_CACHE   ;Call 09 $FF1B (3)
  2081                        ;
  2082 00:FF1E: 4C 61 F9     B_RTC_NVRD      JMP     RTC_NVRD        ;Call 10 $FF1E (3)
  2083 00:FF21: 4C 6E F9     B_RTC_NVWR      JMP     RTC_NVWR        ;Call 11 $FF21 (3)
  2084 00:FF24: 4C 13 FC     B_RTC_INIT      JMP     INIT_RTC        ;Call 12 $FF24 (3)
  2085                        ;
  2086 00:FF27: 4C 30 F8     B_CHRIN2        JMP     CHRIN2          ;Call 13 $FF27 (3)
  2087 00:FF2A: 4C 42 F8     B_CHROUT2       JMP     CHROUT2         ;Call 14 $FF2A (3)
  2088                        ;
  2089 00:FF2D: 4C 53 F9     B_CNT_INIT      JMP     CNT_INIT        ;Call 15 $FF2D (3)
  2090 00:FF30: 4C 5B F9     B_CNT_STRT      JMP     CNT_STRT        ;Call 16 $FF30 (3)
  2091 00:FF33: 4C 5E F9     B_CNT_STOP      JMP     CNT_STOP        ;Call 17 $FF33 (3)
  2092                        ;
  2093 00:FF36: 4C 00 F8     B_CHRIN_NW      JMP     CHRIN_NW        ;Call 18 $FF36 (3)
  2094 00:FF39: 4C 06 F8     B_CHRIN         JMP     CHRIN           ;Call 19 $FF39 (3)
  Mon Apr  3 2023 13:43                                                                                                    Page 41


  2095 00:FF3C: 4C 19 F8     B_CHROUT        JMP     CHROUT          ;Call 20 $FF3C (3)
  2096                        ;
  2097 00:FF3F: 4C 2B F9     B_SET_DLY       JMP     SET_DLY         ;Call 21 $FF3F (3)
  2098 00:FF42: 4C 32 F9     B_EXE_MSDLY     JMP     EXE_MSDLY       ;Call 22 $FF42 (3)
  2099 00:FF45: 4C 3E F9     B_EXE_LGDLY     JMP     EXE_LGDLY       ;Call 23 $FF45 (3)
  2100                        ;
  2101 00:FF48: 4C B3 FF     B_RESERVE       JMP     RESERVE         ;Call 24 $FF48 (3)
  2102                        ;
  2103 00:FF4B: 4C A3 FF     B_INIT_VEC      JMP     INIT_VEC        ;Call 25 $FF4B (3)
  2104 00:FF4E: 4C 9F FF     B_INIT_CFG      JMP     INIT_CFG        ;Call 26 $FF4E (3)
  2105 00:FF51: 4C 95 F9     B_INIT_28L92    JMP     INIT_28L92      ;Call 27 $FF51 (3)
  2106 00:FF54: 4C C2 F9     B_RESET_28L92   JMP     RESET_28L92     ;Call 28 $FF54 (3)
  2107                        ;
  2108 00:FF57: 6C 0E 03     B_WRMMNVEC0     JMP     (WRMMNVEC0)     ;Call 29 $FF57 (3)
  2109 00:FF5A: 6C 0C 03     B_CLDMNVEC0     JMP     (CLDMNVEC0)     ;Call 30 $FF5A (3)
  2110                        ;
  2111                        B_COLDSTRT                              ;Call 31 $FF5D
  2112 00:FF5D: 78                           SEI                     ;Disable Interrupts (safety) (2)
  2113 00:FF5E: D8                           CLD                     ;Clear decimal mode (safety) (2)
  2114 00:FF5F: A2 00                        LDX     #$00            ;Index for length of page (256 bytes) (2)
  2115 00:FF61: 74 00        PAGE0_LP        STZ     $00,X           ;Clear Page Zero (4)
  2116 00:FF63: CA                           DEX                     ;Decrement index (2)
  2117 00:FF64: D0 FB                        BNE     PAGE0_LP        ;Loop back till done (2/3)
  2118 00:FF66: CA                           DEX                     ;LDX #$FF ;-) (2)
  2119 00:FF67: 9A                           TXS                     ;Set Stack Pointer (2)
  2120                        ;
  2121 00:FF68: 20 9C FF                     JSR     INIT_PG03       ;Xfer default Vectors/HW Config to Page $03 (6)
  2122 00:FF6B: 20 8E F9                     JSR     INIT_IO         ;Init I/O - DUART (Console/Timer) (6)
  2123                        ;
  2124                        ; Send BIOS init msg to console - note: X Reg is zero on return from INIT_IO
  2125                        ;
  2126 00:FF6E: BD D0 FF     BMSG_LP         LDA     BIOS_MSG,X      ;Get BIOS init msg (4)
  2127 00:FF71: F0 06                        BEQ     CHECK_IO        ;If zero, msg done, Test for extra I/O (2/3)
  2128 00:FF73: 20 19 F8                     JSR     CHROUT          ;Send to console (6)
  2129 00:FF76: E8                           INX                     ;Increment Index (2)
  2130 00:FF77: 80 F5                        BRA     BMSG_LP         ;Loop back until done (3)
  2131                        CHECK_IO
  2132 00:FF79: 20 E7 FB                     JSR     DETECT_RTC      ;Detect and Init RTC (6)
  2133 00:FF7C: 20 8B FC                     JSR     DETECT_IDE      ;Detect and Init IDE (6)
  2134 00:FF7F: 20 B3 FF                     JSR     RESERVE         ;Reserve one more Init routine for future use (6)
  2135 00:FF82: 80 D6                        BRA     B_CLDMNVEC0     ;Branch to Coldstart Monitor (3)
  2136                        ;
  2137                        ;This front end for the IRQ vector, saves the CPU registers and determines if a BRK
  2138                        ; instruction was the cause. There are 25 clock cycles to jump to the IRQ vector,
  2139                        ; and there are 26 clock cycles to jump to the BRK vector. Note that there is an
  2140                        ; additional 18 clock cycles for the IRQ return vector, which restores the registers.
  2141                        ; This creates an overhead of 43 (IRQ) or 44 (BRK) clock cycles, plus whatever the
  2142                        ; ISR or BRK service routines add.
  2143                        ;
  2144                        IRQ_VECTOR                              ;This is the ROM start for the BRK/IRQ handler
  2145 00:FF84: 48                           PHA                     ;Save A Reg (3)
  2146 00:FF85: DA                           PHX                     ;Save X Reg (3)
  2147 00:FF86: 5A                           PHY                     ;Save Y Reg (3)
  2148 00:FF87: BA                           TSX                     ;Get Stack pointer (2)
  2149 00:FF88: BD 04 01                     LDA     $0100+4,X       ;Get Status Register (4)
  2150 00:FF8B: 29 10                        AND     #$10            ;Mask for BRK bit set (2)
  2151 00:FF8D: D0 03                        BNE     DO_BRK          ;If set, handle BRK (2/3)
  2152 00:FF8F: 6C 04 03                     JMP     (IRQVEC0)       ;Jump to Soft vectored IRQ Handler (6)
  2153 00:FF92: 6C 02 03     DO_BRK          JMP     (BRKVEC0)       ;Jump to Soft vectored BRK Handler (6)
  2154                        ;
  2155 00:FF95: 6C 00 03     NMI_ROM         JMP     (NMIVEC0)       ;Jump to Soft vectored NMI handler (6)
  2156                        ;
  2157                        ;This is the standard return for the IRQ/BRK handler routines (18 clock cycles)
  Mon Apr  3 2023 13:43                                                                                                    Page 42


  2158                        ;
  2159 00:FF98: 7A           IRQ_EXIT0       PLY                     ;Restore Y Reg (4)
  2160 00:FF99: FA                           PLX                     ;Restore X Reg (4)
  2161 00:FF9A: 68                           PLA                     ;Restore A Reg (4)
  2162 00:FF9B: 40                           RTI                     ;Return from IRQ/BRK routine (6)
  2163                        ;
  2164 00:FF9C: 20 A3 FF     INIT_PG03       JSR     INIT_VEC        ;Init the Soft Vectors first (6)
  2165 00:FF9F: A0 40        INIT_CFG        LDY     #$40            ;Get offset to Config data (2)
  2166 00:FFA1: 80 02                        BRA     DATA_XFER       ;Go move the Config data to page $03 (3)
  2167                        ;
  2168 00:FFA3: A0 20        INIT_VEC        LDY     #$20            ;Get offset to Vector data (2)
  2169 00:FFA5: 78           DATA_XFER       SEI                     ;Disable Interrupts, can be called via JMP table (2)
  2170 00:FFA6: A2 20                        LDX     #$20            ;Set count for 32 bytes (2)
  2171 00:FFA8: B9 9F FE     DATA_XFLP       LDA     VEC_TABLE-1,Y   ;Get ROM table data (4)
  2172 00:FFAB: 99 FF 02                     STA     SOFTVEC-1,Y     ;Store in Soft table location (4)
  2173 00:FFAE: 88                           DEY                     ;Decrement index (2)
  2174 00:FFAF: CA                           DEX                     ;Decrement count (2)
  2175 00:FFB0: D0 F6                        BNE     DATA_XFLP       ;Loop back till done (2/3)
  2176 00:FFB2: 58                           CLI                     ;Re-enable interrupts (2)
  2177 00:FFB3: 60           RESERVE         RTS                     ;Return to caller (6)
  2178                        ;
  2179                        RTC_MSG
  2180                        ;
  2181                        ;This is a short BIOS message that is displayed when the DS15x1 RTC is found
  2182 00:FFB4: 52 54 43 20                  .DB     "RTC found"
       00:FFB8: 66 6F 75 6E 
       00:FFBC: 64 
  2183 00:FFBD: 0D 0A 00                     .DB     $0D,$0A,$00
  2184                        ;
  2185                        IDE_MSG
  2186                        ;
  2187                        ;This is a short BIOS message that is displayed when the IDE controller is found
  2188 00:FFC0: 49 44 45 20                  .DB     "IDE found"
       00:FFC4: 66 6F 75 6E 
       00:FFC8: 64 
  2189 00:FFC9: 0D 0A 00                     .DB     $0D,$0A,$00
  2190                        ;
  2191                        ;The offset data here is used as an index to the Identity Block of Data from the IDE controller
  2192 00:FFCC: 78 79 7A 7B  LBA_OFFSET      .DB     120,121,122,123 ;Offset Data for LBA Size
  2193                        ;
  2194                        ;This BIOS version does not rely on CPU clock frequency for RTC timing. Timing is based on the
  2195                        ; SC28L92 DUART Timer/Counter which has a fixed frequency of 3.6864MHz. Jiffy clock set at 10ms.
  2196                        ; Edit Displayed clock rate at CPU_CLK below as needed if running "other" than 8MHz.
  2197                        ;
  2198                                .ORG    $FFD0   ;Hard coded BIOS message to the top of memory (Monitor uses this)
  2199                        ;
  2200                        ;BIOS init message - sent before jumping to the monitor coldstart vector.
  2201                        ; CO2BIOS 2.01 and later, provides a BIOS message with more detail, fixed length/location!
  2202                        ;
  2203 00:FFD0: 0D 0A        BIOS_MSG        .DB     $0D,$0A         ;CR/LF
  2204 00:FFD2: 43 30 32 42                  .DB     "C02BIOS 4.02"  ;Updated Release Version
       00:FFD6: 49 4F 53 20 
       00:FFDA: 34 2E 30 32 
  2205 00:FFDE: 0D 0A                        .DB     $0D,$0A         ;CR/LF
  2206 00:FFE0: 57 36 35 43                  .DB     "W65C02@"       ;Display CPU type
       00:FFE4: 30 32 40 
  2207 00:FFE7: 38 4D 48 7A  CPU_CLK         .DB     "8MHz"          ;Displayed CPU Clock frequency
  2208 00:FFEB: 0D 0A                        .DB     $0D,$0A         ;CR/LF
  2209 00:FFED: 30 33 2F 30                  .DB     "03/04/2023"    ;DD/MM/YYYY
       00:FFF1: 34 2F 32 30 
       00:FFF5: 32 33 
  2210 00:FFF7: 0D 0A 00                     .DB     $0D,$0A,$00     ;CR/LF and terminate string
  2211                        ;
  Mon Apr  3 2023 13:43                                                                                                    Page 43


  2212                                .ORG    $FFFA   ;W65C02 Vectors:
  2213                        ;
  2214 00:FFFA: 95 FF                        .DW     NMI_ROM         ;NMI
  2215 00:FFFC: 5D FF                        .DW     B_COLDSTRT      ;RESET
  2216 00:FFFE: 84 FF                        .DW     IRQ_VECTOR      ;IRQ/BRK
  2217                                .END


      Lines assembled: 2633
      Errors: 0
