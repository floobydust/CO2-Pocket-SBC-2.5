  Sun Sep  5 2021 20:58                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C02 Macro Assembler    **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                                pw      132
     2                                pl      66
     3                                case    off
     4                                chip    W65C02S
     5                        ;XSBC123
     6                        ;When code is configured it is recommended that
     7                        ;a copy of the executable be named XMODEM.COM
     8                        ;for consistency with example and help.
     9                        ;Special version of xmodem for direct communication
    10                        ;with computer at 115,200 bps using SCC2691 UART interface
    11                        ;Modified for C02 Pocket SBC
    12                        ; no need to initialize the hardware.
    13                        ;Version 1.00 By David Robinson CIS 71505,1172
    14                        ;Based on MODEM.ASM by Ward Christensen
    15                        ; Minor modifications by Kevin Maier
    16                        ;
    17                        ;last revision: 8 January 1984 by R. Leary (1.01)
    18                        ;                       eliminated msize and pages dependence
    19                        ;                       added const result check and #$ff
    20                        ;                       corrected several errors
    21                        ;                       made easily adaptable
    22                        ;               13 March 1984 by R. Leary (1.02)
    23                        ;                       added relative user set
    24                        ;               24 November 1984 by R. Leary (1.03)
    25                        ;                       changed io page
    26                        ;                       clear page zero data area
    27                        ;               24 May 1986 by R. Leary (1.04)
    28                        ;                       corrected problems in original
    29                        ;               25 December 1988 by R. Leary (1.05)
    30                        ;                       converted to user 3
    31                        ;                       corrected error near csabor
    32                        ;                       added printer spooling
    33                        ;               9 March 2008 by R. Leary (1.06)
    34                        ;                       corrected spelling
    35                        ;                       reformatted for TASM & ASM210 & up
    36                        ;               24 April 2014 by R. Leary (1.07)
    37                        ;                       changed to User 1
    38                        ;                       deleted old printer port info
    39                        ;                       set print to do nothing
    40                        ;                       corrected many spelling errors
    41                        ;               27 April 2014 by R. Leary (1.08)
    42                        ;                       added lower to upper case routine
    43                        ;                       added call to SIM for printer output
    44                        ;                       made keyboard interaction consistent
    45                        ;                               RETURN (ENTER) --> continue
    46                        ;                               CTRL-C --> abort transfer
    47                        ;                               CTRL-E --> quit a boot
    48                        ;                               R --> retry
    49                        ;                               Y --> yes
    50                        ;               3 November 2014 by R. Leary (1.10)
    51                        ;                       converted IO to SERIAL IO Port A
    52                        ;                       converted to WDC syntax
    53                        ;                       did some 65C02 opcode conversion
    54                        ;               6 December 2014 by R.Leary (1.20)
    55                        ;                       corrected one second timing for 2.5 MHz CPU clock
    56                        ;                       started effort to improve speed
    57                        ;                       incorporated V1.11 changes
  Sun Sep  5 2021 20:58                                                                                                    Page 2


    58                        ;               5 March 2016 (1.21) Rich Leary
    59                        ;                       restored check for nulls in RCVSQ
    60                        ;                       corrected timing loop near nochar
    61                        ;                       eliminated view and see sub-options
    62                        ;                       changed wait to bufind in places
    63                        ;               26 June 2017 (1.22)
    64                        ;                       pasted in sxbbind and stdio
    65                        ;                       changed port calls to WDC
    66                        ;                       changed one second timing
    67                        ;                       changed pzstrt to 5
    68                        ;                       enabled "TRANSFER COMPLETE" IN Q MODE
    69                        ;               28 July 2017 (1.22S)
    70                        ;                       converted to SBC2
    71                        ;               29 jULY 2017 (1.23s)
    72                        ;                       ELIMINATED GARBAGE getc CALLS
    73                        ;               15 March 2021
    74                        ;                       Modified for C02 Pocket SBC
    75                        ;user defined parameters - mostly port definitions
    76                        ;dos/65 parameters
    77             00000030   pzstrt  equ     $30             ;first usable page zero location
    78             00000100   boot    equ     $100            ;warm boot jmp
    79             00000103   pem     equ     $103            ;pem jmp
    80             00000107   fcb     equ     $107            ;fcb address
    81             00000117   fcb2    equ     fcb+16          ;fcb #2
    82             00000127   fcbsno  equ     fcb+32          ;fcb sector number
    83             00000113   fcbext  equ     fcb+12          ;fcb extent
    84             00000128   buffer  equ     $128            ;Default buffer address
    85             00000800   tea     equ     $800            ;execution org
    86                        ;
    87                        ;Page zero equates
    88                        ;
    89                                page0
    90                                org     pzstrt
    91 00:0030:              STROAD  ds      2               ;pointer in ilprt
    92 00:0032:              WAIT    ds      1
    93 00:0033:              bufind  ds      1               ;buffer index
    94 00:0034:              ERRCNT  ds      1
    95 00:0035:              SECINB  ds      1
    96 00:0036:              RCVSNO  ds      1
    97 00:0037:              EOFLR   ds      1
    98 00:0038:              CSUM    ds      1
    99 00:0039:              EOFLG   ds      1
   100 00:003A:              inner   ds      1               ;inner loop timing counter
   101 00:003B:              outer   ds      1               ;outer loop timing counter
   102 00:003C:              seconds ds      1               ;time out in seconds
   103 00:003D:              tmpsec  ds      1               ;temporary hold for received record number
   104 00:003E:              from    ds      2               ;move from pointer
   105 00:0040:              to      ds      2               ;move to pointer
   106 00:0042:              tmpchr  ds      1               ;temp for received character
   107 00:0043:              seccnt  ds      1               ;sector counter
   108 00:0044:              sndcnt  ds      1               ;byte counter
   109 00:0045:              tmpcsm  ds      1               ;temp checksum
   110                        lastzp
   111 00:0046:                      ends
   112                        ;
   113                        ;Define some other things (normally not changed)
   114                        ;
   115             0000000A   ERRLIM  equ     10              ;max # of errors
   116             00000005   EXITCH  equ     05              ;Exit from T or C
   117             00000004   DISCHR  equ     04              ;Disconnects modem
   118                        ;
   119                        ;Define PEM equates
   120             00000009   PRINT   equ     09              ;Print till $ in line
  Sun Sep  5 2021 20:58                                                                                                    Page 3


   121             0000000F   OPEN    equ     15              ;$FF = Not Found
   122             00000010   CLOSE   equ     16              ; "     "
   123             00000011   SRCHF   equ     17              ; "     "  (Search first)
   124             00000012   SCRHN   equ     18              ; "     "  (Search next )
   125             00000013   ERASE   equ     19              ;No return code
   126             00000014   READ    equ     20              ;0 = ok, 1 = EOF
   127             00000015   WRITE   equ     21              ;"      "       $FF=No dir spc
   128             00000016   MAKE    equ     22              ;$FF = Bad
   129             00000017   REN     equ     23              ;"      "
   130             0000001A   STDMA   equ     26              ;Set buffer address
   131                        ;Define ASCII characters used
   132             00000001   SOH     equ     01              ;Start of header
   133             00000003   CTRLC   equ     03              ;Control-C
   134             00000004   EOT     equ     04              ;End of transmission
   135             00000005   CTRLE   equ     05              ;control-e
   136             00000006   ACK     equ     06              ;Acknowledge
   137             00000008   BS      equ     08              ;backspace
   138             00000009   TAB     equ     09              ;Tab
   139             0000000A   LF      equ     $0A             ;Linefeed
   140             0000000D   CR      equ     $0D             ;Carriage return
   141             00000015   NAK     equ     $15             ;Neg acknowledge
   142             00000018   CAN     equ     $18             ;Cancel
   143             00000020   space   equ     $20             ;blank
   144                        ;
   145                        ;Main Program
   146                        ;
   147                                        code
   148                                        org     tea
   149 00:0800: 4C 5C 08                     jmp     start           ;jump to main routine
   150                        ;direct jumps to sim routines
   151 00:0803: 4C 06 00     const           jmp     6               ;console status
   152 00:0806: 4C 09 00     conin           jmp     9               ;read console input
   153 00:0809: 4C 0C 00     conot           jmp     12              ;write to console
   154 00:080C: 4C 0F 00     prnot           jmp     15              ;write to printer
   155                        ;set direct sim jump to correct page
   156 00:080F: AD 02 01     setsim          lda     boot+2          ;get upper address
   157 00:0812: 8D 05 08                     sta     const+2         ;then set
   158 00:0815: 8D 08 08                     sta     conin+2
   159 00:0818: 8D 0B 08                     sta     conot+2
   160 00:081B: 8D 0E 08                     sta     prnot+2
   161                        
   162 00:081E: AD 01 01                     lda     boot+1          ;get lower address
   163 00:0821: 18                           clc                     ;clear carry for add
   164 00:0822: 69 03                        adc     #$03            ;add 3 for next jmp
   165 00:0824: 8D 04 08                     sta     const+1         ;then set
   166 00:0827: 69 03                        adc     #$03
   167 00:0829: 8D 07 08                     sta     conin+1
   168 00:082C: 69 03                        adc     #$03
   169 00:082E: 8D 0A 08                     sta     conot+1
   170 00:0831: 69 03                        adc     #$03
   171 00:0833: 8D 0D 08                     sta     prnot+1
   172 00:0836: 60                           rts
   173                        ;sxbbind.asm
   174                        ;print character in A to stdout
   175                        ;keep X and Y, but not necessarily S
   176 00:0837: 4C 3C FF     PUTC            JMP     $FF3C           ;Call C02 BIOS
   177                        ;
   178                        ;check for character ready at input
   179                        ;returns a=0 and z=0 if none and a=1 and z-0 if ready
   180                        mon_consts
   181 00:083A: A5 D7        CHKC            LDA     $D7             ;Check BIOS 4.0 Input count
   182 00:083C: F0 02                        BEQ     NO_CHR          ;If zero, exit, no data
   183 00:083E: A9 01                        LDA     #$01            ;say ready
  Sun Sep  5 2021 20:58                                                                                                    Page 4


   184 00:0840: 60           NO_CHR          RTS
   185                        
   186                        ;wait until character ready then get character
   187                        ;WAITC          jsr     CHKC            ;see if character
   188                        ;               beq     WAITC           ;loop if none ekse
   189                        ;get a character from stdin
   190                        ;call only after CHKC says character is ready
   191                        ;keep X and Y, but not necessarily S
   192                        ;C=0 on return is ok, C=1 on return is eof
   193 00:0841: 20 39 FF     GETC            JSR     $FF39           ;Call C02 BIOS
   194 00:0844: 18                           CLC
   195 00:0845: 60                           RTS
   196                                        ;
   197                        ;       OUTPUT: Output to console device
   198 00:0846: 29 7F        output  and     #$7f            ;set the high bit to zero
   199 00:0848: C9 08                cmp     #bs             ;pass a backspace
   200 00:084A: F0 0C                beq     out1
   201 00:084C: C9 0D                cmp     #cr             ;pass a cr
   202 00:084E: F0 08                beq     out1
   203 00:0850: C9 0A                cmp     #lf             ;pass a lf
   204 00:0852: F0 04                beq     out1
   205 00:0854: C9 20                cmp     #space          ;don't print control codes
   206 00:0856: 90 03                bcc     out2
   207 00:0858: 20 F4 09     out1    jsr     conout          ;print the char
   208 00:085B: 60           out2    rts
   209                        ;main program execution starts here
   210 00:085C: 20 0F 08     start   jsr     setsim          ;set jump addresses to sim
   211                        ;clear page zero data area
   212 00:085F: A2 30                ldx     #pzstrt         ;set index to start
   213 00:0861: A9 00                lda     #0              ;clear accum
   214 00:0863: 95 00        clrlpe  sta     $00,x           ;clear a byte
   215 00:0865: E8                   inx                     ;bump index
   216 00:0866: E0 46                cpx     #lastzp         ;see if end
   217 00:0868: D0 F9                bne     clrlpe          ;loop if not
   218 00:086A: 20 CF 10             jsr     ilprt           ;print opening message
   219 00:086D: 58 53 42 43          byte    "XSBC123 (XMODEM) - VERSION 1.23",cr,lf
       00:0871: 31 32 33 20 
       00:0875: 28 58 4D 4F 
       00:0879: 44 45 4D 29 
       00:087D: 20 2D 20 56 
       00:0881: 45 52 53 49 
       00:0885: 4F 4E 20 31 
       00:0889: 2E 32 33 0D 
       00:088D: 0A 
   220 00:088E: 46 4F 52 20          byte    "FOR UART PORT @ 115,200 BPS"
       00:0892: 55 41 52 54 
       00:0896: 20 50 4F 52 
       00:089A: 54 20 40 20 
       00:089E: 31 31 35 2C 
       00:08A2: 32 30 30 20 
       00:08A6: 42 50 53 
   221 00:08A9: 0D 0A 0A 00          byte    cr,lf,lf,0
   222 00:08AD: AD 08 01             lda     fcb+1           ;get primary option
   223 00:08B0: C9 48                cmp     #'H'
   224 00:08B2: D0 03                bne     n1
   225 00:08B4: 4C 0B 12             jmp     help            ;Yes, give help
   226 00:08B7: C9 58        n1      cmp     #'X'
   227 00:08B9: D0 03                bne     n2
   228 00:08BB: 4C 60 14             jmp     exam            ;Give examples
   229                        ;
   230                        ;Save primary option, validate secondary option
   231                        ;
   232 00:08BE: 20 44 11     N2      jsr     procop
  Sun Sep  5 2021 20:58                                                                                                    Page 5


   233                        ;
   234                        ;move the file name from fcb 2 to fcb 1
   235                        ;
   236 00:08C1: 20 7C 11             jsr     movfcb
   237                        ;
   238                        ;initialize the serial port
   239                        ;
   240 00:08C4: 20 F9 09             jsr     intmod          ;initialize port and modem
   241                        ;
   242                        ;Jmp to appropriate function
   243                        ;
   244 00:08C7: AD 71 11             lda     option          ;recover the pri option
   245 00:08CA: C9 43                cmp     #'C'            ;"COMPUTER" term echo
   246 00:08CC: D0 03                bne     op1             ;look for more
   247 00:08CE: 4C 3B 09             jmp     trmech          ;go to term echo
   248 00:08D1: C9 45        OP1     cmp     #'E'            ;terminal in echo
   249 00:08D3: D0 03                bne     op2             ;branch if not
   250 00:08D5: 4C 3B 09             jmp     trmech          ;terminal in echo
   251 00:08D8: C9 54        OP2     cmp     #'T'            ;terminal mode?
   252 00:08DA: D0 03                bne     op3
   253 00:08DC: 4C FE 08             jmp     term            ;go to terminal mode
   254 00:08DF: C9 44        OP3     cmp     #'D'            ;disconnect?
   255 00:08E1: D0 03                bne     op4             ;branch if no
   256 00:08E3: 4C 61 10             jmp     discon          ;disconnect
   257 00:08E6: C9 53        OP4     cmp     #'S'            ;send a file?
   258 00:08E8: D0 03                bne     op5             ;no ->
   259 00:08EA: 4C 66 09             jmp     senfil          ;go send file
   260 00:08ED: C9 52        OP5     cmp     #'R'            ;receive a file?
   261 00:08EF: D0 03                bne     op6             ;no ->
   262 00:08F1: 4C 9C 09             jmp     rcvfil          ;go receive a file
   263 00:08F4: C9 50        op6     cmp     #'P'            ;print input
   264 00:08F6: D0 03                bne     op7             ;no ->
   265 00:08F8: 4C 1F 09             jmp     prndta          ;go print file
   266 00:08FB: 4C AA 11     OP7     jmp     badopt          ;none left, error exit
   267                        ;
   268                        ;*      TERM: Terminal mode              *
   269                        ;
   270                        ;This program simply sends keyed characters
   271                        ;down the line, and displays characters
   272                        ;received from the line. This makes it
   273                        ;suitable for communication with time sharing
   274                        ;computers, CBBS's, or another program
   275                        ;running "XMODEM E" (echo mode)
   276                        ;
   277                        ;Type CTRL-E to exit and warm boot.
   278                        ;
   279                        ;NOTE: The "DISCCHR" has not been implemented in
   280                        ;this version of MODEM.
   281                        ;
   282 00:08FE: 20 3A 08     term    jsr     chkc            ;test for byte ready
   283 00:0901: F0 06                beq     ckkeys          ;none ready
   284 00:0903: 20 41 08             jsr     getc            ;get modem byte
   285 00:0906: 20 46 08             jsr     output          ;output to screen
   286 00:0909: 20 03 08     ckkeys  jsr     const           ;look for keys pressed
   287 00:090C: 29 FF                and     #$ff            ;test result
   288 00:090E: F0 EE                beq     term            ;no keys, check modem again
   289 00:0910: 20 EE 09             jsr     coninp          ;get the key pressed
   290 00:0913: C9 05                cmp     #ctrle          ;check for escape code
   291 00:0915: D0 03                bne     keys1           ;branch if not
   292 00:0917: 4C 00 01             jmp     boot            ;end
   293 00:091A: 20 37 08     keys1   jsr     putc            ;output it to modem
   294 00:091D: 80 DF                bra     term            ;go back to modem input
   295                        ;
  Sun Sep  5 2021 20:58                                                                                                    Page 6


   296                        ;prndta: printer spooler
   297                        ;
   298                        ;Type CTRL-E to exit and warm boot.
   299                        ;
   300 00:091F: 20 3A 08     prndta  jsr     chkc            ;test for byte ready
   301 00:0922: F0 06                beq     chkkey          ;none ready
   302 00:0924: 20 41 08             jsr     getc            ;get modem byte
   303 00:0927: 20 0C 08             jsr     prnot           ;send char to printer
   304 00:092A: 20 03 08     chkkey  jsr     const           ;look for keys pressed
   305 00:092D: 29 FF                and     #$ff            ;test result
   306 00:092F: F0 EE                beq     prndta          ;no keys, check modem again
   307 00:0931: 20 EE 09             jsr     coninp          ;get the key pressed
   308 00:0934: C9 05                cmp     #ctrle          ;check for escape code
   309 00:0936: D0 E7                bne     prndta          ;loop if not
   310 00:0938: 4C 00 01             jmp     boot            ;end
   311                        ;
   312                        ;*      TRMECHO: Terminal with echo  *
   313                        ;
   314                        ;Terminal program with echo - see notes
   315                        ;under "TERM" above
   316                        ;
   317                        ;C A U T I O N  Don't run with both computers
   318                        ;in "ECHO" mode - line errors (or any char)
   319                        ;will be echoed back and forth ad infinitum.
   320                        ;
   321 00:093B: 20 3A 08     trmech  jsr     chkc            ;check input status
   322 00:093E: F0 0B                beq     ckkey1          ;branch if no input
   323 00:0940: 20 41 08             jsr     getc            ;get modem byte
   324 00:0943: 48                   pha                     ;save it
   325 00:0944: 20 37 08             jsr     putc            ;echo it
   326 00:0947: 68                   pla                     ;get it back
   327 00:0948: 20 46 08             jsr     output          ;output to screen
   328 00:094B: 20 03 08     CKKEY1  jsr     const           ;look for keys pressed
   329 00:094E: 29 FF                and     #$ff            ;test result
   330 00:0950: F0 E9                beq     trmech          ;no keys, check modem again
   331 00:0952: 20 EE 09             jsr     coninp          ;get the key pressed
   332 00:0955: C9 05                cmp     #ctrle          ;check for escape code
   333 00:0957: D0 03                bne     keys2           ;branch if not
   334 00:0959: 4C 00 01             jmp     boot            ;exit
   335 00:095C: 48           KEYS2   pha                     ;save it
   336 00:095D: 20 37 08             jsr     putc            ;output it to modem
   337 00:0960: 68                   pla                     ;get it again
   338 00:0961: 20 46 08             jsr     output          ;put it on the screen
   339 00:0964: 80 D5                bra     trmech          ;go back for modem input
   340                        ;
   341                        ;*      SENDFIL: Sends a DOS/65 file         *
   342                        ;
   343                        ;The DOS/65 file specified in the modem command
   344                        ;is transferred over the phone to another
   345                        ;computer running XMODEM with the "R"
   346                        ;(receive) option. The data is sent one sector
   347                        ;at a time with headers and checksums, and
   348                        ;re-transmission on errors.
   349                        ;
   350 00:0966: 20 0F 0E     SENFIL  jsr     trap            ;check for no name or ambig
   351 00:0969: 20 7D 0B             jsr     openfi          ;open the file
   352 00:096C: A9 FF                lda     #255            ;wait up to 255 secs for..
   353 00:096E: 85 32                sta     wait            ;..initial NAK
   354 00:0970: 20 CB 0B             jsr     waitna          ;get initial NAK
   355                        ;
   356 00:0973: 20 F9 0B     SENDLP  jsr     rdsect          ;read a sector
   357 00:0976: B0 17                bcs     seneof          ;send EOF if done
   358 00:0978: EE 7B 11             inc     secnum          ;bump sector #
  Sun Sep  5 2021 20:58                                                                                                    Page 7


   359 00:097B: A9 00                lda     #0              ;init error..
   360 00:097D: 85 34                sta     errcnt          ;..count
   361                        ;
   362 00:097F: 20 9F 0C     SENRPT  jsr     senhdr          ;send a header
   363 00:0982: 20 CB 0C             jsr     sensec          ;send the data sector
   364 00:0985: 20 E4 0C             jsr     sencks          ;send the checksum
   365 00:0988: 20 06 0D             jsr     getack          ;get the ACK
   366 00:098B: B0 F2                bcs     senrpt          ;repeat if no ACK
   367 00:098D: 90 E4                bcc     sendlp          ;loop until EOF
   368                        ;
   369                        ;
   370                        ;File sent, send EOT's
   371                        ;
   372 00:098F: A9 04        SENEOF  lda     #EOT            ;send..
   373 00:0991: 20 7F 0F             jsr     send1           ;.. an EOT
   374 00:0994: 20 06 0D             jsr     getack          ;get the ACK
   375 00:0997: B0 F6                bcs     seneof          ;repeat if no ACK
   376 00:0999: 4C 0A 10             jmp     done            ;all done
   377                        ;
   378                        ;*      RCVFIL: Receive a file               *
   379                        ;
   380                        ;Receive a file in block format as sent
   381                        ;by another person doing "XMODEM S fn.ft".
   382                        ;
   383 00:099C: 20 0F 0E     RCVFIL  jsr     trap            ;check for no name or ambig name
   384 00:099F: 20 B5 0D             jsr     erasfi          ;erase the file
   385 00:09A2: 20 68 0D             jsr     makefi          ;..then make new
   386 00:09A5: 20 CF 10             jsr     ilprt           ;print
   387 00:09A8: 46 49 4C 45          byte    "FILE OPEN, READY TO RECEIVE",cr,lf,0
       00:09AC: 20 4F 50 45 
       00:09B0: 4E 2C 20 52 
       00:09B4: 45 41 44 59 
       00:09B8: 20 54 4F 20 
       00:09BC: 52 45 43 45 
       00:09C0: 49 56 45 0D 
       00:09C4: 0A 00 
   388                        ;
   389 00:09C6: 20 FB 09     RCVLP   jsr     rcvsec          ;get a sector
   390 00:09C9: B0 0C                bcs     rcveot          ;got end of transmission
   391 00:09CB: 20 A5 0E             jsr     wrsec           ;save the sector
   392 00:09CE: EE 7B 11             inc     secnum          ;bump the sector number
   393 00:09D1: 20 74 0B             jsr     sendac          ;send the ack
   394 00:09D4: 4C C6 09             jmp     rcvlp           ;loop until end of file
   395                        ;
   396                        ;Got EOT on sector - flush buffers, end
   397                        ;
   398 00:09D7: 20 D1 0E     RCVEOT  jsr     wrbloc          ;write the last block
   399 00:09DA: 20 74 0B             jsr     sendac          ;ack the sector
   400 00:09DD: 20 72 0E             jsr     closef          ;close the file
   401 00:09E0: 4C 0A 10             jmp     done            ;print message & return
   402                        ;
   403                        ;*              SUBROUTINES                      *
   404                        ;convert character in a from lower case to upper case
   405 00:09E3: C9 61        lwrupr  cmp     #'a'            ;if < a
   406 00:09E5: 90 06                bcc     notlc           ;then ok
   407 00:09E7: C9 7B                cmp     #'z'+1          ;if > z
   408 00:09E9: B0 02                bcs     notlc           ;then ok
   409 00:09EB: 29 5F                and     #$5f            ;else convert
   410 00:09ED: 60           notlc   rts
   411                        ;console input and output with msb clear
   412                        ;input
   413 00:09EE: 20 06 08     coninp  jsr     conin           ;go to sim
   414 00:09F1: 29 7F                and     #$7f            ;clear msb
  Sun Sep  5 2021 20:58                                                                                                    Page 8


   415 00:09F3: 60                   rts
   416                        ;output
   417 00:09F4: 29 7F        conout  and     #$7f            ;clear msb
   418 00:09F6: 4C 09 08             jmp     conot           ;go to sim
   419                        ;modem input, output, and status routines
   420                        ;initialize modem and port
   421                        ;Initial version leaves just a NOP and a RTS
   422 00:09F9: EA           intmod  nop                     ;do nothing
   423 00:09FA: 60                   rts
   424                        ;
   425                        ;---->  RCVSECT: Receive a sector
   426                        ;
   427                        ;Returns with carry set if EOT received
   428                        ;
   429 00:09FB: A9 00        RCVSEC  lda     #0              ;init error count
   430 00:09FD: 85 34                sta     errcnt
   431                        ;
   432 00:09FF: AD 77 11     RCVRPT  lda     qflg            ;quiet?
   433 00:0A02: F0 1A                beq     rcvsq           ;yes, no stat msg.
   434 00:0A04: 20 CF 10             jsr     ilprt           ;print
   435 00:0A07: 41 57 41 49          byte    "AWAITING #",0
       00:0A0B: 54 49 4E 47 
       00:0A0F: 20 23 00 
   436 00:0A12: AD 7B 11             lda     secnum          ;get sector number
   437 00:0A15: 18                   clc                     ;add 1
   438 00:0A16: 69 01                adc     #1              ;(real later)
   439 00:0A18: 20 C0 0F             jsr     hexo            ;print in hex
   440 00:0A1B: 20 64 10             jsr     crlf            ;then cr/lf
   441                        ;
   442 00:0A1E: A9 0A        RCVSQ   lda     #10             ;10 sec time out
   443 00:0A20: 85 3C                sta     seconds         ;save it
   444 00:0A22: 20 41 0F             jsr     recv            ;get SOH/EOT
   445 00:0A25: B0 37                bcs     rcvser          ;time out
   446 00:0A27: C9 00                cmp     #0              ;ignore nulls
   447 00:0A29: F0 D4                beq     rcvrpt
   448 00:0A2B: C9 01                cmp     #SOH            ;got SOH?
   449 00:0A2D: F0 06                beq     rcv1            ;yes, go ->
   450 00:0A2F: C9 04                cmp     #EOT            ;end of transfer?
   451 00:0A31: D0 05                bne     r1              ;no, go try again
   452 00:0A33: 38                   sec                     ;yes,.. EOT
   453 00:0A34: 60                   rts                     ;from rcvsec
   454                        ;
   455 00:0A35: 4C D3 0A     RCV1    jmp     rcvsoh
   456                        ;
   457                        ;Didn't get SOH or EOT -
   458                        ;
   459 00:0A38: 85 42        R1      sta     tmpchr          ;save char received
   460 00:0A3A: AD 77 11             lda     qflg            ;quiet mode?
   461 00:0A3D: F0 1F                beq     rcvser          ;yes, ->
   462 00:0A3F: A5 42        RCVSEH  lda     tmpchr          ;restore char rcvd
   463 00:0A41: 20 C0 0F             jsr     hexo            ;print hex char
   464 00:0A44: 20 CF 10             jsr     ilprt           ;tell user
   465 00:0A47: 48 24 20 52          byte    "H$ RECEIVED, NOT SOH",cr,lf,0
       00:0A4B: 45 43 45 49 
       00:0A4F: 56 45 44 2C 
       00:0A53: 20 4E 4F 54 
       00:0A57: 20 53 4F 48 
       00:0A5B: 0D 0A 00 
   466                        ;
   467                        ;Didn't get valid header - purge the line,
   468                        ;then send NAK.
   469                        ;
   470 00:0A5E: 20 3B 0F     RCVSER  jsr     onesec          ;wait one second for character
  Sun Sep  5 2021 20:58                                                                                                    Page 9


   471 00:0A61: 90 FB                bcc     rcvser          ;loop until sender done
   472 00:0A63: E6 34                inc     errcnt          ;abort if we
   473 00:0A65: A5 34                lda     errcnt          ;have reached
   474 00:0A67: C9 0A                cmp     #errlim         ;the error limit
   475 00:0A69: 90 0A                bcc     rcvck2          ;no, try again
   476                        ;
   477                        ;10 errors in a row
   478                        ;
   479 00:0A6B: AD 77 11             lda     qflg            ;quiet mode?
   480 00:0A6E: F0 0D                beq     rcvsab          ;yes, ->
   481 00:0A70: 20 71 10     RCVCKQ  jsr     ckquit          ;Quit?
   482 00:0A73: D0 08                bne     rcvsab          ;yes, quit ->
   483                        ;
   484                        ;Line must be purged because sender probably started
   485                        ;resending while operator answered RETRY/QUIT prompt.
   486                        ;
   487 00:0A75: A9 15        RCVCK2  lda     #NAK            ;send a NAK
   488 00:0A77: 20 7F 0F             jsr     send1
   489 00:0A7A: 4C FF 09             jmp     rcvrpt          ;try again ->
   490                        ;
   491 00:0A7D: 20 72 0E     RCVSAB  jsr     closef          ;keep whatever we got
   492 00:0A80: 20 CF 10             jsr     ilprt           ;abort
   493 00:0A83: 2B 2B 55 4E          byte    "++UNABLE TO RECEIVE BLOCK "
       00:0A87: 41 42 4C 45 
       00:0A8B: 20 54 4F 20 
       00:0A8F: 52 45 43 45 
       00:0A93: 49 56 45 20 
       00:0A97: 42 4C 4F 43 
       00:0A9B: 4B 20 
   494 00:0A9D: 2D 20 41 42          byte    "- ABORTING++",cr,lf,0
       00:0AA1: 4F 52 54 49 
       00:0AA5: 4E 47 2B 2B 
       00:0AA9: 0D 0A 00 
   495 00:0AAC: 4C 31 10             jmp     erxit           ;quit
   496                        ;Time out on receive
   497 00:0AAF: AD 77 11     RCVSTO  lda     qflg            ;Quiet mode?
   498 00:0AB2: D0 03                bne     rcvspt          ;no, ->
   499 00:0AB4: 4C 5E 0A             jmp     rcvser          ;quiet ->
   500                        ;
   501 00:0AB7: 20 CF 10     RCVSPT  jsr ilprt               ;tell about it
   502 00:0ABA: 2B 2B 54 49          byte    "++TIME OUT++",0
       00:0ABE: 4D 45 20 4F 
       00:0AC2: 55 54 2B 2B 
       00:0AC6: 00 
   503                        ;
   504 00:0AC7: A5 34        RCVPRN  lda     errcnt          ;get error count
   505 00:0AC9: 20 C0 0F             jsr     hexo            ;print it
   506 00:0ACC: 20 64 10             jsr     crlf            ;clean up line
   507 00:0ACF: 4C 5E 0A             jmp     rcvser          ;try again
   508                        ;
   509 00:0AD2: 00           BLK     byte    0
   510                        ;
   511                        ;
   512                        ;Got SOH - get block #, block # complimented
   513                        ;
   514 00:0AD3: 20 3B 0F     RCVSOH  jsr     onesec          ;wait 1 sec for char
   515 00:0AD6: B0 D7                bcs     rcvsto          ;time out
   516 00:0AD8: 8D D2 0A             sta     blk             ;save block number
   517 00:0ADB: 20 3B 0F             jsr     onesec          ;go back for EOR blk #
   518 00:0ADE: B0 CF                bcs     rcvsto          ;time out
   519 00:0AE0: 85 3D                sta     tmpsec          ;save complemented block #
   520 00:0AE2: A9 FF                lda     #$ff            ;do a ones compliment
   521 00:0AE4: 45 3D                eor     tmpsec          ;on it
  Sun Sep  5 2021 20:58                                                                                                    Page 10


   522 00:0AE6: CD D2 0A             cmp     blk             ;is it the same?
   523 00:0AE9: F0 28                beq     rcvdat          ;yes, get data
   524                        ;
   525                        ;Got bad sector #
   526                        ;
   527 00:0AEB: AD 77 11             lda     qflg            ;ck quiet flag
   528 00:0AEE: F0 20                beq     r2              ;yes, ->
   529                        ;
   530 00:0AF0: 20 CF 10     RCVBSE  jsr     ilprt           ;tell story
   531 00:0AF3: 2B 2B 42 41          byte    "++BAD SECTOR # IN HEADER++",cr,lf,0
       00:0AF7: 44 20 53 45 
       00:0AFB: 43 54 4F 52 
       00:0AFF: 20 23 20 49 
       00:0B03: 4E 20 48 45 
       00:0B07: 41 44 45 52 
       00:0B0B: 2B 2B 0D 0A 
       00:0B0F: 00 
   532 00:0B10: 4C 5E 0A     R2      jmp     rcvser          ;bump error count
   533                        ;
   534 00:0B13: AD D2 0A     RCVDAT  lda     blk             ;get sector number
   535 00:0B16: 85 36                sta     rcvsno          ;save it
   536 00:0B18: A9 00                lda     #0              ;init checksum
   537 00:0B1A: 85 38                sta     csum            ;count
   538 00:0B1C: A2 00                ldx     #0              ;set up buffer pointer
   539 00:0B1E: 86 33                stx     bufind          ;and hold it
   540                        ;
   541 00:0B20: 20 3B 0F     RCVCHR  jsr     onesec          ;wait for a char
   542 00:0B23: B0 2B                bcs     rcv2            ;time out
   543 00:0B25: A6 33                ldx     bufind          ;restore X pointer
   544 00:0B27: 9D 28 01             sta     buffer,x        ;save the character
   545 00:0B2A: E6 33                inc     bufind          ;bump the pointer
   546 00:0B2C: E8                   inx                     ;has it been 128 chars?
   547 00:0B2D: E0 80                cpx     #128
   548 00:0B2F: D0 EF                bne     rcvchr          ;no, go get the rest
   549 00:0B31: A5 38                lda     csum            ;verify checksum
   550 00:0B33: 85 45                sta     tmpcsm          ;save it for a while
   551 00:0B35: 20 3B 0F             jsr     onesec          ;get the checksum
   552 00:0B38: B0 16                bcs     rcv2            ;time out
   553 00:0B3A: C5 45                cmp     tmpcsm          ;is it the same?
   554 00:0B3C: D0 15                bne     rcvcer          ;no, try again
   555                        ;
   556                        ;Got a sector, it's a dup if = prev,
   557                        ;       or ok if = 1 + prev sector
   558                        ;
   559 00:0B3E: A5 36                lda     rcvsno          ;verify the sector number
   560 00:0B40: 85 3D                sta     tmpsec          ;hold it for a while
   561 00:0B42: AD 7B 11             lda     secnum          ;compare the two
   562 00:0B45: C5 3D                cmp     tmpsec
   563 00:0B47: F0 25                beq     recvac          ;same sector
   564 00:0B49: 1A                   inc     a               ;add one to it
   565 00:0B4A: C5 3D                cmp     tmpsec          ;should be the same
   566 00:0B4C: D0 2C                bne     abt             ;no match, abort
   567 00:0B4E: 18                   clc                     ;carry off
   568 00:0B4F: 60                   rts                     ;from rcvsec
   569                        ;
   570 00:0B50: 4C AF 0A     RCV2    jmp     rcvsto
   571                        ;
   572                        ;Got Checksum
   573                        ;
   574 00:0B53: AD 77 11     RCVCER  lda     qflg            ;quiet?
   575 00:0B56: D0 03                bne     rcvcpr          ;no, ->
   576 00:0B58: 4C 5E 0A             jmp     rcvser          ;quiet ->
   577                        ;
  Sun Sep  5 2021 20:58                                                                                                    Page 11


   578 00:0B5B: 20 CF 10     RCVCPR  jsr     ilprt           ;tell message
   579 00:0B5E: 2B 2B 43 48          byte    "++CHECKSUM++",0
       00:0B62: 45 43 4B 53 
       00:0B66: 55 4D 2B 2B 
       00:0B6A: 00 
   580 00:0B6B: 4C C7 0A             jmp     rcvprn          ;go ->
   581                        ;
   582                        ;Previous sector repeated, due to the last ACK
   583                        ;being garbage. ACK it so sender will catch up
   584                        ;
   585 00:0B6E: 20 74 0B     RECVAC  jsr     sendac          ;acknowledge the sector
   586 00:0B71: 4C FB 09             jmp     rcvsec          ;go for more
   587 00:0B74: A9 06        SENDAC  lda     #ack            ;send the
   588 00:0B76: 20 7F 0F             jsr     send1           ;acknowledgement
   589 00:0B79: 60                   rts
   590 00:0B7A: 4C DF 0F     ABT     jmp     abort           ;abort transfer
   591                        ;
   592                        ;---->  OPENFIL: Opens the file to be sent.
   593                        ;
   594 00:0B7D: A9 07        OPENFI  lda     #<fcb           ;point to the file
   595 00:0B7F: A0 01                ldy     #>fcb           ;to open
   596 00:0B81: A2 0F                ldx     #open           ;get the function
   597 00:0B83: 20 03 01             jsr     pem             ;open the file
   598 00:0B86: 10 1A                bpl     openok          ;open ok?
   599 00:0B88: 20 CF 10             jsr     ilprt           ;no, print message..
   600 00:0B8B: 43 41 4E 20          byte    "CAN NOT OPEN FILE",cr,lf,0
       00:0B8F: 4E 4F 54 20 
       00:0B93: 4F 50 45 4E 
       00:0B97: 20 46 49 4C 
       00:0B9B: 45 0D 0A 00 
   601 00:0B9F: 4C 31 10             jmp     erxit           ;get out
   602 00:0BA2: 20 CF 10     OPENOK  jsr     ilprt           ;print...
   603 00:0BA5: 46 49 4C 45          byte    "FILE OPEN, EXTENT LENGTH: $",0
       00:0BA9: 20 4F 50 45 
       00:0BAD: 4E 2C 20 45 
       00:0BB1: 58 54 45 4E 
       00:0BB5: 54 20 4C 45 
       00:0BB9: 4E 47 54 48 
       00:0BBD: 3A 20 24 00 
   604 00:0BC1: AD 16 01             lda     fcb+15          ;get the number of sectors
   605 00:0BC4: 20 C0 0F             jsr     hexo            ;print it
   606 00:0BC7: 20 64 10             jsr     crlf            ;clean up the line
   607 00:0BCA: 60                   rts
   608                        ;
   609                        ;---->  WAITNAK: Waits for initial NAK
   610                        ;3
   611                        ;To ensure no data is sent until the receiving
   612                        ;program is ready, this routine waits for
   613                        ;the first time out-NAK from the receiver.
   614                        ;(WAIT) contains the # of seconds to wait.
   615                        ;
   616 00:0BCB: AD 77 11     WAITNA  lda     qflg            ;quiet mode?
   617 00:0BCE: F0 1A                beq     waitnl          ;yes, ->
   618 00:0BD0: 20 CF 10     WAITNP  jsr     ilprt           ;print...
   619 00:0BD3: 41 57 41 49          byte    "AWAITING INITIAL NAK",cr,lf,0
       00:0BD7: 54 49 4E 47 
       00:0BDB: 20 49 4E 49 
       00:0BDF: 54 49 41 4C 
       00:0BE3: 20 4E 41 4B 
       00:0BE7: 0D 0A 00 
   620 00:0BEA: 20 3B 0F     WAITNL  jsr     onesec          ;wait one sec for NAK
   621 00:0BED: C9 15                cmp     #NAK            ;did we get it?
   622 00:0BEF: D0 01                bne     nonak           ;no, ->
  Sun Sep  5 2021 20:58                                                                                                    Page 12


   623 00:0BF1: 60                   rts                     ;yes, return
   624 00:0BF2: C6 32        NONAK   dec     wait            ;drop the count
   625 00:0BF4: D0 F4                bne     waitnl          ;if not time out, ->
   626 00:0BF6: 4C DF 0F             jmp     abort           ;time out, abort ->
   627                        ;
   628                        ;---->  RDSECT: Reads a sector.
   629                        ;
   630                        ;For speed this routine buffers up 16
   631                        ;sectors at a time.
   632                        ;
   633 00:0BF9: C6 35        RDSECT  dec     secinb          ;see if any sectors in buffer
   634 00:0BFB: 30 25                bmi     rdbloc          ;get more ->
   635 00:0BFD: AD 79 11             lda     secptr          ;point to the data buffer
   636 00:0C00: AC 7A 11             ldy     secptr+1
   637 00:0C03: 85 3E                sta     from            ;set up for a move
   638 00:0C05: 84 3F                sty     from+1
   639 00:0C07: A9 28                lda     #<buffer        ;destination buffer address
   640 00:0C09: A0 01                ldy     #>buffer
   641 00:0C0B: 85 40                sta     to              ;for the move
   642 00:0C0D: 84 41                sty     to+1
   643 00:0C0F: 20 9D 11             jsr     mov128          ;move a sector to buffer
   644 00:0C12: 18                   clc                     ;set up for an add
   645 00:0C13: AD 79 11             lda     secptr          ;to point to the next
   646 00:0C16: 69 80                adc     #128            ;sector to move
   647 00:0C18: 8D 79 11             sta     secptr          ;save it
   648 00:0C1B: 90 04                bcc     rds1            ;no carry, ->
   649 00:0C1D: EE 7A 11             inc     secptr+1        ;bump high pointer
   650 00:0C20: 18                   clc                     ;say ok
   651 00:0C21: 60           RDS1    rts                     ;from rdsect
   652 00:0C22: A5 39        RDBLOC  lda     eoflg           ;get EOF flag
   653 00:0C24: C9 01                cmp     #1              ;is it set?
   654 00:0C26: D0 02                bne     rdb1            ;no, ->
   655 00:0C28: 38                   sec                     ;carry set for EOF
   656 00:0C29: 60                   rts
   657 00:0C2A: A9 00        RDB1    lda     #0              ;initialize sector counter
   658 00:0C2C: 85 43                sta     seccnt
   659 00:0C2E: A9 81                lda     #<dbuf          ;set up destination address
   660 00:0C30: A0 15                ldy     #>dbuf          ;for transfer
   661 00:0C32: 85 40                sta     to              ;save it..
   662 00:0C34: 84 41                sty     to+1
   663 00:0C36: A5 40        RDSECL  lda     to              ;get the address for DOS
   664 00:0C38: A4 41                ldy     to+1
   665 00:0C3A: A2 1A                ldx     #stdma          ;get the function
   666 00:0C3C: 20 03 01             jsr     pem             ;set the DMA address
   667 00:0C3F: A9 07                lda     #<fcb           ;point to the...
   668 00:0C41: A0 01                ldy     #>fcb           ;...fcb file
   669 00:0C43: A2 14                ldx     #read           ;get read function
   670 00:0C45: 20 03 01             jsr     pem             ;read sector into memory
   671 00:0C48: F0 20                beq     rdseco          ;read ok, ->
   672 00:0C4A: 10 35                bpl     reof            ;found EOF, ->
   673 00:0C4C: 20 CF 10             jsr     ilprt           ;file error, print..
   674 00:0C4F: 0D 0A 2B 2B          byte    cr,lf,"++FILE READ ERROR++",cr,lf,0
       00:0C53: 46 49 4C 45 
       00:0C57: 20 52 45 41 
       00:0C5B: 44 20 45 52 
       00:0C5F: 52 4F 52 2B 
       00:0C63: 2B 0D 0A 00 
   675 00:0C67: 4C 31 10             jmp     erxit           ;get out
   676 00:0C6A: 18           RDSECO  clc                     ;add the length..
   677 00:0C6B: A5 40                lda     to              ;..of one sector..
   678 00:0C6D: 69 80                adc     #128            ;..to the next..
   679 00:0C6F: 85 40                sta     to              ;..buffer
   680 00:0C71: A5 41                lda     to+1
  Sun Sep  5 2021 20:58                                                                                                    Page 13


   681 00:0C73: 69 00                adc     #0
   682 00:0C75: 85 41                sta     to+1
   683 00:0C77: E6 43                inc     seccnt          ;increment the counter
   684 00:0C79: A5 43                lda     seccnt          ;16 yet?
   685 00:0C7B: C9 10                cmp     #16
   686 00:0C7D: F0 08                beq     rdbful          ;yes, ->
   687 00:0C7F: D0 B5                bne     rdsecl          ;no, read some more
   688 00:0C81: A9 01        REOF    lda     #1              ;set the EOF flag
   689 00:0C83: 85 39                sta     eoflg
   690 00:0C85: A5 43                lda     seccnt          ;get the sector load count
   691 00:0C87: 85 35        RDBFUL  sta     secinb          ;save the sector count
   692 00:0C89: A9 81                lda     #<dbuf          ;initialize the buffer
   693 00:0C8B: A0 15                ldy     #>dbuf          ;pointer
   694 00:0C8D: 8D 79 11             sta     secptr          ;save it
   695 00:0C90: 8C 7A 11             sty     secptr+1
   696 00:0C93: A9 28                lda     #<buffer        ;reset the DMA address
   697 00:0C95: A0 01                ldy     #>buffer
   698 00:0C97: A2 1A                ldx     #stdma          ;get the DMA function
   699 00:0C99: 20 03 01             jsr     pem             ;reset DMA address
   700 00:0C9C: 4C F9 0B             jmp     rdsect          ;go, ->
   701                        ;
   702                        ;---->  SENHDR: Send record header
   703                        ;
   704 00:0C9F: AD 77 11     SENHDR  lda     qflg            ;quiet mode?
   705 00:0CA2: F0 13                beq     sendhn          ;yes, ->
   706 00:0CA4: 20 CF 10             jsr     ilprt           ;print...
   707 00:0CA7: 53 45 4E 44          byte    "SEND #",0
       00:0CAB: 20 23 00 
   708 00:0CAE: AD 7B 11             lda     secnum          ;get sector #
   709 00:0CB1: 20 C0 0F             jsr     hexo            ;print it
   710 00:0CB4: 20 64 10             jsr     crlf            ;clean up
   711 00:0CB7: A9 01        SENDHN  lda     #SOH            ;send...
   712 00:0CB9: 20 7F 0F             jsr     send1           ;...SOH,
   713 00:0CBC: AD 7B 11             lda     secnum          ;then send..
   714 00:0CBF: 20 7F 0F             jsr     send1           ;sector #
   715 00:0CC2: A9 FF                lda     #$FF            ;then sector #
   716 00:0CC4: 4D 7B 11             eor     secnum          ;complemented
   717 00:0CC7: 20 7F 0F             jsr     send1           ;..sector #
   718 00:0CCA: 60                   rts                     ;from SENDHDR
   719                        ;
   720                        ;---->  SENDSEC: Send the data sector
   721                        ;
   722 00:0CCB: A2 00        SENSEC  ldx     #0              ;init checksum
   723 00:0CCD: 86 38                stx     csum            ;.. and..
   724 00:0CCF: 86 33                stx     bufind          ;buffer offset
   725 00:0CD1: A9 80                lda     #128            ;set up counter..
   726 00:0CD3: 85 44                sta     sndcnt          ;for # of bytes
   727 00:0CD5: A6 33        SENDC   ldx     bufind          ;get offset into buffer
   728 00:0CD7: BD 28 01             lda     buffer,x        ;get data
   729 00:0CDA: E6 33                inc     bufind          ;bump offset
   730 00:0CDC: 20 7F 0F             jsr     send1           ;send data
   731 00:0CDF: C6 44                dec     sndcnt          ;drop counter
   732 00:0CE1: D0 F2                bne     sendc           ;not done, ->
   733 00:0CE3: 60                   rts                     ;from Sendsec
   734                        ;
   735                        ;Send the checksum
   736                        ;
   737 00:0CE4: A5 38        SENCKS  lda     csum            ;get the checksum
   738 00:0CE6: 4C 7F 0F             jmp     send1           ;send it
   739                        ;
   740                        ;Time out getting ACK
   741                        ;
   742 00:0CE9: AD 77 11     GETTOT  lda     qflg            ;quiet mode
  Sun Sep  5 2021 20:58                                                                                                    Page 14


   743 00:0CEC: F0 4C                beq     ackerr          ;yes, ->
   744 00:0CEE: 20 CF 10             jsr     ilprt           ;print..
   745 00:0CF1: 54 49 4D 45          byte    "TIME OUT ON ACK",cr,lf,0
       00:0CF5: 20 4F 55 54 
       00:0CF9: 20 4F 4E 20 
       00:0CFD: 41 43 4B 0D 
       00:0D01: 0A 00 
   746 00:0D03: 4C 3A 0D             jmp     ackerr          ;abort
   747                        ;
   748                        ;---->  GETACK: Get the ACK on the sector
   749                        ;
   750                        ;Returns with carry clear if ACK received.
   751                        ;if an ACK is not received, the error count
   752                        ;is incremented, and if less than "ERRLIM",
   753                        ;carry is set and control returns. If the
   754                        ;error count is at "ERRLIM", the program
   755                        ;aborts if in "QUIET" mode, or asks the
   756                        ;user for quit/retry if not.
   757                        ;
   758 00:0D06: A9 0A        GETACK  lda     #10             ;wait ten secs...
   759 00:0D08: 85 3C                sta     seconds         ;..MAX
   760 00:0D0A: 20 41 0F             jsr     recvdg          ;recv w/garbage collect
   761 00:0D0D: B0 DA                bcs     gettot          ;timed out, ->
   762 00:0D0F: C9 06                cmp     #ACK            ;ok?
   763 00:0D11: D0 02                bne     getak1          ;no, error ->
   764 00:0D13: 18                   clc                     ;carry off
   765 00:0D14: 60                   rts                     ;ok, ->
   766 00:0D15: 48           GETAK1  pha                     ;hold char recv'd
   767 00:0D16: AD 77 11             lda     qflg            ;quiet mode?
   768 00:0D19: F0 1E                beq     acker2          ;yes, ->
   769 00:0D1B: 68                   pla                     ;get char recv'd
   770 00:0D1C: 48                   pha                     ;save it again
   771 00:0D1D: 20 C0 0F             jsr     hexo            ;print it in Hex
   772 00:0D20: 20 CF 10             jsr     ilprt           ;print mess..
   773 00:0D23: 48 20 52 45          byte    "H RECEIVED, NOT ACK",cr,lf,0
       00:0D27: 43 45 49 56 
       00:0D2B: 45 44 2C 20 
       00:0D2F: 4E 4F 54 20 
       00:0D33: 41 43 4B 0D 
       00:0D37: 0A 00 
   774 00:0D39: 68           ACKER2  pla                     ;clean up stack
   775 00:0D3A: E6 34        ACKERR  inc     errcnt          ;bump the error count
   776 00:0D3C: A5 34                lda     errcnt          ;10 errors?
   777 00:0D3E: C9 0A                cmp     #errlim
   778 00:0D40: F0 02                beq     acker1          ;yes, ->
   779 00:0D42: 38                   sec                     ;show error,
   780 00:0D43: 60                   rts                     ;return, not at limit
   781 00:0D44: AD 77 11     ACKER1  lda     qflg            ;quiet mode?
   782 00:0D47: F0 07                beq     csabor          ;yes, abort transfer
   783 00:0D49: 20 71 10     GACKV   jsr     ckquit          ;see if user wants to quit
   784 00:0D4C: D0 02                bne     csabor          ;yes they do
   785 00:0D4E: 38                   sec                     ;no, try again
   786 00:0D4F: 60                   rts
   787 00:0D50: 20 CF 10     CSABOR  jsr     ilprt           ;print..
   788 00:0D53: 54 49 4D 45          byte    "TIME OUT ON ACK",cr,lf,0
       00:0D57: 20 4F 55 54 
       00:0D5B: 20 4F 4E 20 
       00:0D5F: 41 43 4B 0D 
       00:0D63: 0A 00 
   789 00:0D65: 4C 31 10             jmp     erxit           ;abort transfer ->
   790                        ;
   791                        ;----> MAKEFILE: Makes the file to be received.
   792                        ;
  Sun Sep  5 2021 20:58                                                                                                    Page 15


   793 00:0D68: A9 07        MAKEFI  lda     #<fcb           ;load a & y with
   794 00:0D6A: A0 01                ldy     #>fcb           ;the fcb address
   795 00:0D6C: A2 16                ldx     #make           ;set x to make a file
   796 00:0D6E: 20 03 01             jsr     pem             ;make the file
   797 00:0D71: 10 41                bpl     mak1            ;ok, file made ->
   798 00:0D73: 20 CF 10             jsr     ilprt           ;tell the user the bad news
   799 00:0D76: 2B 2B 45 52          byte    "++ERROR - CAN NOT MAKE FILE++",cr,lf
       00:0D7A: 52 4F 52 20 
       00:0D7E: 2D 20 43 41 
       00:0D82: 4E 20 4E 4F 
       00:0D86: 54 20 4D 41 
       00:0D8A: 4B 45 20 46 
       00:0D8E: 49 4C 45 2B 
       00:0D92: 2B 0D 0A 
   800 00:0D95: 2B 2B 44 49          byte    "++DIRECTORY MAY BE FULL++",cr,lf,0
       00:0D99: 52 45 43 54 
       00:0D9D: 4F 52 59 20 
       00:0DA1: 4D 41 59 20 
       00:0DA5: 42 45 20 46 
       00:0DA9: 55 4C 4C 2B 
       00:0DAD: 2B 0D 0A 00 
   801 00:0DB1: 4C 31 10             jmp     erxit           ;get out
   802 00:0DB4: 60           MAK1    rts                     ;done with makefile
   803                        ;
   804                        ;----> ERASEFILE: Erase the incoming file.
   805                        ;
   806                        ;If it exist, ask if it may be erased.
   807                        ;
   808 00:0DB5: A9 07        ERASFI  lda     #<fcb           ;point a & y to the
   809 00:0DB7: A0 01                ldy     #>fcb           ;fcb address
   810 00:0DB9: A2 11                ldx     #srchf          ;set x to look for file
   811 00:0DBB: 20 03 01             jsr     pem             ;search for file name
   812 00:0DBE: 30 4E                bmi     er1             ;if not found then ->
   813 00:0DC0: 20 CF 10             jsr     ilprt           ;give the message
   814 00:0DC3: 46 49 4C 45          byte    "FILE EXISTS, TYPE Y TO ERASE "
       00:0DC7: 20 45 58 49 
       00:0DCB: 53 54 53 2C 
       00:0DCF: 20 54 59 50 
       00:0DD3: 45 20 59 20 
       00:0DD7: 54 4F 20 45 
       00:0DDB: 52 41 53 45 
       00:0DDF: 20 
   815 00:0DE0: 4F 54 48 45          byte    "OTHER TO QUIT",cr,lf,0
       00:0DE4: 52 20 54 4F 
       00:0DE8: 20 51 55 49 
       00:0DEC: 54 0D 0A 00 
   816 00:0DF0: 20 EE 09             jsr     coninp          ;get the input
   817 00:0DF3: 48                   pha                     ;save it
   818 00:0DF4: 20 46 08             jsr     output          ;print it
   819 00:0DF7: 20 64 10             jsr     crlf            ;clean up the line
   820 00:0DFA: 68                   pla                     ;get char back
   821 00:0DFB: 20 E3 09             jsr     lwrupr          ;convert to upper case
   822 00:0DFE: C9 59                cmp     #'Y'            ;was it 'yes'
   823 00:0E00: F0 03                beq     er2             ;yes, ->
   824 00:0E02: 4C 31 10             jmp     ckdis           ;no, get out
   825 00:0E05: A9 07        ER2     lda     #<fcb           ;set a & y to the
   826 00:0E07: A0 01                ldy     #>fcb           ;fcb address
   827 00:0E09: A2 13                ldx     #erase          ;set x to erase
   828 00:0E0B: 20 03 01             jsr     pem             ;erase the file name
   829 00:0E0E: 60           ER1     rts                     ;from erasefile
   830                        ;
   831                        ;----> TRAP: Check for no file name or ambiguous name
   832                        ;
  Sun Sep  5 2021 20:58                                                                                                    Page 16


   833 00:0E0F: A2 01        TRAP    ldx     #1              ;point to 1st char in fcb
   834 00:0E11: BD 07 01             lda     fcb,x           ;get it
   835 00:0E14: C9 20                cmp     #space          ;is it blank?
   836 00:0E16: D0 23                bne     atrap           ;no, the names there
   837 00:0E18: 20 CF 10             jsr     ilprt           ;tell the user
   838 00:0E1B: 2B 2B 4E 4F          byte    "++NO FILE NAME SPECIFIED++",cr,lf,0
       00:0E1F: 20 46 49 4C 
       00:0E23: 45 20 4E 41 
       00:0E27: 4D 45 20 53 
       00:0E2B: 50 45 43 49 
       00:0E2F: 46 49 45 44 
       00:0E33: 2B 2B 0D 0A 
       00:0E37: 00 
   839 00:0E38: 4C 31 10             jmp     erxit           ;get out
   840 00:0E3B: BD 07 01     ATRAP   lda     fcb,x           ;now look for ambig
   841 00:0E3E: C9 3F                cmp     #'?'            ;chars in file name
   842 00:0E40: F0 06                beq     trerr           ;branch if found
   843 00:0E42: E8                   inx                     ;bump the pointer
   844 00:0E43: E0 0B                cpx     #11             ;looked at all chars yet?
   845 00:0E45: D0 F4                bne     atrap           ;no ->
   846 00:0E47: 60                   rts                     ;from TRAP
   847 00:0E48: 20 CF 10     TRERR   jsr     ilprt           ;tell the user
   848 00:0E4B: 2B 2B 43 41          byte    "++CAN NOT USE WILD CARD"
       00:0E4F: 4E 20 4E 4F 
       00:0E53: 54 20 55 53 
       00:0E57: 45 20 57 49 
       00:0E5B: 4C 44 20 43 
       00:0E5F: 41 52 44 
   849 00:0E62: 20 4F 50 54          byte    " OPTIONS++",cr,lf,0
       00:0E66: 49 4F 4E 53 
       00:0E6A: 2B 2B 0D 0A 
       00:0E6E: 00 
   850 00:0E6F: 4C 31 10             jmp     erxit           ;bad exit form TRAP
   851                        ;
   852                        ;----> CLOSEFILE: Closes the received file.
   853                        ;
   854 00:0E72: A9 07        CLOSEF  lda     #<fcb           ;a & y point
   855 00:0E74: A0 01                ldy     #>fcb           ;to the file
   856 00:0E76: A2 10                ldx     #close          ;set x to close code
   857 00:0E78: 20 03 01             jsr     pem             ;close the file
   858 00:0E7B: 10 27                bpl     clo1            ;if OK ->
   859 00:0E7D: 20 CF 10             jsr     ilprt           ;give error message
   860 00:0E80: 2B 2B 43 41          byte    "++CAN NOT CLOSE FILE - ERROR++"
       00:0E84: 4E 20 4E 4F 
       00:0E88: 54 20 43 4C 
       00:0E8C: 4F 53 45 20 
       00:0E90: 46 49 4C 45 
       00:0E94: 20 2D 20 45 
       00:0E98: 52 52 4F 52 
       00:0E9C: 2B 2B 
   861 00:0E9E: 0D 0A 00             byte    cr,lf,0
   862 00:0EA1: 4C 31 10             jmp     erxit           ;error exit
   863 00:0EA4: 60           clo1    rts                     ;from closef
   864                        ;
   865                        ;---->  WRSEC: Write a sector
   866                        ;
   867                        ;Writes the sector into a buffer. When 16
   868                        ;have been written, writes the block to disk.
   869                        ;
   870                        ;entry point "WRBLOC" flushes the buffer at EOF.
   871                        ;
   872 00:0EA5: A9 28        WRSEC   lda     #<buffer        ;set up a & y
   873 00:0EA7: A0 01                ldy     #>buffer        ;for a move to
  Sun Sep  5 2021 20:58                                                                                                    Page 17


   874 00:0EA9: 85 3E                sta     from            ;track buffer
   875 00:0EAB: 84 3F                sty     from+1
   876 00:0EAD: AD 79 11             lda     secptr
   877 00:0EB0: AC 7A 11             ldy     secptr+1
   878 00:0EB3: 85 40                sta     to
   879 00:0EB5: 84 41                sty     to+1
   880 00:0EB7: 20 9D 11             jsr     mov128          ;move 128 bytes
   881 00:0EBA: 18                   clc                     ;bump the sector pointer
   882 00:0EBB: AD 79 11             lda     secptr          ;ahead 128 bytes
   883 00:0EBE: 69 80                adc     #128
   884 00:0EC0: 8D 79 11             sta     secptr          ;save it
   885 00:0EC3: 90 03                bcc     wrs1            ;branch if no carry
   886 00:0EC5: EE 7A 11             inc     secptr+1        ;bump the high byte
   887 00:0EC8: E6 35        WRS1    inc     secinb          ;bump the sector count moved
   888 00:0ECA: A5 35                lda     secinb          ;check for a full track yet
   889 00:0ECC: C9 10                cmp     #16             ;16 sectors = 1 track
   890 00:0ECE: F0 01                beq     wrbloc          ;yes, ->
   891 00:0ED0: 60                   rts                     ;from WRSEC
   892                        ;
   893                        ;---->  WRBLOC: Writes a block to disk
   894                        ;
   895 00:0ED1: A5 35        WRBLOC  lda     secinb          ;see if there is anything
   896 00:0ED3: F0 FB                beq     wrbloc-1        ;to write. no, ->
   897 00:0ED5: 85 43                sta     seccnt          ;save the sector count
   898 00:0ED7: A9 81                lda     #<dbuf          ;set the DMA address
   899 00:0ED9: A0 15                ldy     #>dbuf          ;to the track buffer
   900 00:0EDB: 85 40                sta     to              ;save address
   901 00:0EDD: 84 41                sty     to+1
   902 00:0EDF: A2 1A        DKWRLP  ldx     #stdma          ;set x = set DMA
   903 00:0EE1: 20 03 01             jsr     pem             ;set the buffer address
   904 00:0EE4: A9 07                lda     #<fcb           ;set up for a file write
   905 00:0EE6: A0 01                ldy     #>fcb
   906 00:0EE8: A2 15                ldx     #write          ;x = Write
   907 00:0EEA: 20 03 01             jsr     pem             ;write a sector
   908 00:0EED: D0 2A                bne     wrerr           ;error? ->
   909 00:0EEF: 18                   clc                     ;now point to next sector
   910 00:0EF0: A5 40                lda     to
   911 00:0EF2: 69 80                adc     #128
   912 00:0EF4: 85 40                sta     to
   913 00:0EF6: 90 02                bcc     wrs3
   914 00:0EF8: E6 41                inc     to+1
   915 00:0EFA: A5 40        WRS3    lda     to              ;get new DMA address
   916 00:0EFC: A4 41                ldy     to+1            ;into a & y
   917 00:0EFE: C6 43                dec     seccnt          ;drop the sector count
   918 00:0F00: D0 DD                bne     dkwrlp          ;more to write ->
   919 00:0F02: A9 00                lda     #0              ;put zero into sector count
   920 00:0F04: 85 35                sta     secinb
   921 00:0F06: A9 81                lda     #<dbuf          ;set pointers to the start
   922 00:0F08: A0 15                ldy     #>dbuf          ;of the track buffer
   923 00:0F0A: 8D 79 11             sta     secptr
   924 00:0F0D: 8C 7A 11             sty     secptr+1
   925 00:0F10: A9 28        RSDMA   lda     #<buffer        ;set DMA address to the
   926 00:0F12: A0 01                ldy     #>buffer        ;default buffer
   927 00:0F14: A2 1A                ldx     #stdma          ;x = set DMA
   928 00:0F16: 4C 03 01             jmp     pem             ;set default buffer address
   929                        ;error writing to file
   930 00:0F19: 20 10 0F     WRERR   jsr     rsdma           ;reset buffer address
   931 00:0F1C: 20 CF 10             jsr     ilprt           ;tell the bad news
   932 00:0F1F: 2B 2B 45 52          byte    "++ERROR WRITING FILE++",cr,lf,0
       00:0F23: 52 4F 52 20 
       00:0F27: 57 52 49 54 
       00:0F2B: 49 4E 47 20 
       00:0F2F: 46 49 4C 45 
  Sun Sep  5 2021 20:58                                                                                                    Page 18


       00:0F33: 2B 2B 0D 0A 
       00:0F37: 00 
   933 00:0F38: 4C DF 0F             jmp     abort           ;abort
   934                        ;Enter RECV and use one second
   935 00:0F3B: A9 01        ONESEC  lda     #1              ;set up for a one second
   936 00:0F3D: 85 3C                sta     seconds         ;wait on receive char
   937 00:0F3F: D0 00                bne     recv            ;always ->
   938                        ;
   939                        ;---->  RECV: Receive a character
   940                        ;
   941                        ;Time out time is in SECONDS, in seconds. Entry via
   942                        ;"RECVDG" deletes garbage characters on the
   943                        ;line. For example, having just sent a sector,
   944                        ;calling RECVDG will delete any line-noise-induced
   945                        ;characters long before the ACK/NAK would
   946                        ;be received.
   947                        ;The operations involved in the inner timing
   948                        ;loop with number of clock cycles required are:
   949                        ;       jsr     35
   950                        ;       beq     4
   951                        ;       jsr     7x12
   952                        ;       lda     3
   953                        ;       bne     4
   954                        ;       dec     5
   955                        ;       lda     3
   956                        ;       ora     3
   957                        ;       bne     4
   958                        ; TOTAL         145
   959                        ;With 8 MHz CPU clock this means inner loop can consume
   960                        ;up to 4640 usec in the inner loop. Adding the small
   961                        ;outer loop delays says 221 outer loop cycles
   962                        ;will yield e delay time of 1 second.
   963                        ;
   964                        recvdg
   965 00:0F41: A9 00        RECV    lda     #0              ;set up for a delay loop
   966 00:0F43: 85 3A                sta     inner           ;start inner at 256
   967 00:0F45: A9 DD                lda     #221            ;then outer at 227
   968 00:0F47: 85 3B                sta     outer
   969 00:0F49: 20 3A 08     mwti    jsr     chkc            ;test input status
   970 00:0F4C: F0 08                beq     nochar          ;not ready, ->
   971 00:0F4E: 20 41 08             jsr     getc            ;receive a char
   972 00:0F51: 20 92 0F             jsr     chksum          ;update the checksum count
   973 00:0F54: 18                   clc                     ;carry clear = got char
   974 00:0F55: 60                   rts                     ;from RECV
   975                        ;count down the timers
   976 00:0F56: 20 7E 0F     NOCHAR  jsr     rdelay          ;add 12 cycles of delay
   977 00:0F59: 20 7E 0F             jsr     rdelay          ;add 12 cycles of delay
   978 00:0F5C: 20 7E 0F             jsr     rdelay          ;add 12 cycles of delay
   979 00:0F5F: 20 7E 0F             jsr     rdelay          ;add 12 cycles of delay
   980 00:0F62: 20 7E 0F             jsr     rdelay          ;add 12 cycles of delay
   981 00:0F65: 20 7E 0F             jsr     rdelay          ;add 12 cycles of delay
   982 00:0F68: 20 7E 0F             jsr     rdelay          ;add 12 cycles of delay
   983 00:0F6B: A5 3A                lda     inner           ;see if inner 0
   984 00:0F6D: D0 02                bne     nochrz          ;skip if non zero
   985 00:0F6F: C6 3B                dec     outer           ;but drop outer if inner 0
   986 00:0F71: C6 3A        nochrz  dec     inner           ;always drop inner
   987 00:0F73: A5 3A                lda     inner           ;check for zero result
   988 00:0F75: 05 3B                ora     outer
   989 00:0F77: D0 D0                bne     mwti            ;loop if not zero
   990 00:0F79: C6 3C                dec     seconds         ;dec the seconds count
   991 00:0F7B: D0 C4                bne     recv            ;wait more? ->
   992 00:0F7D: 38                   sec                     ;carry set = time out
   993 00:0F7E: 60           rdelay  rts                     ;from RECV
  Sun Sep  5 2021 20:58                                                                                                    Page 19


   994                        ;
   995                        ;---->  SEND: Send a character to the modem
   996                        ;
   997                        ;       CTRL-C will abort the transfer and send a CAN
   998                        ;
   999 00:0F7F: 20 92 0F     SEND1   jsr     chksum          ;update the checksum
  1000 00:0F82: 20 37 08             jsr     putc            ;send the char
  1001 00:0F85: 20 D4 0F             jsr     polkey          ;poll for a key pressed
  1002 00:0F88: C9 03                cmp     #ctrlc          ;control-c ?
  1003 00:0F8A: D0 05                bne     nostop          ;no ->
  1004 00:0F8C: 68                   pla                     ;yes, pop return address
  1005 00:0F8D: 68                   pla                     ;to here
  1006 00:0F8E: 4C DF 0F             jmp     abort           ;exit
  1007 00:0F91: 60           NOSTOP  rts                     ;from SEND1
  1008                        ;calculate checksum using byte in a while saving A
  1009 00:0F92: 08           chksum  php                     ;save status
  1010 00:0F93: 48                   pha                     ;then byte
  1011 00:0F94: 18                   clc                     ;set up for an add
  1012 00:0F95: 65 38                adc     csum            ;add it to checksum
  1013 00:0F97: 85 38                sta     csum            ;save it
  1014 00:0F99: 68                   pla                     ;get byte
  1015 00:0F9A: 28                   plp                     ;then status
  1016 00:0F9B: 60                   rts                     ;from CHKSUM
  1017                        ;
  1018                        ;---->  SHOW: Shows chars sent/received
  1019                        ;
  1020                        ;CR, LF, and TAB are shown. All other
  1021                        ;non-printable characters are shown in
  1022                        ;hex as (XX)
  1023                        ;
  1024 00:0F9C: C9 0A        SHOW    cmp     #lf             ;is it a linefeed?
  1025 00:0F9E: F0 1C                beq     ctype           ;yes, ->
  1026 00:0FA0: C9 0D                cmp     #cr             ;is it a cr
  1027 00:0FA2: F0 18                beq     ctype           ;yes, ->
  1028 00:0FA4: C9 09                cmp     #tab            ;Tab?
  1029 00:0FA6: F0 14                beq     ctype           ;yes, ->
  1030 00:0FA8: C9 20                cmp     #space          ;control char?
  1031 00:0FAA: 90 04                bcc     showhe          ;yes, ->
  1032 00:0FAC: C9 7F                cmp     #$7f            ;ascii?
  1033 00:0FAE: 90 0C                bcc     ctype           ;yes, ->
  1034 00:0FB0: 48           SHOWHE  pha                     ;save char
  1035 00:0FB1: A9 28                lda     #'('            ;put it in ()
  1036 00:0FB3: 20 F4 09             jsr     conout          ;type
  1037 00:0FB6: 68                   pla                     ;get back char
  1038 00:0FB7: 20 C0 0F             jsr     hexo            ;print hex char
  1039 00:0FBA: A9 29                lda     #')'            ;closing ")"
  1040 00:0FBC: 20 F4 09     CTYPE   jsr     conout          ;print char in a
  1041 00:0FBF: 60                   rts                     ;from SHOW
  1042                        ;
  1043                        ;---->  HEXO:  output byte in a as two hex chars to  console
  1044                        ;
  1045 00:0FC0: 48           HEXO    pha                     ;hold char
  1046 00:0FC1: 4A                   lsr     a               ;get high byte
  1047 00:0FC2: 4A                   lsr     a
  1048 00:0FC3: 4A                   lsr     a
  1049 00:0FC4: 4A                   lsr     a
  1050 00:0FC5: 20 C9 0F             jsr     nibbl           ;print high nibble
  1051 00:0FC8: 68                   pla                     ;get char again
  1052 00:0FC9: 29 0F        NIBBL   and     #$0f            ;mask off high nibble
  1053 00:0FCB: C9 0A                cmp     #$0A            ;set or clear carry
  1054 00:0FCD: F8                   sed                     ;sed for decimal add
  1055 00:0FCE: 69 30                adc     #$30            ;make it ascii
  1056 00:0FD0: D8                   cld                     ;back to binary add
  Sun Sep  5 2021 20:58                                                                                                    Page 20


  1057 00:0FD1: 4C F4 09             jmp     conout          ;print it
  1058                        ;
  1059                        ;---->  POLKEY: Scan the keyboard for keys pressed
  1060                        ;
  1061                        ;
  1062                        ;Returns with ZERO if no input.
  1063                        ;
  1064 00:0FD4: 20 03 08     POLKEY  jsr     const           ;check console for input
  1065 00:0FD7: 29 FF                and     #$ff            ;test result
  1066 00:0FD9: F0 03                beq     pol1            ;no, ->
  1067 00:0FDB: 20 EE 09             jsr     coninp          ;yes, read console
  1068 00:0FDE: 60           POL1    rts                     ;from POLKEY
  1069                        ;
  1070                        ;---->  ABORT: Abort the file transfer
  1071                        ;
  1072 00:0FDF: 20 3B 0F     ABORT   jsr     onesec          ;wait 1 sec without chars
  1073 00:0FE2: 90 FB                bcc     abort           ;loop until sender done
  1074 00:0FE4: A9 18                lda     #can            ;send a cancel
  1075 00:0FE6: 20 7F 0F             jsr     send1
  1076 00:0FE9: 20 CF 10             jsr     ilprt           ;exit with abort message
  1077 00:0FEC: 58 4D 4F 44          byte    "XMODEM PROGRAM CANCELLED",cr,lf,0
       00:0FF0: 45 4D 20 50 
       00:0FF4: 52 4F 47 52 
       00:0FF8: 41 4D 20 43 
       00:0FFC: 41 4E 43 45 
       00:1000: 4C 4C 45 44 
       00:1004: 0D 0A 00 
  1078 00:1007: 4C 31 10             jmp     ckdis           ;go to exit
  1079                        ;
  1080                        ;---->  DONE: Normal exit
  1081                        ;
  1082                        DONE
  1083 00:100A: 20 CF 10     DONETC  jsr     ilprt           ;print message
  1084 00:100D: 54 52 41 4E          byte    "TRANSFER COMPLETE",cr,lf,0
       00:1011: 53 46 45 52 
       00:1015: 20 43 4F 4D 
       00:1019: 50 4C 45 54 
       00:101D: 45 0D 0A 00 
  1085 00:1021: AD 78 11     DONE1   lda     termfl          ;check terminal flag
  1086 00:1024: D0 03                bne     done2           ;no ->
  1087 00:1026: 4C FE 08             jmp     term
  1088 00:1029: AD 75 11     DONE2   lda     echofl          ;check echo flag
  1089 00:102C: D0 03                bne     ckdis           ;no, ->
  1090 00:102E: 4C 3B 09             jmp     trmech          ;go to terminal echo
  1091                        ;
  1092                        ;---->  CKDIS: Check for disconnect
  1093                        ;
  1094                        ERXIT
  1095 00:1031: AD 74 11     CKDIS   lda     discfl          ;check disconnect flag
  1096 00:1034: D0 2B                bne     discon          ;no, ->
  1097 00:1036: 20 CF 10             jsr     ilprt           ;print message
  1098 00:1039: 0D 0A 50 52          byte    cr,lf,"PRESS RETURN TO DISCONNECT:",0
       00:103D: 45 53 53 20 
       00:1041: 52 45 54 55 
       00:1045: 52 4E 20 54 
       00:1049: 4F 20 44 49 
       00:104D: 53 43 4F 4E 
       00:1051: 4E 45 43 54 
       00:1055: 3A 00 
  1099 00:1057: 20 EE 09             jsr     coninp          ;get a key
  1100 00:105A: 20 64 10             jsr     crlf            ;print cr,lf
  1101 00:105D: C9 0D                cmp     #cr             ;cr?
  1102 00:105F: D0 D0                bne     ckdis           ;no, ->
  Sun Sep  5 2021 20:58                                                                                                    Page 21


  1103                        ;disconnect - this version does nothing
  1104 00:1061: 4C 00 01     DISCON  jmp     boot            ;exit
  1105                        ;
  1106                        ;---->  CRLF:  send cr and lf to console
  1107                        ;
  1108                        ;preserves whatever was in a at entry
  1109 00:1064: 48           CRLF    pha                     ;save a
  1110 00:1065: A9 0D                lda     #cr
  1111 00:1067: 20 F4 09             jsr     conout
  1112 00:106A: A9 0A                lda     #lf
  1113 00:106C: 20 F4 09             jsr     conout
  1114 00:106F: 68                   pla                     ;restore a
  1115 00:1070: 60                   rts
  1116                        ;
  1117                        ;---->  CKQUIT: Quit/Retry after multiple errors
  1118                        ;
  1119                        ;Returns w/zero set if retry asked for
  1120                        ;
  1121 00:1071: A9 00        CKQUIT  lda     #0              ;zero out error count
  1122 00:1073: 85 34                sta     errcnt
  1123 00:1075: 20 CF 10     CKQLP   jsr     ilprt           ;print:
  1124 00:1078: 4D 55 4C 54          byte    "MULTIPLE ERRORS ENCOUNTERED",CR,LF
       00:107C: 49 50 4C 45 
       00:1080: 20 45 52 52 
       00:1084: 4F 52 53 20 
       00:1088: 45 4E 43 4F 
       00:108C: 55 4E 54 45 
       00:1090: 52 45 44 0D 
       00:1094: 0A 
  1125 00:1095: 54 59 50 45          byte    "TYPE CTRL-E TO QUIT, R TO RETRY:",0
       00:1099: 20 43 54 52 
       00:109D: 4C 2D 45 20 
       00:10A1: 54 4F 20 51 
       00:10A5: 55 49 54 2C 
       00:10A9: 20 52 20 54 
       00:10AD: 4F 20 52 45 
       00:10B1: 54 52 59 3A 
       00:10B5: 00 
  1126 00:10B6: 20 EE 09             jsr     coninp          ;get response
  1127 00:10B9: 48                   pha                     ;save it
  1128 00:10BA: 20 F4 09             jsr     conout          ;print it
  1129 00:10BD: 20 64 10             jsr     crlf            ;clean up line
  1130 00:10C0: 68                   pla                     ;retrieve response
  1131 00:10C1: 20 E3 09             jsr     lwrupr          ;convert to upper case
  1132 00:10C4: C9 52                cmp     #'R'            ;retry?
  1133 00:10C6: F0 06                beq     ckq1            ;yes, go on
  1134 00:10C8: C9 05                cmp     #CTRLE          ;see if quit
  1135 00:10CA: D0 A9                bne     CKQLP           ;loop if not
  1136 00:10CC: A9 FF                lda     #$FF            ;set to non-zero
  1137 00:10CE: 60           CKQ1    rts                     ;from CKQUIT
  1138                        ;
  1139                        ;---->  ILPRT: In line print of message
  1140                        ;
  1141                        ;The call to ILPRT is followed by a message,
  1142                        ;binary zero as the end. Binary one may be
  1143                        ;used to pause with message 'PRESS RETURN TO CONTINUE'
  1144                        ;
  1145 00:10CF: 68           ILPRT   pla                     ;move the return
  1146 00:10D0: 85 30                sta     stroad          ;address into
  1147 00:10D2: 68                   pla                     ;zero page
  1148 00:10D3: 85 31                sta     stroad+1
  1149 00:10D5: A0 01        n6      ldy     #1              ;set y for addr+1
  1150 00:10D7: B1 30                lda     (stroad),y      ;get the char
  Sun Sep  5 2021 20:58                                                                                                    Page 22


  1151 00:10D9: F0 13                beq     n3              ;branch if done
  1152 00:10DB: C9 01                cmp     #1              ;pause if #1
  1153 00:10DD: D0 03                bne     n5
  1154 00:10DF: 4C FB 10             jmp     lpause          ;pause
  1155 00:10E2: 20 F4 09     n5      jsr     conout          ;print char
  1156 00:10E5: E6 30        lpnext  inc     stroad          ;bump the pointer
  1157 00:10E7: D0 02                bne     n4              ;no carry >
  1158 00:10E9: E6 31                inc     stroad+1        ;bump high byte
  1159 00:10EB: 4C D5 10     n4      jmp     n6              ;go back for more
  1160 00:10EE: E6 30        n3      inc     stroad          ;set return address
  1161 00:10F0: D0 02                bne     n7
  1162 00:10F2: E6 31                inc     stroad+1
  1163 00:10F4: A5 31        n7      lda     stroad+1        ;put addr back
  1164 00:10F6: 48                   pha                     ;onto stack
  1165 00:10F7: A5 30                lda     stroad
  1166 00:10F9: 48                   pha
  1167 00:10FA: 60                   rts                     ;return past mess.
  1168                        ;pause until return pressed
  1169 00:10FB: A9 15        LPAUSE  lda     #<paumes        ;set pointers
  1170 00:10FD: A0 11                ldy     #>paumes        ;for pause message
  1171 00:10FF: A2 09                ldx     #print          ;set pem command
  1172 00:1101: 20 03 01             jsr     pem             ;print it
  1173 00:1104: 20 EE 09             jsr     coninp          ;wait for a key
  1174 00:1107: C9 05                cmp     #ctrle          ;see if quit
  1175 00:1109: F0 07                beq     n8              ;is so quit
  1176 00:110B: C9 0D                cmp     #cr             ;continue code?
  1177 00:110D: D0 EC                bne     lpause          ;no ->
  1178 00:110F: 4C E5 10             jmp     lpnext          ;is so print more
  1179 00:1112: 4C 00 01     n8      jmp     boot            ;EXIT
  1180 00:1115: 0D 0A        PAUMES  byte    cr,lf
  1181 00:1117: 50 52 45 53          byte    "PRESS RETURN TO CONTINUE OR CTRL-E TO EXIT"
       00:111B: 53 20 52 45 
       00:111F: 54 55 52 4E 
       00:1123: 20 54 4F 20 
       00:1127: 43 4F 4E 54 
       00:112B: 49 4E 55 45 
       00:112F: 20 4F 52 20 
       00:1133: 43 54 52 4C 
       00:1137: 2D 45 20 54 
       00:113B: 4F 20 45 58 
       00:113F: 49 54 
  1182 00:1141: 0D 0A 24             byte    cr,lf,"$"
  1183                        ;
  1184                        ;---->  PROCOP: Process command options
  1185                        ;
  1186                        ;1) Save the primary option in 'OPTION';
  1187                        ;2) Scans the sub-option characters, and for
  1188                        ;each found, zeros the appropriate entry in
  1189                        ;the option table. For example if 'D' is
  1190                        ;coded (DISCONNECT) then the 'D' stored at
  1191                        ;'DISCFL' is set to 0 so it can be tested
  1192                        ;later.
  1193                        ;
  1194 00:1144: A2 00        PROCOP  ldx     #0              ;save the primary
  1195 00:1146: BD 08 01             lda     fcb+1,x         ;option
  1196 00:1149: 8D 71 11             sta     option
  1197 00:114C: E8           N10     inx                     ;point to the sec option
  1198 00:114D: BD 08 01             lda     fcb+1,x         ;get it
  1199 00:1150: C9 20                cmp     #space          ;if blank-> end of opts
  1200 00:1152: F0 1C                beq     endopt
  1201 00:1154: 8E 72 11             stx     optbl           ;save sec option pointer
  1202 00:1157: A2 01                ldx     #1              ;point to start op opts table
  1203 00:1159: DD 72 11     N11     cmp     optbl,x         ;look for a match
  Sun Sep  5 2021 20:58                                                                                                    Page 23


  1204 00:115C: D0 0A                bne     n9              ;not this one ->
  1205 00:115E: A9 00                lda     #0              ;found option
  1206 00:1160: 9D 72 11             sta     optbl,x         ;put a zero in it
  1207 00:1163: AE 72 11             ldx     optbl           ;recover fcb pointer
  1208 00:1166: D0 E4                bne     n10             ;always branch
  1209 00:1168: E8           N9      inx                     ;bump opt tbl pointer
  1210 00:1169: E0 07                cpx     #optbe-optbl    ;option table length
  1211 00:116B: D0 EC                bne     n11             ;if more ->
  1212 00:116D: 4C AA 11             jmp     badopt          ;bad option -> error mess
  1213 00:1170: 60           ENDOPT  rts                     ;from procop
  1214                        ;
  1215                        ;Sub-option table. If an option is in effect,
  1216                        ;the character is set to binary 0
  1217                        ;
  1218 00:1171: 00           OPTION  byte    0               ;pri option saved here
  1219 00:1172: 00           OPTBL   byte    0               ;secondary option table
  1220 00:1173: 41           ANSWFL  byte    "A"             ;answer mode
  1221 00:1174: 44           DISCFL  byte    "D"             ;disconnect when done
  1222 00:1175: 45           ECHOFL  byte    "E"             ;to echo after xfer
  1223 00:1176: 4F           ORIGFL  byte    "O"             ;originate mode
  1224 00:1177: 51           QFLG    byte    "Q"             ;quiet transfer (no msgs)
  1225 00:1178: 54           TERMFL  byte    "T"             ;to term after xfer
  1226                        OPTBE
  1227 00:1179: 81 15        SECPTR  word    Dbuf            ;Start of the block buffer
  1228 00:117B: 00           SECNUM  byte    0               ;sector number storage
  1229                        ;move FCB
  1230 00:117C: A9 17        MOVfcb  lda     #<fcb2          ;set up 'from'
  1231 00:117E: A0 01                ldy     #>fcb2          ;address
  1232 00:1180: 85 3E                sta     from
  1233 00:1182: 84 3F                sty     from+1
  1234 00:1184: A9 07                lda     #<fcb           ;set up 'to'
  1235 00:1186: A0 01                ldy     #>fcb           ;address
  1236 00:1188: 85 40                sta     to
  1237 00:118A: 84 41                sty     to+1
  1238 00:118C: A2 10                ldx     #16             ;length to move
  1239 00:118E: 20 9F 11             jsr     move            ;do the move
  1240 00:1191: A9 00                lda     #0              ;get a zero
  1241 00:1193: 8D 27 01             sta     fcbsno          ;set sector #
  1242 00:1196: 8D 13 01             sta     fcbext          ;and the extent
  1243 00:1199: 8D 14 01             sta     fcbext+1
  1244 00:119C: 60                   rts
  1245                        ;move 128 bytes from (from) to (to) using x as counter
  1246 00:119D: A2 80        MOV128  ldx     #128            ;set up to move 128
  1247                        ;move x bytes from (from) to (to)
  1248 00:119F: A0 00        MOVE    ldy     #0              ;set index to zero
  1249 00:11A1: B1 3E        movelp  lda     (from),y        ;get byte
  1250 00:11A3: 91 40                sta     (to),y          ;put byte
  1251 00:11A5: C8                   iny                     ;bump index
  1252 00:11A6: CA                   dex                     ;decrement the length
  1253 00:11A7: D0 F8                bne     movelp          ;go back for more
  1254 00:11A9: 60                   rts                     ;from move
  1255                        ;
  1256                        ;Invalid command
  1257                        ;
  1258 00:11AA: 20 CF 10     BADOPT  jsr     ilprt           ;exit w/error
  1259 00:11AD: 3A 49 4E 56          byte    ":INVALID OPTION ON XMODEM "
       00:11B1: 41 4C 49 44 
       00:11B5: 20 4F 50 54 
       00:11B9: 49 4F 4E 20 
       00:11BD: 4F 4E 20 58 
       00:11C1: 4D 4F 44 45 
       00:11C5: 4D 20 
  1260 00:11C7: 43 4F 4D 4D          byte    "COMMAND -",cr,lf
  Sun Sep  5 2021 20:58                                                                                                    Page 24


       00:11CB: 41 4E 44 20 
       00:11CF: 2D 0D 0A 
  1261 00:11D2: 50 52 45 53          byte    "PRESS RETURN FOR HELP, OR "
       00:11D6: 53 20 52 45 
       00:11DA: 54 55 52 4E 
       00:11DE: 20 46 4F 52 
       00:11E2: 20 48 45 4C 
       00:11E6: 50 2C 20 4F 
       00:11EA: 52 20 
  1262 00:11EC: 43 54 52 4C          byte    "CTRL-E TO EXIT",cr,lf,0
       00:11F0: 2D 45 20 54 
       00:11F4: 4F 20 45 58 
       00:11F8: 49 54 0D 0A 
       00:11FC: 00 
  1263 00:11FD: 20 EE 09             jsr     coninp          ;get key
  1264 00:1200: C9 0D                cmp     #cr             ;see if RETURN
  1265 00:1202: F0 07                beq     HELP            ;if so do HELP
  1266 00:1204: C9 05                cmp     #CTRLE          ;see if ctrl-e
  1267 00:1206: D0 A2                bne     badopt          ;loop if not
  1268 00:1208: 4C 00 01             jmp     boot            ;but boot if is
  1269                        ;e5xecute HELP option
  1270 00:120B: 20 CF 10     HELP    jsr     ilprt
  1271 00:120E: 0D 0A                byte    cr,lf
  1272 00:1210: 46 6F 72 6D          byte    "Format for command is:",cr,lf
       00:1214: 61 74 20 66 
       00:1218: 6F 72 20 63 
       00:121C: 6F 6D 6D 61 
       00:1220: 6E 64 20 69 
       00:1224: 73 3A 0D 0A 
  1273 00:1228: 58 4D 4F 44          byte    "XMODEM # FILENAME",cr,lf,cr,lf
       00:122C: 45 4D 20 23 
       00:1230: 20 46 49 4C 
       00:1234: 45 4E 41 4D 
       00:1238: 45 0D 0A 0D 
       00:123C: 0A 
  1274 00:123D: 57 68 65 72          byte    "Where # is a 1 character "
       00:1241: 65 20 23 20 
       00:1245: 69 73 20 61 
       00:1249: 20 31 20 63 
       00:124D: 68 61 72 61 
       00:1251: 63 74 65 72 
       00:1255: 20 
  1275 00:1256: 70 72 69 6D          byte    "primary option,",cr,lf
       00:125A: 61 72 79 20 
       00:125E: 6F 70 74 69 
       00:1262: 6F 6E 2C 0D 
       00:1266: 0A 
  1276 00:1267: 20 77 68 69          byte    " which may be followed by "
       00:126B: 63 68 20 6D 
       00:126F: 61 79 20 62 
       00:1273: 65 20 66 6F 
       00:1277: 6C 6C 6F 77 
       00:127B: 65 64 20 62 
       00:127F: 79 20 
  1277 00:1281: 73 75 62 2D          byte    "sub-options"
       00:1285: 6F 70 74 69 
       00:1289: 6F 6E 73 
  1278 00:128C: 0D 0A 01             byte    cr,lf,1
  1279 00:128F: 50 72 69 6D          byte    "Primary options",cr,lf
       00:1293: 61 72 79 20 
       00:1297: 6F 70 74 69 
       00:129B: 6F 6E 73 0D 
       00:129F: 0A 
  Sun Sep  5 2021 20:58                                                                                                    Page 25


  1280 00:12A0: 20 20 20 53          byte    "   S to send a file",cr,lf
       00:12A4: 20 74 6F 20 
       00:12A8: 73 65 6E 64 
       00:12AC: 20 61 20 66 
       00:12B0: 69 6C 65 0D 
       00:12B4: 0A 
  1281 00:12B5: 20 20 20 52          byte    "   R to receive a file",cr,lf
       00:12B9: 20 74 6F 20 
       00:12BD: 72 65 63 65 
       00:12C1: 69 76 65 20 
       00:12C5: 61 20 66 69 
       00:12C9: 6C 65 0D 0A 
  1282 00:12CD: 20 20 20 54          byte    "   T to act as a terminal",cr,lf
       00:12D1: 20 74 6F 20 
       00:12D5: 61 63 74 20 
       00:12D9: 61 73 20 61 
       00:12DD: 20 74 65 72 
       00:12E1: 6D 69 6E 61 
       00:12E5: 6C 0D 0A 
  1283 00:12E8: 20 20 20 45          byte    "   E to act as a computer "
       00:12EC: 20 74 6F 20 
       00:12F0: 61 63 74 20 
       00:12F4: 61 73 20 61 
       00:12F8: 20 63 6F 6D 
       00:12FC: 70 75 74 65 
       00:1300: 72 20 
  1284 00:1302: 28 65 63 68          byte    "(echo data)",cr,lf
       00:1306: 6F 20 64 61 
       00:130A: 74 61 29 0D 
       00:130E: 0A 
  1285 00:130F: 20 20 20 50          byte    "   P to send input to printer",cr,lf
       00:1313: 20 74 6F 20 
       00:1317: 73 65 6E 64 
       00:131B: 20 69 6E 70 
       00:131F: 75 74 20 74 
       00:1323: 6F 20 70 72 
       00:1327: 69 6E 74 65 
       00:132B: 72 0D 0A 
  1286 00:132E: 20 20 20 44          byte    "   D to disconnect the line",cr,lf
       00:1332: 20 74 6F 20 
       00:1336: 64 69 73 63 
       00:133A: 6F 6E 6E 65 
       00:133E: 63 74 20 74 
       00:1342: 68 65 20 6C 
       00:1346: 69 6E 65 0D 
       00:134A: 0A 
  1287 00:134B: 20 20 20 48          byte    "   H to print this help file"
       00:134F: 20 74 6F 20 
       00:1353: 70 72 69 6E 
       00:1357: 74 20 74 68 
       00:135B: 69 73 20 68 
       00:135F: 65 6C 70 20 
       00:1363: 66 69 6C 65 
  1288 00:1367: 0D 0A 01             byte    cr,lf,1
  1289 00:136A: 53 65 63 6F          byte    "Secondary options:",cr,lf
       00:136E: 6E 64 61 72 
       00:1372: 79 20 6F 70 
       00:1376: 74 69 6F 6E 
       00:137A: 73 3A 0D 0A 
  1290 00:137E: 20 20 20 41          byte    "   A answer mode",cr,lf
       00:1382: 20 61 6E 73 
       00:1386: 77 65 72 20 
       00:138A: 6D 6F 64 65 
  Sun Sep  5 2021 20:58                                                                                                    Page 26


       00:138E: 0D 0A 
  1291 00:1390: 20 20 20 4F          byte    "   O originate mode",cr,lf
       00:1394: 20 6F 72 69 
       00:1398: 67 69 6E 61 
       00:139C: 74 65 20 6D 
       00:13A0: 6F 64 65 0D 
       00:13A4: 0A 
  1292 00:13A5: 20 20 20 44          byte    "   D disconnect after "
       00:13A9: 20 64 69 73 
       00:13AD: 63 6F 6E 6E 
       00:13B1: 65 63 74 20 
       00:13B5: 61 66 74 65 
       00:13B9: 72 20 
  1293 00:13BB: 65 78 65 63          byte    "execution",cr,lf
       00:13BF: 75 74 69 6F 
       00:13C3: 6E 0D 0A 
  1294 00:13C6: 20 20 20 54          byte    "   T to go to terminal mode "
       00:13CA: 20 74 6F 20 
       00:13CE: 67 6F 20 74 
       00:13D2: 6F 20 74 65 
       00:13D6: 72 6D 69 6E 
       00:13DA: 61 6C 20 6D 
       00:13DE: 6F 64 65 20 
  1295 00:13E2: 61 66 74 65          byte    "after xfer",cr,lf
       00:13E6: 72 20 78 66 
       00:13EA: 65 72 0D 0A 
  1296 00:13EE: 20 20 20 45          byte    "   E to go to echo mode "
       00:13F2: 20 74 6F 20 
       00:13F6: 67 6F 20 74 
       00:13FA: 6F 20 65 63 
       00:13FE: 68 6F 20 6D 
       00:1402: 6F 64 65 20 
  1297 00:1406: 61 66 74 65          byte    "after file xfer",cr,lf
       00:140A: 72 20 66 69 
       00:140E: 6C 65 20 78 
       00:1412: 66 65 72 0D 
       00:1416: 0A 
  1298 00:1417: 20 20 20 51          byte    "   Q quiet mode - no status "
       00:141B: 20 71 75 69 
       00:141F: 65 74 20 6D 
       00:1423: 6F 64 65 20 
       00:1427: 2D 20 6E 6F 
       00:142B: 20 73 74 61 
       00:142F: 74 75 73 20 
  1299 00:1433: 6D 73 67 73          byte    "msgs",cr,lf
       00:1437: 0D 0A 
  1300 00:1439: 0D 0A 46 4F          byte    cr,lf,"FOR EXAMPLES, TYPE: XMODEM X"
       00:143D: 52 20 45 58 
       00:1441: 41 4D 50 4C 
       00:1445: 45 53 2C 20 
       00:1449: 54 59 50 45 
       00:144D: 3A 20 58 4D 
       00:1451: 4F 44 45 4D 
       00:1455: 20 58 
  1301 00:1457: 0D 0A 00             byte    cr,lf,0
  1302 00:145A: 4C 5D 14             jmp     exit
  1303 00:145D: 4C 00 01     EXIT    jmp     boot
  1304 00:1460: 20 CF 10     EXAM    jsr     ilprt
  1305 00:1463: 53 65 6E 64          byte    "Send a file, originate mode",cr,lf
       00:1467: 20 61 20 66 
       00:146B: 69 6C 65 2C 
       00:146F: 20 6F 72 69 
       00:1473: 67 69 6E 61 
  Sun Sep  5 2021 20:58                                                                                                    Page 27


       00:1477: 74 65 20 6D 
       00:147B: 6F 64 65 0D 
       00:147F: 0A 
  1306 00:1480: 20 20 20 58          byte    "   XMODEM SO fn.ft",cr,lf
       00:1484: 4D 4F 44 45 
       00:1488: 4D 20 53 4F 
       00:148C: 20 66 6E 2E 
       00:1490: 66 74 0D 0A 
  1307 00:1494: 53 65 6E 64          byte    "Send another file:",cr,lf
       00:1498: 20 61 6E 6F 
       00:149C: 74 68 65 72 
       00:14A0: 20 66 69 6C 
       00:14A4: 65 3A 0D 0A 
  1308 00:14A8: 20 20 20 58          byte    "   XMODEM S fn.ft",cr,lf
       00:14AC: 4D 4F 44 45 
       00:14B0: 4D 20 53 20 
       00:14B4: 66 6E 2E 66 
       00:14B8: 74 0D 0A 
  1309 00:14BB: 53 65 6E 64          byte    "Send a third file and "
       00:14BF: 20 61 20 74 
       00:14C3: 68 69 72 64 
       00:14C7: 20 66 69 6C 
       00:14CB: 65 20 61 6E 
       00:14CF: 64 20 
  1310 00:14D1: 64 69 73 63          byte    "disconnect:",cr,lf
       00:14D5: 6F 6E 6E 65 
       00:14D9: 63 74 3A 0D 
       00:14DD: 0A 
  1311 00:14DE: 20 20 20 58          byte    "   XMODEM SD fn.ft",cr,lf
       00:14E2: 4D 4F 44 45 
       00:14E6: 4D 20 53 44 
       00:14EA: 20 66 6E 2E 
       00:14EE: 66 74 0D 0A 
  1312 00:14F2: 41 63 74 20          byte    "Act as a terminal, originate"
       00:14F6: 61 73 20 61 
       00:14FA: 20 74 65 72 
       00:14FE: 6D 69 6E 61 
       00:1502: 6C 2C 20 6F 
       00:1506: 72 69 67 69 
       00:150A: 6E 61 74 65 
  1313 00:150E: 6D 6F 64 65          byte    "mode:",cr,lf
       00:1512: 3A 0D 0A 
  1314 00:1515: 20 20 20 58          byte    "   XMODEM TO",cr,lf
       00:1519: 4D 4F 44 45 
       00:151D: 4D 20 54 4F 
       00:1521: 0D 0A 
  1315 00:1523: 20 20 20 28          byte    "   (Use ctrl-E to disconnect)",cr,lf
       00:1527: 55 73 65 20 
       00:152B: 63 74 72 6C 
       00:152F: 2D 45 20 74 
       00:1533: 6F 20 64 69 
       00:1537: 73 63 6F 6E 
       00:153B: 6E 65 63 74 
       00:153F: 29 0D 0A 
  1316 00:1542: 52 65 63 65          byte    "Receive a file, answer mode"
       00:1546: 69 76 65 20 
       00:154A: 61 20 66 69 
       00:154E: 6C 65 2C 20 
       00:1552: 61 6E 73 77 
       00:1556: 65 72 20 6D 
       00:155A: 6F 64 65 
  1317 00:155D: 2C 20 76 69          byte    ", view it:",cr,lf
       00:1561: 65 77 20 69 
  Sun Sep  5 2021 20:58                                                                                                    Page 28


       00:1565: 74 3A 0D 0A 
  1318 00:1569: 20 20 20 58          byte    "   XMODEM RA fn.ft",cr,lf,0
       00:156D: 4D 4F 44 45 
       00:1571: 4D 20 52 41 
       00:1575: 20 66 6E 2E 
       00:1579: 66 74 0D 0A 
       00:157D: 00 
  1319 00:157E: 4C 5D 14             jmp     exit
  1320                        ;block storage buffer
  1321 00:1581:              dbuf    ds      16*128          ;16 records
  1322                                ends
  1323                                end


      Lines assembled: 1323
      Errors: 0
