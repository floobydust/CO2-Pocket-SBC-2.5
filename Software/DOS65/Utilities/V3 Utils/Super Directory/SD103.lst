  Sat Feb 18 2023 11:03                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C02 Macro Assembler    **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;*************************************************************************************************
     2                                GLOBALS ON
     3                                CASE    OFF
     4                                CHIP    W65C02S
     5                                PW      132
     6                                PL      66
     7                        ;*************************************************************************************************
     8                        ;SD.ASM VER 1.04 (WDC Assembler Format)
     9                        ;DOS/65Super Directory based on CP/M Super Directory by Bruce R. Ratoff
    10                        ;that was based on DIRS by Keith Petersen, W8SDZ
    11                        ;
    12                        ;Displays the directory of a DOS/65 drive, sorted alphabetically,
    13                        ;with the file size in K, rounded to the nearest DOS/65 block size.
    14                        ;
    15                        ;THIS LATEST VARIATION ON A COMMON THEME WILL AUTOMATICALLY ADJUST
    16                        ;ITSELF FOR ANY BLOCK SIZE AND DIRECTORY LENGTH UNDER DOS/65 2.1X or 3.x.
    17                        ;PROVISIONS ARE MADE FOR (1) AUTOMATIC PAUSES
    18                        ;WHEN THE SCREEN FILLS UP; (2) searching individual or multiple
    19                        ;USER AREAS; (3) summary line output giving
    20                        ;DRIVE AND USER INFORMATION, # OF FILES MATCHED AND HOW MUCH SPACE THEY
    21                        ;CONSUME, AND THE AMOUNT OF FREE SPACE REMAINING ON THE DISK; (4) accepting
    22                        ;ambiguous file names WITH OR WITHOUT A DRIVE NAME.
    23                        ;
    24                        ;Released:              27 March 2015 (V1.00) - Rich Leary
    25                        ;Last Revision:         29 March 2015 (V1.01) - Rich Leary
    26                        ;                               corrected error with $'s in file name
    27                        ;                       30 March 2015 (V1.02) - Rich Leary
    28                        ;                               eliminated duplicate searches
    29                        ;                       4 August 2017 (V1.03) - Rich Leary
    30                        ;                               changed option char to =
    31                        ;
    32                        ;NOTE: Simple labels are used when doing some of the various
    33                        ;6502/65C02 branch instructions. For example note that in
    34                        ;the following code fragment the label NZ001 is a simple label that
    35                        ;usually is only referenced within a very small address span.
    36                        ;               inc     hl
    37                        ;               bne     nz001
    38                        ;               inc     hl+1
    39                        ;       nz001
    40                        ;In this case the label designates code flow as a result of a simple
    41                        ;arithmetic operation.
    42                        ;Several generic versions of such labels are used in this program and
    43                        ;the follow the general pattern of
    44                        ;               ccnnn
    45                        ;where cc denotes a flag condition and nnn is a sequential numerical
    46                        ;designator. cc's used include:
    47                        ;       nz      not zero
    48                        ;       eq      zero
    49                        ;       cc      carry clear or borrow set
    50                        ;       cs      carry set or borrow clear
    51                        ;       pl      plus
    52                        ;       mi      minus
    53                        ;Labels used are as follows:
    54                        ;       nz      nz001,nz004,nz005,nz020,nz021,nz010,nz011,nz013,
    55                        ;               nz009,nz020
    56                        ;       eq      eq030
    57                        ;       cc      cc002,cc004,cc005,cc006,cc050,cc003
  Sat Feb 18 2023 11:03                                                                                                    Page 2


    58                        ;       cs      cs002
    59                        ;       pl      pl001
    60                        ;       mi
    61                        ;
    62                        ;*************************************************************************************************
    63                        ;
    64                        ;fixed values
    65             00000000   FALSE   EQU     0
    66             00000001   TRUE    EQU     1
    67                        ;ASCII characters
    68             0000000A   LF      EQU     10                      ;line feed
    69             0000000D   CR      EQU     13                      ;carriage return
    70             0000007C   DELIM   EQU     $7C                     ;delimiter - vertical bar
    71                        ;
    72                        ;*****************************
    73                        ;                            *
    74                        ; USER OPTION SPECIFICATIONS *
    75                        ;                            *
    76                        ;*****************************
    77                        ;
    78             00000001   V3      EQU     TRUE                    ;True if DOS/65 V3.x vs V2.1
    79             00000001   AOPT    EQU     TRUE                    ;True to allow searching all user areas
    80             00000001   NOPT    EQU     TRUE                    ;True to allow disabling page pause option
    81             00000001   OPTION  EQU     TRUE                    ;True if allowing ANY command line options
    82             00000001   PGPAWZ  EQU     TRUE                    ;True for pause after each page
    83             00000001   REPERR  EQU     TRUE                    ;True to report command line option errors
    84             00000001   REPSIZ  EQU     TRUE                    ;True to report file sizes
    85             00000001   REPUSR  EQU     TRUE                    ;True to report user numbers
    86             00000001   UOPT    EQU     TRUE                    ;True to allow user number option
    87                        ;
    88             00000004   NPL     EQU     4                       ;names/line (max of 3 for 64x16)
    89                        ;                                                   (MAX OF 4 FOR 80X24)
    90                        
    91             00000050   LPS     EQU     80                      ;lines/screen (max of 24 for 64x16)
    92                        ;                                                     (MAX OF 40 FOR 80X24)
    93                        ;
    94                        ;PEM FUNCTION DEFINITIONS
    95             00000000   WBOOT   EQU     0               ;do warm boot
    96             00000001   RDCHR   EQU     1               ;Read char from console
    97             00000002   WRCHR   EQU     2               ;Write char to console
    98             00000006   NOECHO  EQU     6               ;read char from console - no echo
    99             00000009   STRING  EQU     9               ;send $-terminated string to console
   100             0000000B   CONST   EQU     11              ;Check console status
   101             0000000E   SELDSK  EQU     14              ;Select disk
   102             00000011   SEARCH  EQU     17              ;A=$ff if not found
   103             00000012   NEXT    EQU     18              ;same
   104             00000019   CURDSK  EQU     25              ;Get currently logged disk name
   105             0000001A   SETDMA  EQU     26              ;Set current buffer addressDMA
   106             0000001B   GALLOC  EQU     27              ;Get address of allocation vector
   107             00000022   CURDCB  EQU     34              ;Get current disk parameters
   108             00000024   CURUSR  EQU     36              ;Get or set current user number (3.x only)
   109                        ;
   110                        ; Note: Disk Control Block has been changed!
   111                        ; DCB is now record based, no track/sector
   112                        ; DCB has no checksum entries, not needed for IDE block devices
   113                        ;
   114                        ;DCB contents are:
   115                        ;       MAXBLK  .word           maximum block number
   116                        ;       NRECRD  .word           number 128 byte records per disk block
   117                        ;       NSYSTR  .word           number of reserved records
   118                        ;       BLKSCD  .byte           0=1024,1=2048,2=4096,3=8192,4=16384
   119                        ;       MAXDIR  .word           max directory number
   120                        ;       ALCMAP  .word           address of allocation map
  Sat Feb 18 2023 11:03                                                                                                    Page 3


   121                        ;
   122                        ;DOS/65 addresses
   123             00000030   PZSTRT  EQU     $30             ;page zero start
   124             00000103   PEM     EQU     $103            ;fixed PEM entry point
   125             00000107   DFLFCB  EQU     $107            ;default FCB
   126             00000128   DFLBUF  EQU     $128            ;default disk buffer
   127             00000800   TEA     EQU     $800
   128                        ;
   129                                PAGE0
   130                        ;page zero storage
   131                                ORG     PZSTRT
   132 00:0030:              OLDUSR  DEFS    1               ;user number upon invocation
   133 00:0031:              NEWUSR  DEFS    1               ;user number selected by "$U" option
   134 00:0032:              OLDDSK  DEFS    1               ;Holder for currently logged-in drive
   135 00:0033:              CURDRV  DEFS    1               ;current drive
   136 00:0034:              SCOUNT  DEFS    2               ;# to sort
   137 00:0036:              SUPSPC  DEFS    1               ;Leading space flag for decimal routine
   138 00:0037:              TOTFIL  DEFS    2               ;Total number of files
   139 00:0039:              TOTSIZ  DEFS    2               ;Total size of all files
   140 00:003B:              HL      DEFS    2               ;16 bit pointer
   141                        ;next three variables are associated with option scan process
   142 00:003D:              BUFIND  DEFS    1               ;index into command line buffer
   143 00:003E:              BUFCNT  DEFS    1               ;number char left in buffer
   144 00:003F:              SCNCHR  DEFS    1               ;command line chr being compared
   145 00:0040:              TMPDIG  DEFS    1               ;save digit in scan
   146 00:0041:              COUNT   DEFS    2               ;Entry count
   147 00:0043:              COUNTS  DEFS    2               ;save as COUNT is modified
   148 00:0045:              FREEBY  DEFS    2               ;Contains number of K left on directory drive
   149 00:0047:              GAP     DEFS    2               ;Sort routine storage
   150 00:0049:              I       DEFS    2               ;Sort routine storage
   151 00:004B:              J       DEFS    2               ;Sort routine storage
   152 00:004D:              JPNT    DEFS    2               ;pointer in COMPARE
   153 00:004F:              JG      DEFS    2               ;Sort routine storage
   154 00:0051:              JGPNT   DEFS    2               ;pointer in COMPARE
   155 00:0053:              LZFLG   DEFS    1               ;0 when printing leading zeros
   156 00:0054:              MAXUSR  DEFS    1               ;Maximum user # for drive
   157 00:0055:              NEXTT   DEFS    2               ;Next table entry
   158                        ;
   159                        ;copy of DCB for selected drive
   160                        DCBCPY
   161 00:0057:              MAXBLK  DEFS    2
   162 00:0059:              NRECRD  DEFS    2
   163 00:005B:              NSYSTR  DEFS    2
   164 00:005D:              BLKSCD  DEFS    1
   165 00:005E:              MAXDIR  DEFS    2
   166 00:0060:              ALCMAP  DEFS    2
   167                        ;
   168                        ;more variables
   169 00:0062:              NUMBLK  DEFS    2               ;number of blocks
   170 00:0064:              BLKCNT  DEFS    2               ;counter for allocated blocks
   171 00:0066:              ALCPNT  DEFS    2               ;pointer used to scan map
   172 00:0068:              BYTTMP  DEFS    1               ;temp in map scan
   173 00:0069:              NMEPNT  DEFS    2               ;pointer in setting up ORDER
   174 00:006B:              FLDCNT  DEFS    1               ;count of fields per line
   175 00:006C:              MSGSAV  DEFS    2               ;save message pointer
   176 00:006E:              EXTENT  DEFS    2               ;extent number of last directory entry
   177                                                        ;and working location for file size
   178 00:0070:              MINUS   DEFS    2               ;save for modulus
   179 00:0072:              REMAIN  DEFS    1               ;remainder in K calculation
   180 00:0073:              CUREXT  DEFS    1               ;current extent
   181 00:0074:              SRCHFR  DEFS    1               ;first search in extent = 1, else 0
   182 00:0075:              INDX    DEFS    2               ;index pointer in MSgZer
   183 00:0077:                      ends
  Sat Feb 18 2023 11:03                                                                                                    Page 4


   184                        ;
   185                                code
   186                        ;********************************
   187                        ;                               *
   188                        ; BEGIN EXECUTABLE PROGRAM CODE *
   189                        ;                               *
   190                        ;********************************
   191                        ;
   192                                ORG     TEA
   193 00:0800: A9 DF        START   lda     #<opnmsg        ;point to message
   194 00:0802: A0 0D                ldy     #>opnmsg
   195 00:0804: 20 E6 0C             jsr     msgout          ;send it
   196                        ;
   197                                if      v3
   198 00:0807: A9 0F                lda     #15
   199 00:0809: 85 54                sta     maxusr
   200 00:080B: A9 FF                LDA     #255            ;Get current user number if DOS/65 V3
   201 00:080D: A2 24                ldx     #36
   202 00:080F: 20 03 01             jsr     pem
   203                                else
   204                        ;        lda     #0
   205                                stz     maxusr
   206                                endif
   207                        ;
   208 00:0812: 85 30                sta     OLDUSR          ;Initialize start up user number
   209 00:0814: 85 31                sta     NEWUSR          ;..and make new user match it
   210 00:0816: A2 19                ldx     #CURDSK
   211 00:0818: 20 03 01             jsr     pem             ;Get current disk nr
   212 00:081B: 85 32                sta     OLDDSK          ;Save for reset if needed
   213                        ;IF AT LEAST ONE OPTION IS ALLOWED, SCAN THE COMMAND LINE FOR THE
   214                        ;OPTION FIELD DELIMITER. THE OPTION FIELD DELIMITER IS CONSIDERED
   215                        ;VALID ONLY IF IT IS PRECEDED BY AT LEAST 1 SPACE (OTHERWISE, IT
   216                        ;MAY BE PART OF THE DIRECTORY FILENAME). ANY UNRECOGNIZED OPTIONS
   217                        ;OR ILLEGAL USER NUMBERS WILL BE FLAGGED OR IGNORED (SEE REPERR).
   218                        ;WE SCAN THE COMMAND LINE BUFFER RATHER THAN THE 2ND DEFAULT FCB
   219                        ;BECAUSE ALL OPTIONS PLUS A 2 DIGIT USER NUMBER WON't fit in
   220                        ;THE FCB NAME FIELD).
   221                        ;
   222                                IF      OPTION
   223 00:081D: AE 28 01             ldx     DflBuf          ;get length of command line
   224 00:0820: A0 00                ldy     #0              ;Set command line buffer index
   225                        ;
   226                        ;SEARCH FOR THE COMMAND LINE DELIMITER. IF NOT FOUND, ASSUME NO OPTIONS.
   227 00:0822: C8           SCNDOL  iny                     ;advance index
   228 00:0823: CA                   dex                     ;drop count
   229 00:0824: 10 03                bpl     pl001           ;continue if positive
   230 00:0826: 4C DC 08             jmp     ckrest          ;exit if command line buffer empty
   231 00:0829: B9 28 01     pl001   lda     DflBuf,y        ;get character
   232 00:082C: C9 3D                cmp     #'='
   233 00:082E: D0 F2                bne     SCNDOL          ;loop if not found
   234 00:0830: 88                   dey                     ;'=' found - make sure space precedes it
   235 00:0831: B9 28 01             lda     DflBuf,y
   236 00:0834: C8                   iny
   237 00:0835: C9 20                cmp     #' '
   238 00:0837: D0 E9                bne     SCNDOL          ;No space - ignore "=" and search again
   239                        ;VALID DELIMITER FOUND. SCAN THE REST OF THE BUFFER FOR OPTIONS. ERRORS
   240                        ;PAST THIS POINT WILL CAUSE AN ABORT IF THE COMMAND LINE ERROR OPTION IS
   241                        ;ENABLED. OTHERWISE, THE DUD OPTION WILL BE IGNORED AND SD WILL ATTEMPT
   242                        ;TO CONTINUE STUMBLING THROUGH THE REST OF THE FIELD.
   243 00:0839: C8           scnopt  iny                     ;bump index into buffer
   244 00:083A: 84 3D                sty     Bufind          ;save index
   245 00:083C: CA                   dex                     ;drop count
   246 00:083D: 86 3E                stx     BufCnt          ;save for later
  Sat Feb 18 2023 11:03                                                                                                    Page 5


   247 00:083F: 10 03                bpl     scnagn          ;continue if more
   248 00:0841: 4C DC 08             jmp     ckrest          ;if exhausted quit
   249 00:0844: B9 28 01     SCNAGN  lda     DflBuf,y        ;Get the next option character
   250 00:0847: 85 3F                sta     ScnChr          ;save char
   251 00:0849: C9 20                cmp     #' '            ;Do we have a space?
   252 00:084B: F0 EC                beq     SCNOPT          ;Ignore it if so
   253                        ;scan option table by first setting x & y
   254 00:084D: A2 03                ldx     #OEnd-OTbl+1    ;get length
   255 00:084F: A0 FF                ldy     #255            ;set index to -1
   256 00:0851: C8           NoMach  iny                     ;bump index
   257 00:0852: CA                   dex                     ;drop count
   258 00:0853: F0 12                beq     Ck4Usr          ;if none check battery
   259 00:0855: B9 69 0E             lda     Otbl,y          ;get char
   260 00:0858: C5 3F                cmp     ScnChr          ;compare to command line char
   261 00:085A: D0 F5                bne     NoMach          ;loop if no match
   262 00:085C: A9 00                lda     #0              ;else activate by erasing
   263 00:085E: 99 69 0E             sta     OTbl,y          ;option letter
   264 00:0861: A6 3E                ldx     BufCnt          ;restore count
   265 00:0863: A4 3D                ldy     BufInd          ;and index
   266 00:0865: 80 D2                bra     ScnOpt          ;loop for next command line chr
   267                        ;IF OPTION CHARACTER DOESN't match the table, see if we have a User
   268                        ;OPTION.
   269 00:0867: A4 3D        CK4USR  ldy     BufInd          ;get index
   270 00:0869: A6 3E                ldx     BufCnt          ;and count
   271 00:086B: B9 28 01             lda     dFLbUF,y        ;and character
   272                        ;
   273                                IF      UOPT            ;Check for user number option
   274 00:086E: C9 55                cmp     #'U'            ;see if U
   275 00:0870: D0 37                bne     CLERR           ;Last option, so bad deal if that ain't it
   276 00:0872: C8           UAGN    iny                     ;Bump to user number digit
   277 00:0873: CA                   dex                     ;DROP COUNT
   278 00:0874: 30 33                BMI     CLERR           ;Error if nothing left
   279 00:0876: B9 28 01             LDA     dFLbUF,Y        ;Get decimal digit
   280 00:0879: C9 20                CMP     #' '            ;Ignore leading spaces
   281 00:087B: F0 F5                BEQ     UAGN
   282 00:087D: 38                   SEC
   283 00:087E: E9 30                sbc     #'0'            ;Subtract ASCII BIAS
   284                        ;If result requires borrow then error
   285 00:0880: 90 27                bcc     CLERR           ;Error if < 0
   286 00:0882: C9 0A                cmp     #10
   287 00:0884: B0 23                bcs     CLERR           ;Error if > 9
   288 00:0886: 85 31                sta     NEWUSR          ;Save user number as it may be only 1 digit
   289 00:0888: C8                   iny                     ;Bump to possible 2nd digit of user number
   290 00:0889: CA                   dex
   291 00:088A: 30 50                bmi     CKREST          ;If no more buffer, exit with complete user #
   292 00:088C: B9 28 01             lda     DflBuf,y        ;Else, check for another digit
   293 00:088F: 38                   sec
   294 00:0890: E9 30                sbc     #'0'
   295 00:0892: 90 B0                bcc     SCNAGN          ;If next char not numeric not part of
   296 00:0894: C9 0A                cmp     #10             ;user number so go check for another option
   297 00:0896: B0 AC                bcs     SCNAGN
   298                        ;At this point we have a two digit number but only legal first digit is 1. So
   299                        ;check that it is 1
   300 00:0898: 85 40                sta     tmpdig          ;save low digit
   301 00:089A: A5 31                LDA     newusr          ;get it
   302 00:089C: C9 01                cmp     #1              ;check it
   303 00:089E: D0 09                bne     clerr           ;error if not 1
   304 00:08A0: 18                   clc                     ;now them all up
   305 00:08A1: A5 40                lda     tmpdig          ;get low back
   306 00:08A3: 69 0A                adc     #10             ;add 10
   307                        ;Note that user number could still be > 15 and illegal
   308 00:08A5: 85 31                sta     NEWUSR          ;Save the total user number
   309 00:08A7: 80 90                bra     SCNOPT          ;Continue scanning
  Sat Feb 18 2023 11:03                                                                                                    Page 6


   310                                ENDIF                   ;Balance UOPT
   311                        ;
   312                        ;IF COMMAND LINE ERROR OPTION ENABLED, PLAYBACK THE COMMAND LINE UP
   313                        ;TO THE CHARACTER THAT WE GAGGED ON AND EXIT. IF REPERR IS NOT ENABLED,
   314                        ;THEN CONTINUE AS IF NOTHING WERE AMISS TO AVOID ACKNOWLEDGING THAT
   315                        ;SOME OPTIONS ARE AVAILABLE.
   316                        CLERR
   317                                IF      REPERR
   318 00:08A9: A9 00                lda     #0              ;get ready to flag end
   319 00:08AB: C8                   iny
   320 00:08AC: 99 28 01             sta     DflBuf,y        ;do it
   321 00:08AF: 20 A1 0C             jsr     CRLF
   322 00:08B2: A9 0A                lda     #<errms2
   323 00:08B4: A0 0E                ldy     #>errms2
   324 00:08B6: 20 E6 0C             jsr     MsgOut
   325 00:08B9: A9 10                lda     #<errtag
   326 00:08BB: A0 0E                ldy     #>errtag
   327 00:08BD: 20 E6 0C             jsr     MsgOut
   328 00:08C0: A0 01                ldy     #1              ;Playback bad command line to error point
   329 00:08C2: B9 28 01     CLELP   lda     dflbuf,y
   330 00:08C5: F0 0A                beq     CLEX
   331 00:08C7: 84 3D                sty     BufInd          ;save index
   332 00:08C9: 20 B4 0C             jsr     TYPE
   333 00:08CC: A4 3D                ldy     BufInd          ;get index back
   334 00:08CE: C8                   iny                     ;bump it
   335 00:08CF: 80 F1                bra     CLELP
   336                        ;identify error point
   337 00:08D1: A9 3F        CLEX    lda     #'?'            ;Tag line with a '?' field
   338 00:08D3: 20 B4 0C             jsr     TYPE
   339 00:08D6: 20 A1 0C             jsr     CRLF            ;Space down 1 more line
   340 00:08D9: 4C D3 0D             JMP     EXIT            ;..and return to DOS/65
   341                                ELSE
   342                        ;
   343                                JMP     SCNOPT          ;If not reporting errors, ignore the dud
   344                                ENDIF                   ;Balance REPERR
   345                                ENDIF                   ;Balance OPTION
   346                        ;
   347                        ;OPTIONS INPUT complete OR none SPECIFIED.
   348                        CKREST
   349                        ;
   350 00:08DC: AD 08 01             lda     DflFCB+1        ;point to name
   351 00:08DF: C9 20                cmp     #' '            ;see if blank
   352 00:08E1: D0 0A                bne     gotfcb          ;if not use
   353                        ;NO FCB - MAKE  FCB ALL '?'
   354 00:08E3: A2 0B                ldx     #11             ;FN+FT count
   355 00:08E5: A9 3F                lda     #'?'            ;get ?
   356 00:08E7: 9D 07 01     QLOOP   sta     DflFCB,x        ;Store '?' IN FCB
   357 00:08EA: CA                   dex
   358 00:08EB: D0 FA                bne     qloop           ;loop if more
   359                        GOTFCB
   360                        ;Clear rest of FCB
   361 00:08ED: A9 00                lda     #0              ;get zero
   362 00:08EF: A0 0C                ldy     #12
   363 00:08F1: 99 07 01     clrfcb  sta     DflFCB,y        ;write 0
   364 00:08F4: C8                   iny
   365 00:08F5: C0 21                cpy     #33             ;see if past end
   366 00:08F7: D0 F8                bne     clrfcb
   367 00:08F9: 20 1E 0D             jsr     SETSRC          ;Set DMA for PEM media change check
   368 00:08FC: AD 07 01             lda     DflFCB          ;get drive code from FCB
   369 00:08FF: D0 04                bne     notdfl          ;if non-zero not default
   370 00:0901: A5 32                lda     olddsk          ;get old
   371 00:0903: 80 05                bra     setdfl          ;set default
   372 00:0905: 38           notdfl  sec                     ;Normalize drive code for SELECT
  Sat Feb 18 2023 11:03                                                                                                    Page 7


   373 00:0906: E9 01                sbc     #1
   374 00:0908: 29 07                and     #%00000111      ;look at three bits only
   375 00:090A: 85 33        setdfl  sta     curdrv          ;save for later
   376 00:090C: A2 0E                ldx     #SELDSK         ;Select the directory drive to retrieve
   377 00:090E: 20 03 01             jsr     PEM             ;..the proper allocation vector
   378                        ;        lda     #0              ;clear auto
   379 00:0911: 9C 07 01             stz     DflFCB
   380                        ;DOS/65 disk definition structure is not the same as CP/Ms.
   381 00:0914: A2 22        usedfl  ldx     #CurDCB         ;request DCB
   382 00:0916: 20 03 01             jsr     pem
   383 00:0919: 85 3B                sta     hl              ;save in pointer
   384 00:091B: 84 3C                sty     hl+1
   385                        ;HL points to (new) DCB - make a local copy of the 11 bytes
   386 00:091D: A0 00                ldy     #0
   387 00:091F: B1 3B        DCBLPE  lda     (hl),y          ;get actual
   388 00:0921: 99 57 00             sta     DCBCPY,y        ;save copy
   389 00:0924: C8                   iny                     ;bump index
   390 00:0925: C0 0B                cpy     #11             ;new DCB is smaller
   391 00:0927: D0 F6                bne     DCBLPE          ;loop 11 times
   392                        ;
   393                        ;CALCULATE # OF K FREE ON SELECTED DRIVE NOW
   394                        FREE    ; ldy     #0              ;clear
   395 00:0929: 64 64                stz     BlkCnt          ;block counter
   396 00:092B: 64 65                stz     BlkCnt+1        ;low and high
   397                        ;Get address of allocation vector
   398 00:092D: A5 60                lda     AlcMap          ;low then high
   399 00:092F: A4 61                ldy     AlcMap+1
   400 00:0931: 85 66                sta     AlcPnt          ;set pointer
   401 00:0933: 84 67                sty     AlcPnt+1
   402                        ;calculate length of allocation map
   403 00:0935: A5 57                lda     maxblk
   404 00:0937: A4 58                ldy     maxblk+1
   405 00:0939: 85 62                sta     NumBlk          ;save max
   406 00:093B: 84 63                sty     NumBlk+1
   407 00:093D: E6 62                inc     NumBlk          ;bump by one
   408 00:093F: D0 02                bne     gspbyt          ;skip if not roll over
   409 00:0941: E6 63                inc     NumBlk+1
   410                        GSPBYT  ; ldy     #0
   411 00:0943: B2 66                lda     (AlcPnt)      ;get byte
   412 00:0945: 85 68                sta     BytTmp          ;save it
   413 00:0947: A2 08                ldx     #8              ;Set to process 8 blocks
   414 00:0949: 06 68        GSPLUP  asl     BytTmp          ;Test bit
   415 00:094B: B0 06                bcs     NOTFRE          ;block used if c=1
   416 00:094D: E6 64                INC     BlkCnt          ;else bump count
   417 00:094F: D0 02                bne     notfre          ;skip if no roll over
   418 00:0951: E6 65                inc     BlkCnt+1        ;else bump high
   419 00:0953: 38           NOTFRE  sec                     ;drop total left by one
   420 00:0954: A5 62                lda     NumBlk
   421 00:0956: E9 01                sbc     #1
   422 00:0958: 85 62                sta     NumBlk
   423 00:095A: A5 63                lda     NumBlk+1        ;get high
   424 00:095C: E9 00                sbc     #0
   425 00:095E: 85 63                sta     NumBlk+1
   426 00:0960: 05 62                ora     NumBlk          ;see if now zero
   427 00:0962: F0 0B                beq     endalc          ;done if zero
   428 00:0964: CA                   dex                     ;Count down 8 bits
   429 00:0965: D0 E2                bne     GSPLUP          ;Do another bit
   430 00:0967: E6 66                inc     AlcPnt          ;go to next byte
   431 00:0969: D0 D8                bne     GSPBYT          ;skip if no roll over
   432 00:096B: E6 67                inc     AlcPnt+1
   433 00:096D: 80 D4        nz001   bra     GSPBYT          ;Process it
   434                        ;have now scanned the entire map
   435 00:096F: A5 64        ENDALC  lda     BlkCnt          ;get free block count
  Sat Feb 18 2023 11:03                                                                                                    Page 8


   436 00:0971: A4 65                ldy     BlkCnt+1
   437 00:0973: 85 45                sta     freeby          ;and save
   438 00:0975: 84 46                sty     freeby+1
   439 00:0977: A6 5D                ldx     BlkSCd          ;get block size code from DCB copy
   440 00:0979: F0 09                beq     savfre          ;done if 1K
   441 00:097B: 85 68                sta     BytTmp          ;set up temp
   442 00:097D: 06 45        FREKLP  asl     freeby          ;shift low
   443 00:097F: 26 46                rol     freeby+1
   444 00:0981: CA                   dex                     ;drop multiplier
   445 00:0982: D0 F9                bne     freklp          ;loop if more
   446                        ;Free space has been calculated - now set up search of directory. One
   447                        ;awkward aspect of that results from fact that DOS/65 does not do
   448                        ;wild card searches on the EXTENT. What code does is first search for
   449                        ;EXTENT=0 , then do EXTENT=1, etc. For EXTENT>0 use the first search
   450                        ;results to terminate searches beyond that point.
   451                        SAVFRE
   452                        ;
   453                        ;REENTER HERE ON SUBSEQUENT PASSES WHILE IN THE ALL-USERS MODE
   454                        SETTBL
   455 00:0984: A9 82                lda     #<name          ;of name
   456 00:0986: 85 55                sta     nextt           ;and init next table entry pointer
   457 00:0988: A9 0E                lda     #>name
   458 00:098A: 85 56                sta     nextt+1
   459                        ;pointer calculated and saved now
   460                        ;
   461                                IF      UOPT
   462 00:098C: A5 31                lda     NEWUSR          ;Get user area for directory
   463 00:098E: A2 24                ldx     #CURUSR         ;Get the user function
   464                        ;
   465                                if      v3
   466 00:0990: 20 03 01             jsr     pem             ;..and set new user number if V3
   467                                endif
   468                        ;
   469                                ENDIF
   470                        ;
   471                        ;LOOK UP THE FCB IN THE DIRECTORY
   472                        SFIRST  ; lda     #0              ;initialize counters
   473                        ;        tay
   474 00:0993: 64 41                stz     COUNT           ;Initialize match counter
   475 00:0995: 64 42                stz     count+1
   476 00:0997: 64 37                stz     TOTFIL          ;initialize total file counter
   477 00:0999: 64 38                stz     totfil+1
   478 00:099B: 64 39                stz     TOTSIZ          ;initialize total size counter
   479 00:099D: 64 3A                stz     totsiz+1
   480 00:099F: 20 1E 0D             jsr     SETSRC          ;Set DMA for directory search
   481                        ;set FCB for actual search
   482                        ;        lda     #0              ;reset current EXTENT to 0
   483 00:09A2: 64 73                stz     curext          ;reset current EXTENT to 0
   484 00:09A4: A5 73        newext  lda     curext          ;get current EXTENT
   485 00:09A6: 8D 13 01             sta     DflFCB+12
   486                        ;set flag so we will know this is first search for this extent
   487 00:09A9: A9 01                lda     #1
   488 00:09AB: 85 74                sta     srchfr
   489 00:09AD: A2 11                ldx     #SEARCH         ;Get 'search first' function
   490 00:09AF: 80 04                bra     LOOK            ;..and go search for 1st match
   491                        ;
   492                        ;READ MORE DIRECTORY ENTRIES
   493                        MORDIR  ; lda     #0              ;clear search first
   494 00:09B1: 64 74                stz     srchfr          ;clear first search
   495 00:09B3: A2 12                ldx     #NEXT           ;Search next but first
   496 00:09B5: A9 07        LOOK    lda     #<DflFCB
   497 00:09B7: A0 01                LDY     #>DflFCB
   498 00:09B9: 20 03 01             jsr     PEM             ;Read directory entry
  Sat Feb 18 2023 11:03                                                                                                    Page 9


   499 00:09BC: C9 FF                cmp     #255            ;check for not found
   500                        ;Check for "not found" (0FFH)
   501 00:09BE: D0 0A                bne     some            ;if not use
   502                        ;search found nothing so see if it was a first
   503 00:09C0: A5 74                lda     srchfr          ;read flag
   504 00:09C2: F0 02                beq     ntfirs          ;not a first so bump EXTENT
   505                        ;was a first search so done
   506 00:09C4: D0 3D                bne     sprint          ;go sort and print
   507                        ;was not a first search try new EXTENT
   508 00:09C6: E6 73        ntfirs  inc     curext          ;else bump current
   509 00:09C8: 80 DA                bra     newext          ;and loop
   510                        ;
   511                        ;POINT TO DIRECTORY ENTRY
   512                        SOME
   513 00:09CA: 29 03                AND     #3              ;Make modulus 4
   514 00:09CC: 0A                   asl     a               ;multiply by 32
   515 00:09CD: 0A                   asl     a
   516 00:09CE: 0A                   asl     a
   517 00:09CF: 0A                   asl     a
   518 00:09D0: 0A                   asl     a
   519                        ;at this point a=0,32,64, or 96
   520 00:09D1: AA                   tax                     ;make an index
   521 00:09D2: BD 28 01             lda     DflBuf,x        ;get user number
   522 00:09D5: C5 31                cmp     NEWUSR          ;compare to current user
   523 00:09D7: D0 D8                bne     MORDIR          ;Ignore if different
   524 00:09D9: E8                   inx                     ;go to name field
   525 00:09DA: A0 00                ldy     #0              ;clear destination index
   526                        ;MOVE ENTRY TO TABLE
   527 00:09DC: BD 28 01     TMOVE   LDA     DflBuf,x        ;Get entry char
   528 00:09DF: 29 7F                AND     #$7F            ;Remove attributes
   529 00:09E1: 91 55                sta     (nextt),y       ;Store in table
   530 00:09E3: C8                   iny                     ;bump destination index
   531 00:09E4: E8                   inx                     ;and source
   532 00:09E5: C0 0C                cpy     #12             ;see if destination at 12
   533 00:09E7: D0 F3                bne     tmove
   534                        ;at this point y is pointing to the correct destination for
   535                        ;record count but x is two short so bump x
   536 00:09E9: E8                   inx
   537 00:09EA: E8                   inx
   538 00:09EB: BD 28 01             lda     dflbuf,x        ;get record count
   539 00:09EE: 91 55                sta     (nextt),y       ;and save
   540                        ;now adjust table pointer to get ready for next match
   541 00:09F0: 18                   clc                     ;add 16 to address
   542 00:09F1: A5 55                lda     nextt           ;get low
   543 00:09F3: 69 10                adc     #16             ;add 16
   544 00:09F5: 85 55                sta     nextt           ;save low
   545 00:09F7: 90 02                bcc     CC002           ;if no carry skip high bump
   546 00:09F9: E6 56                inc     nextt+1
   547 00:09FB: E6 41        CC002   inc     count           ;bump match counter
   548 00:09FD: D0 02                bne     nz004
   549 00:09FF: E6 42                inc     count+1
   550 00:0A01: 80 AE        NZ004   bra     MORDIR          ;loop for more
   551                        ;
   552                        ;SORT AND PRINT
   553                        SPRINT
   554                        ;
   555                                IF      AOPT OR UOPT
   556 00:0A03: 20 16 0D             jsr     SETFOP          ;set file & user #
   557                                ENDIF
   558                        ;
   559 00:0A06: A5 41                lda     COUNT           ;Get file name count
   560 00:0A08: 05 42                ora     count+1         ;any found
   561 00:0A0A: D0 03                bne     nz005           ;yes so keep going
  Sat Feb 18 2023 11:03                                                                                                    Page 10


   562 00:0A0C: 4C 0A 0C             JMP     PRTOTL          ;Exit if no files found
   563                        NZ005
   564                        ;        lda     #0              ;set A to 0
   565 00:0A0F: 64 36                stz     SUPSPC          ;Enable leading space suppression (0)
   566 00:0A11: A5 41                lda     count           ;save count as sort count
   567 00:0A13: A4 42                ldy     count+1
   568 00:0A15: 85 34                sta     scount
   569 00:0A17: 84 35                sty     scount+1
   570                        ;test for only one entry
   571 00:0A19: C0 00                cpy     #0              ;if high not zero can
   572 00:0A1B: D0 07                bne     sort            ;not be one
   573 00:0A1D: C9 01                cmp     #1              ;test low
   574 00:0A1F: D0 03                bne     sort            ;if not one do sort
   575 00:0A21: 4C AE 0A             jmp     done            ;else done
   576                        ;
   577                        ;THIS SORT ROUTINE IS ADAPTED FROM SOFTWARE TOOLS
   578                        ;BY KERNIGAN AND PLAUGHER. As written it works with an array
   579                        ;of items numbered from 1 to N (SCOUNT). That is why COMPARE
   580                        ;and SWAP do a -1 record offset in the start to handle actual
   581                        ;data addresses of 0 to N-1. The items in this
   582                        ;case is the table of file names, types, extents, and records.
   583                        ;While V1.00 only deals with 13 of the 16 bytes in each table record
   584                        ;that was done because expanding the sort table indices to handle
   585                        ;16 byte records is a lot easier than handing 13 byte records.
   586                        ;The extra three bytes are ignored fir now.
   587 00:0A24: A5 34        SORT    lda     scount          ;get number of entries
   588 00:0A26: A4 35                ldy     scount+1
   589 00:0A28: 85 3B                sta     hl              ;and put in HL
   590 00:0A2A: 84 3C                sty     hl+1
   591 00:0A2C: 46 3C        L0      lsr     hl+1            ;gap=gap/2
   592 00:0A2E: 66 3B                ror     hl
   593 00:0A30: A5 3B                lda     hl              ;see if zero
   594 00:0A32: 05 3C                ora     hl+1
   595 00:0A34: F0 78                beq     done            ;if so none left
   596 00:0A36: A5 3B                lda     hl              ;make gap odd
   597 00:0A38: 09 01                ora     #1
   598 00:0A3A: 85 3B                sta     hl
   599 00:0A3C: 85 47                sta     gap             ;save gap
   600 00:0A3E: A5 3C                lda     hl+1
   601 00:0A40: 85 48                sta     gap+1
   602 00:0A42: E6 3B                inc     hl              ;I=GAP+1
   603 00:0A44: D0 02                bne     nz020           ;skip if no wrap
   604 00:0A46: E6 3C                inc     hl+1
   605                        nz020
   606                        ;
   607 00:0A48: A5 3B        L2      lda     hl
   608 00:0A4A: A4 3C                ldy     hl+1
   609 00:0A4C: 85 49                sta     I               ;actually use I
   610 00:0A4E: 84 4A                sty     I+1
   611 00:0A50: 38                   sec                     ;J=I-GAP
   612 00:0A51: A5 49                lda     I
   613 00:0A53: E5 47                sbc     gap
   614 00:0A55: 85 4B                sta     J
   615 00:0A57: A5 4A                lda     I+1
   616 00:0A59: E5 48                sbc     gap+1
   617 00:0A5B: 85 4C                sta     J+1
   618 00:0A5D: 18           L3      clc                     ;JG=J+GAP
   619 00:0A5E: A5 4B                lda     J
   620 00:0A60: 65 47                adc     GAP
   621 00:0A62: 85 4F                sta     JG
   622 00:0A64: A5 4C                lda     J+1
   623 00:0A66: 65 48                adc     GAP+1
   624 00:0A68: 85 50                sta     JG+1
  Sat Feb 18 2023 11:03                                                                                                    Page 11


   625                        ;Do the comparison between the two entries in NAME - only compare
   626                        ;12 bytes. COMPARE returns with CS result if A(J)>A(JG)
   627                        ;in which case swap is needed. But if A(J)<=A(JG) as CC shows do not swap.
   628 00:0A6A: A9 0C                lda     #12             ;compare 12 characters
   629 00:0A6C: 20 6F 0D             jsr     compare         ;compare A(J) and A(JG)
   630 00:0A6F: 90 18                bcc     L5              ;do nothing if C clear
   631 00:0A71: 20 5A 0D             jsr     SWAP            ;Exchange A(J) and A(JG)
   632 00:0A74: 38                   sec                     ;J=J-GAP
   633 00:0A75: A5 4B                lda     J
   634 00:0A77: E5 47                sbc     gap
   635 00:0A79: 85 4B                sta     J
   636 00:0A7B: A5 4C                lda     J+1
   637 00:0A7D: E5 48                sbc     gap+1
   638 00:0A7F: 85 4C                sta     J+1
   639 00:0A81: 30 06                bmi     L5              ;if J<0
   640 00:0A83: 05 4B                ora     J               ;check for zero
   641 00:0A85: F0 02                beq     L5              ;if J=0
   642 00:0A87: 80 D4                bra     L3              ;if J>0
   643 00:0A89: E6 49        L5      inc     I               ;I=I+1
   644 00:0A8B: D0 02                bne     NZ021
   645 00:0A8D: E6 4A                inc     I+1
   646                        NZ021
   647                        ;If I<=N goto L2
   648 00:0A8F: 38                   sec                     ;do as subtract N-I
   649 00:0A90: A5 34                lda     scount
   650 00:0A92: E5 49                sbc     I
   651 00:0A94: A5 35                lda     scount+1
   652 00:0A96: E5 4A                sbc     I+1
   653 00:0A98: B0 0A                bcs     CS002           ;I<=N
   654 00:0A9A: A5 47                lda     gap
   655 00:0A9C: A4 48                ldy     gap+1           ;preload gap into hl
   656 00:0A9E: 85 3B                sta     hl
   657 00:0AA0: 84 3C                sty     hl+1
   658 00:0AA2: 80 88                bra     L0
   659 00:0AA4: A5 49        CS002   lda     I
   660 00:0AA6: A4 4A                ldy     I+1
   661 00:0AA8: 85 3B                sta     hl              ;preload I into HL
   662 00:0AAA: 84 3C                sty     hl+1
   663 00:0AAC: 80 9A                bra     L2
   664                        ;SORT IS ALL DONE - PRINT ENTRIES
   665                        DONE
   666                        ;
   667                        NOOUT
   668 00:0AAE: A9 82                lda     #<name          ;initialize table pointer
   669 00:0AB0: A0 0E                ldy     #>name
   670 00:0AB2: 85 69                sta     nmepnt          ;by saving
   671 00:0AB4: 84 6A                sty     nmepnt+1
   672 00:0AB6: 4C A1 0B             JMP     NEWLIN          ;Start new line and output the files
   673                        ;
   674                        ;OUTPUT THE DIRECTORY FILES WE've matched.
   675 00:0AB9: 38           ENTRY   sec                     ;drop file count
   676 00:0ABA: A5 41                lda     count
   677 00:0ABC: E9 01                sbc     #1
   678 00:0ABE: 85 41                sta     count           ;and save
   679 00:0AC0: A5 42                lda     count+1
   680 00:0AC2: E9 00                sbc     #0
   681 00:0AC4: 85 42                sta     count+1
   682 00:0AC6: 05 41                ora     count           ;see if last file
   683 00:0AC8: F0 15                beq     OKPRNT          ;If COUNT=0, last file so skip compare
   684                        ;COMPARE EACH ENTRY TO MAKE SURE THAT IT ISN't part of a multiple
   685                        ;EXTENT FILE. GO ONLY WHEN WE HAVE THE LAST EXTENT OF THE FILE.
   686 00:0ACA: 20 03 0D             jsr     CKABRT          ;Check for abort code from keyboard
   687 00:0ACD: 20 38 0D             jsr     COMPR           ;Does this entry match next one?
  Sat Feb 18 2023 11:03                                                                                                    Page 12


   688 00:0AD0: D0 0D                bne     OKPRNT          ;No, print it
   689 00:0AD2: 18                   clc                     ;bump pointer by 16
   690 00:0AD3: A5 69                lda     nmepnt
   691 00:0AD5: 69 10                adc     #16
   692 00:0AD7: 85 69                sta     nmepnt
   693 00:0AD9: 90 02                bcc     cc004
   694 00:0ADB: E6 6A                inc     nmepnt+1
   695 00:0ADD: 80 DA        cc004   bra     ENTRY           ;Loop back for next lowest extent
   696                        ;VALID ENTRY OBTAINED - SPIT IT OUT.
   697                        OKPRNT
   698                        ;First do name
   699 00:0ADF: A0 00                ldy     #0              ;start at first byte
   700 00:0AE1: B1 69        CNAME   lda     (nmepnt),y      ;get name char
   701 00:0AE3: 99 6B 0E             sta     namcpy,y        ;save it
   702 00:0AE6: C8                   iny
   703 00:0AE7: C0 08                cpy     #8              ;see if past end
   704 00:0AE9: D0 F6                bne     cname           ;loop if more
   705                        ;now do type
   706 00:0AEB: A2 00                ldx     #0              ;use second index for copy
   707 00:0AED: B1 69        ctype   lda     (nmepnt),y      ;get char
   708 00:0AEF: 9D 74 0E             sta     typcpy,x        ;save it
   709 00:0AF2: E8                   inx
   710 00:0AF3: C8                   iny
   711 00:0AF4: C0 0B                cpy     #11             ;see if past end
   712 00:0AF6: D0 F5                bne     ctype           ;loop if more
   713                        ;now print
   714 00:0AF8: A9 6B                lda     #<namcpy        ;point to name
   715 00:0AFA: A0 0E                ldy     #>namcpy
   716 00:0AFC: 20 EB 0C             jsr     msgzer          ;print it
   717 00:0AFF: A9 2E                LDA     #'.'            ;Period after FN
   718 00:0B01: 20 B4 0C             jsr     TYPE
   719 00:0B04: A9 74                lda     #<typcpy        ;point to type
   720 00:0B06: A0 0E                ldy     #>typcpy
   721 00:0B08: 20 EB 0C             jsr     msgzer          ;print it
   722                        ;COMPUTE THE SIZE OF THE FILE AND UPDATE OUR SUMMARY DATUM.
   723 00:0B0B: A0 0B                ldy     #11             ;get extent
   724 00:0B0D: B1 69                lda     (nmepnt),y
   725 00:0B0F: 85 6E                sta     extent
   726                        ;        lda     #0              ;set high to 0
   727 00:0B11: 64 6F                stz     extent+1        ;set high byte to zero
   728 00:0B13: C8                   iny                     ;point to record count of last extent
   729 00:0B14: B1 69                lda     (nmepnt),y      ;get it
   730                        ;now convert whole extents to KB
   731 00:0B16: A2 04                ldx     #4              ;multiply by 16
   732 00:0B18: 06 6E        extmul  asl     extent
   733 00:0B1A: 26 6F                rol     extent+1
   734 00:0B1C: CA                   dex
   735 00:0B1D: D0 F9                bne     extmul          ;loop if more
   736                        ;now convert record count to KB
   737 00:0B1F: 86 72                stx     remain          ;clear remainder
   738 00:0B21: 4A                   lsr     a               ;divide by 2
   739 00:0B22: 66 72                ror     remain          ;set remainder if any
   740 00:0B24: 4A                   lsr     a
   741 00:0B25: 66 72                ror     remain
   742 00:0B27: 4A                   lsr     a
   743 00:0B28: 66 72                ror     remain
   744 00:0B2A: 29 1F                and     #%00011111
   745 00:0B2C: 18                   clc                     ;add to existing
   746 00:0B2D: 65 6E                adc     extent
   747 00:0B2F: 85 6E                sta     extent
   748 00:0B31: 90 02                bcc     cc005
   749 00:0B33: E6 6F                inc     extent+1
   750 00:0B35: A5 72        cc005   lda     remain          ;test remainder
  Sat Feb 18 2023 11:03                                                                                                    Page 13


   751 00:0B37: F0 06                beq     norem           ;if none ignore
   752 00:0B39: E6 6E                inc     extent          ;else bump by 1K
   753 00:0B3B: D0 02                bne     norem
   754 00:0B3D: E6 6F                inc     extent+1
   755                        norem
   756                        ;now round up to whole blocks
   757 00:0B3F: A6 5D                ldx     blkscd          ;get DCB parameter
   758 00:0B41: BD 78 0E             lda     kblkm,x         ;get K/BLK mask
   759 00:0B44: 25 6E                AND     extent          ;use as rounding
   760 00:0B46: F0 15                beq     noblk           ;if result 0 size is correct
   761 00:0B48: BD 78 0E             lda     kblkm,x         ;get mask again
   762 00:0B4B: 49 FF                eor     #%11111111      ;complement
   763 00:0B4D: 25 6E                and     extent          ;clear partial
   764 00:0B4F: 85 6E                sta     extent
   765 00:0B51: 18                   clc                     ;add block size to total
   766 00:0B52: BD 7D 0E             lda     kblk,x
   767 00:0B55: 65 6E                adc     extent
   768 00:0B57: 85 6E                sta     extent          ;save
   769 00:0B59: 90 02                bcc     noblk
   770 00:0B5B: E6 6F                inc     extent+1
   771                        ;now add this file size to total
   772 00:0B5D: 18           noblk   clc
   773 00:0B5E: A5 39                lda     totsiz
   774 00:0B60: 65 6E                adc     extent
   775 00:0B62: 85 39                sta     totsiz
   776 00:0B64: A5 3A                lda     totsiz+1
   777 00:0B66: 65 6F                adc     extent+1
   778 00:0B68: 85 3A                sta     totsiz+1
   779                        ;now bump file count
   780 00:0B6A: E6 37                inc     totfil
   781 00:0B6C: D0 02                bne     nz010
   782 00:0B6E: E6 38                inc     totfil+1
   783                        nz010
   784                        ;IF REPORT SIZE ENABLED, OUTPUT THE SIZE OF THE INDIVIDUAL FILE.
   785                        ;
   786                                IF      REPSIZ          ;If file size report wanted
   787 00:0B70: A9 01                lda     #1              ;do not suppress spaces
   788 00:0B72: 85 36                sta     supspc
   789 00:0B74: A5 6E                lda     extent          ;get file size
   790 00:0B76: A4 6F                ldy     extent+1
   791 00:0B78: 85 3B                sta     hl              ;pass in HL
   792 00:0B7A: 84 3C                sty     hl+1
   793 00:0B7C: 20 AB 0B             jsr     DECPRT          ;..go print it
   794 00:0B7F: A9 4B                LDA     #'K'            ;..and follow with K size
   795 00:0B81: 20 B4 0C             jsr     TYPE
   796                                ENDIF
   797                        ;
   798                        ;ONE FILE OUTPUT - TEST TO SEE IF WE HAVE TO OUTPUT ANOTHER ONE.
   799                        ;but first point to next entry in NAME
   800 00:0B84: 18                   clc
   801 00:0B85: A5 69                lda     nmepnt
   802 00:0B87: 69 10                adc     #16
   803 00:0B89: 85 69                sta     nmepnt
   804 00:0B8B: 90 02                bcc     cc050
   805 00:0B8D: E6 6A                inc     nmepnt+1
   806 00:0B8F: A5 41        cc050   lda     count           ;test count
   807 00:0B91: 05 42                ora     count+1
   808 00:0B93: D0 02                bne     nz011
   809 00:0B95: 80 73                bra     prtotl          ;if no more do summary
   810                        ;AT LEAST ONE MORE FILE TO OUTPUT - CAN WE PUT IT ON THE CURRENT LINE?
   811 00:0B97: C6 6B        nz011   dec     fldcnt          ;drop counter
   812 00:0B99: F0 06                beq     newlin          ;if zero new line
   813 00:0B9B: 20 AA 0C             jsr     FENCE           ;If room left, output the fence character
  Sat Feb 18 2023 11:03                                                                                                    Page 14


   814 00:0B9E: 4C B9 0A             JMP     ENTRY           ;.. and go output another file
   815                        ;CURRENT LINE FULL, START A NEW ONE.
   816 00:0BA1: A9 04        NEWLIN  lda     #NPL            ;Reset names per line counter
   817 00:0BA3: 85 6B                sta     fldcnt          ;set counter
   818 00:0BA5: 20 A1 0C             jsr     CRLF            ;Space down to next line
   819                        ;
   820                                IF      NPL<4           ;If printing less than 4 wide ..
   821                                clc
   822                                LDA     curdrv          ;.. precede new line with drive name
   823                                ADC     #'A'
   824                                jsr     TYPE
   825                        ;
   826                                IF      REPUSR and v3   ;If reporting user numbers and running under
   827                                                        ;V3, output the user number too
   828                                jsr     TYPUSR
   829                                ENDIF                   ;Balance REPUSR and v3
   830                        ;
   831                                lda     #':'            ;Tag header with a colon and a space
   832                                jsr     FPAD            ;..and exit back to ENTRY
   833                        ;
   834                                ENDIF                   ;Balance NPL GT 3
   835                        ;
   836 00:0BA8: 4C B9 0A             jmp     ENTRY           ;Go back and output another file
   837                        ;
   838                        ;PRINT HL IN DECIMAL WITH LEADING ZERO SUPPRESSION
   839                        DECPRT  ; lda     #0              ;Clear leading zero flag
   840 00:0BAB: 64 53                stz     LZFLG           ;clear leading zero flag
   841 00:0BAD: A9 E8                lda     #<1000
   842 00:0BAF: A0 03                ldy     #>1000          ;do 1000's first
   843 00:0BB1: 20 CA 0B             jsr     DIGIT
   844 00:0BB4: A9 64                lda     #<100
   845 00:0BB6: A0 00                ldy     #>100
   846 00:0BB8: 20 CA 0B             jsr     DIGIT
   847 00:0BBB: A9 0A                lda     #<10
   848 00:0BBD: A0 00                ldy     #>10
   849 00:0BBF: 20 CA 0B             jsr     DIGIT
   850 00:0BC2: 18                   clc
   851 00:0BC3: A9 30                LDA     #'0'            ;Get 1's digit
   852 00:0BC5: 65 3B                ADC     hl
   853 00:0BC7: 4C B4 0C             JMP     TYPE
   854                        ;do decimal digit
   855 00:0BCA: A2 30        DIGIT   LDX     #'0'            ;Start off with ASCII 0
   856 00:0BCC: 85 70                sta     minus           ;save modulus
   857 00:0BCE: 84 71                sty     minus+1
   858 00:0BD0: 38           DIGLP   sec                     ;subtract
   859 00:0BD1: A5 3B                lda     hl              ;modulus from hl
   860 00:0BD3: E5 70                sbc     minus
   861 00:0BD5: 85 3B                sta     hl              ;and save
   862 00:0BD7: A5 3C                lda     hl+1
   863 00:0BD9: E5 71                sbc     minus+1
   864 00:0BDB: 85 3C                sta     hl+1
   865 00:0BDD: 90 03                bcc     digex           ;done if borrow
   866 00:0BDF: E8                   INX                     ;Bump digit
   867 00:0BE0: 80 EE                bra     DIGLP           ;Loop back
   868                        ;at this point HL reflects the last borrow so add modulus back
   869 00:0BE2: 18           DIGEX   clc                     ;add modulus back
   870 00:0BE3: A5 3B                lda     hl
   871 00:0BE5: 65 70                adc     minus
   872 00:0BE7: 85 3B                sta     hl
   873 00:0BE9: A5 3C                lda     hl+1
   874 00:0BEB: 65 71                adc     minus+1
   875 00:0BED: 85 3C                sta     hl+1
   876 00:0BEF: 8A                   txa                     ;move digit to A
  Sat Feb 18 2023 11:03                                                                                                    Page 15


   877 00:0BF0: C9 30                cmp     #'0'            ;see if zero
   878 00:0BF2: D0 11                bne     dignz           ;go send it
   879                        ;we know digit is a 0 - check if leading 0 or not
   880 00:0BF4: A5 53                LDA     LZFLG           ;Leading zero?
   881 00:0BF6: F0 05                beq     notyp0          ;if clear do not type
   882 00:0BF8: A9 30                LDA     #'0'            ;else do type
   883 00:0BFA: 4C B4 0C             JMP     TYPE            ;Print digit
   884 00:0BFD: A5 36        notyp0  LDA     SUPSPC          ;Get space suppression flag
   885 00:0BFF: F0 03                beq     nospac          ;if clear no space
   886 00:0C01: 4C B2 0C             JMP     SPACE           ;Leading zero...print space
   887 00:0C04: 60           nospac  rts
   888                        ;print non-zero digit
   889 00:0C05: 85 53        DIGNZ   sta     LZFLG           ;Set leading flag so next zero prints
   890 00:0C07: 4C B4 0C             JMP     TYPE            ;And print digit
   891                        ;
   892                        ;SHOW TOTAL SPACE AND FILES USED
   893                        PRTOTL  ; lda     #0              ;suppress leading spaces
   894 00:0C0A: 64 36                stz     supspc          ;supress leading spaces
   895 00:0C0C: A5 37                lda     totfil          ;check total file count
   896 00:0C0E: 05 38                ora     totfil+1
   897 00:0C10: F0 4A                beq     nxtusr          ;skip if nothing found
   898 00:0C12: 8D 67 0E             sta     fndflg          ;set file found flag
   899 00:0C15: A9 26                lda     #<totms1        ;Print [CR,LF,LF]"DRIVE "
   900 00:0C17: A0 0E                ldy     #>totms1
   901 00:0C19: 20 E6 0C             jsr     MsgOut
   902 00:0C1C: 18                   clc
   903 00:0C1D: A5 33                LDA     curdrv
   904 00:0C1F: 69 41                ADC     #'A'
   905 00:0C21: 20 B4 0C             jsr     TYPE            ;Output the drive code
   906                        ;
   907                                IF      REPUSR and v3
   908 00:0C24: A9 31                lda     #<TOTMS2        ;Print ", USER "
   909 00:0C26: A0 0E                ldy     #>totms2
   910 00:0C28: 20 E6 0C             jsr     MsgOut
   911 00:0C2B: 20 8C 0C             jsr     TYPUSR          ;Output the user number
   912                                ENDIF
   913                        ;
   914 00:0C2E: A9 39        NOUSER  lda     #<totms3        ;print "CONTAINS "
   915 00:0C30: A0 0E                ldy     #>totms3
   916 00:0C32: 20 E6 0C             jsr     msgout
   917 00:0C35: A5 39                lda     totsiz          ;print total K used by files
   918 00:0C37: A4 3A                ldy     totsiz+1
   919 00:0C39: 85 3B                sta     hl
   920 00:0C3B: 84 3C                sty     hl+1
   921 00:0C3D: 20 AB 0B             jsr     decprt
   922 00:0C40: A9 44                lda     #<totms4        ;print "K IN "
   923 00:0C42: A0 0E                ldy     #>totms4
   924 00:0C44: 20 E6 0C             jsr     msgout
   925 00:0C47: A5 37                lda     totfil          ;print total files
   926 00:0C49: A4 38                ldy     totfil+1
   927 00:0C4B: 85 3B                sta     hl
   928 00:0C4D: 84 3C                sty     hl+1
   929 00:0C4F: 20 AB 0B             jsr     DECPRT          ;Print number of files matched
   930 00:0C52: A9 4A                lda     #<TOTMS5        ;Print " FILES WITH "
   931 00:0C54: A0 0E                ldy     #>totms5
   932 00:0C56: 20 E6 0C             jsr     MsgOut
   933 00:0C59: 20 27 0D             jsr     PRTFRE          ;Output free space remaining & " FREE."
   934                        ;DIRECTORY FOR ONE USER AREA COMPLETED. IF ALL USERS OPTION IS
   935                        ;SELECTED, THEN GO DO ANOTHER DIRECTORY ON THE NEXT USER NUMBER
   936                        ;UNTIL WE EXCEED THE MAXIMUM USER # FOR THE SELECTED DRIVE.
   937                        NXTUSR
   938                                IF      AOPT            ;If all users option enabled
   939 00:0C5C: AD 69 0E             lda     AOPFLG          ;If not all users mode - skip next
  Sat Feb 18 2023 11:03                                                                                                    Page 16


   940 00:0C5F: D0 0E                bne     goclz
   941                        ;
   942                                if      v3
   943 00:0C61: 20 03 0D             jsr     CKABRT          ;Check for user abort first
   944 00:0C64: A5 54                lda     MAXUSR          ;No abort - get maximum user number
   945 00:0C66: E6 31                inc     newusr          ;bump user
   946 00:0C68: C5 31                cmp     newusr          ;compare max to new
   947 00:0C6A: 90 03                bcc     cc003           ;if borrow at end
   948 00:0C6C: 4C 84 09             jmp     settbl          ;else use
   949                        cc003
   950                                endif                   ;balance v3
   951                        ;
   952                                ENDIF                   ;Balance AOPT
   953                        ;
   954                        ; WE've finished all of our outputting.
   955                        ;
   956                        GOCLZ
   957                        ;
   958                        ;DIRECTORY FOR ALL USER AREAS COMPLETED.
   959 00:0C6F: AD 67 0E     NXTDSK  lda     fndflg          ;get flag
   960 00:0C72: D0 15                bne     ndsk            ;exit if none
   961                        ;        lda     #0              ;clear flag
   962 00:0C74: 9C 67 0E             stz     fndflg
   963 00:0C77: 18                   clc
   964 00:0C78: A5 33                LDA     curdrv          ;Stash ASCII drive in NO FILE msg
   965 00:0C7A: 69 41                ADC     #'A'
   966 00:0C7C: 8D 21 0E             sta     NOFMS2
   967 00:0C7F: A9 14                lda     #<NOFMS1        ;Print "NO FILE ON ? - "
   968 00:0C81: A0 0E                ldy     #>nofms1
   969 00:0C83: 20 E6 0C             jsr     MsgOut
   970 00:0C86: 20 27 0D             jsr     PRTFRE          ;Tag with free message
   971 00:0C89: 4C D3 0D     NDSK    JMP     EXIT            ;All done - exit to CCP
   972                        ;
   973                        ;PRINT THE USER NUMBER OF THE DIRECTORY IN DECIMAL
   974                        TYPUSR
   975                                IF      REPUSR
   976 00:0C8C: A5 31                LDA     NEWUSR
   977 00:0C8E: C9 0A                CMP     #10             ;If user no. > 9 print leading 1
   978 00:0C90: 90 0A                bcc     DUX
   979 00:0C92: A9 31                LDA     #'1'
   980 00:0C94: 20 B4 0C             jsr     TYPE
   981 00:0C97: 38                   sec
   982 00:0C98: A5 31                LDA     NEWUSR          ;Print low digit of user no.
   983 00:0C9A: E9 0A                SBC     #10
   984 00:0C9C: 18           DUX     clc
   985 00:0C9D: 69 30                ADC     #'0'
   986 00:0C9F: 80 13                bra     TYPE
   987                                ENDIF
   988                        ;
   989                        ;FORCE NEW LINE ON console
   990 00:0CA1: A9 0D        CRLF    LDA     #cr             ;Send CR
   991 00:0CA3: 20 B4 0C             jsr     TYPE
   992 00:0CA6: A9 0A                LDA     #lf             ;Send LF
   993 00:0CA8: 80 0A                bra     TYPE            ;Exit to caller from TYPE
   994                        ;
   995                        ;SEPARATE THE DIRECTORY OUTPUT ON A LINE WITH A SPACE, THE DELIMITER,
   996                        ;FOLLOWED BY ANOTHER SPACE.
   997 00:0CAA: 20 B2 0C     FENCE   jsr     SPACE
   998 00:0CAD: A9 7C                LDA     #DELIM          ;Fence character
   999 00:0CAF: 20 B4 0C     FPAD    jsr     TYPE            ;Print it, fall into space
  1000 00:0CB2: A9 20        SPACE   LDA     #' '            ;Fall through to TYPE
  1001                        ;OUTPUT CHARACTER IN A TO CONSOLE - and save char as function
  1002                        ;of options selected
  Sat Feb 18 2023 11:03                                                                                                    Page 17


  1003 00:0CB4: 48           TYPE    pha                     ;Save the character to output
  1004 00:0CB5: 20 E1 0C             jsr     TYPE1           ;Send it to console
  1005 00:0CB8: 68                   pla                     ;Restore the output character
  1006                        ;TEST PAGE PAUSE TEST IF NOT ACTIVE.
  1007 00:0CB9: C9 0A                cmp     #lf             ;see if lf
  1008 00:0CBB: D0 23                bne     typret          ;done if not
  1009                        ;
  1010                                IF      NOPT AND PGPAWZ
  1011 00:0CBD: AD 6A 0E             LDA     NOPFLG          ;Is the page pause function disabled?
  1012 00:0CC0: F0 1E                beq     TYPRET          ;Exit if so
  1013                                ENDIF
  1014                        ;
  1015                                IF      PGPAWZ
  1016 00:0CC2: EE 68 0E             inc     LINCNT          ;Get line count
  1017 00:0CC5: AD 68 0E             lda     lincnt
  1018 00:0CC8: C9 50                cmp     #lps            ;see if at end screen
  1019 00:0CCA: D0 14                bne     NOTEOS          ;Skip if not
  1020 00:0CCC: A9 FC                lda     #<eosmsg        ;Else, display pause message
  1021 00:0CCE: A0 0D                ldy     #>eosmsg
  1022 00:0CD0: 20 E6 0C             jsr     msgout
  1023 00:0CD3: 20 FE 0C             jsr     CINPUT          ;Wait for character
  1024 00:0CD6: C9 03                CMP     #'C'-$40
  1025 00:0CD8: D0 03                bne     nz013           ;continue if not
  1026 00:0CDA: 4C D3 0D             JMP     EXIT            ;Abort on CTRL-C
  1027                        nz013   ; lda     #0              ;reset line count
  1028 00:0CDD: 9C 68 0E             stz     lincnt
  1029                        NOTEOS
  1030                                ENDIF
  1031                        ;
  1032 00:0CE0: 60           TYPRET  rts                     ;Exit from TYPE
  1033                        ;
  1034                        ;OUTPUT CHARACTER in A to console
  1035 00:0CE1: A2 02        TYPE1   ldx     #WRCHR
  1036 00:0CE3: 4C 03 01             jmp     pem             ;Call CONOUT via pem
  1037                        ;
  1038                        ;Print $-terminated message on console
  1039                        ;Message start in AY
  1040 00:0CE6: A2 09        MsgOut  ldx     #string
  1041 00:0CE8: 4C 03 01             jmp     pem
  1042                        ;
  1043                        ;Print 0 terminated message on console - start in AY
  1044                        ;at entry.
  1045 00:0CEB: 85 75        MsgZer  sta     indx            ;save address
  1046 00:0CED: 84 76                sty     indx+1
  1047 00:0CEF: B2 75        MsgZLp  lda     (indx)          ;get character
  1048 00:0CF1: F0 ED                beq     TYPRET          ;done if zero
  1049 00:0CF3: 20 B4 0C             jsr     type            ;else send to console
  1050 00:0CF6: E6 75                inc     indx            ;bump address
  1051 00:0CF8: D0 F5                bne     MsgZLp          ;loop
  1052 00:0CFA: E6 76                inc     indx+1
  1053 00:0CFC: 80 F1                bra     MsgZLp          ;loop
  1054                        ;MsgZX   rts
  1055                        ;FETCH CHARACTER FROM CONSOLE (WITHOUT ECHO)
  1056 00:0CFE: A2 06        CINPUT  ldx     #noecho         ;read input w/o echo
  1057 00:0D00: 4C 03 01             jmp     pem
  1058                        ;
  1059                        ;CHECK FOR A CTRL-C ENTERED FROM THE KEYBOARD. JUMP TO
  1060                        ;EXIT IF CTRL-C. System already checks for and handles ctl-s
  1061                        ;and ctl-q for pause and resume.
  1062 00:0D03: A2 0B        CKABRT  ldx     #const          ;check console input
  1063 00:0D05: 20 03 01             jsr     pem
  1064 00:0D08: F0 D6                beq     TYPRET          ;done if nothing there
  1065 00:0D0A: A2 06                ldx     #noecho         ;something there - get
  Sat Feb 18 2023 11:03                                                                                                    Page 18


  1066 00:0D0C: 20 03 01             jsr     pem             ;without echo
  1067 00:0D0F: C9 03                cmp     #'C'-$40        ;see if ctl-c
  1068 00:0D11: D0 CD                bne     TYPRET          ;if not ignore
  1069 00:0D13: 4C D3 0D             jmp     exit            ;else exit
  1070                        ;eq030   rts
  1071                        ;
  1072                        ;RETURN TO OLD USER AREA
  1073                        SETFOP
  1074                                IF      UOPT OR AOPT
  1075 00:0D16: A5 30                lda     OLDUSR          ;Get user number at start up
  1076 00:0D18: A2 24                LDX     #CURUSR
  1077                        ;
  1078                                if      v3
  1079 00:0D1A: 20 03 01             jsr     pem             ;Reset the old user number if V3
  1080                                endif
  1081                        ;
  1082                                ENDIF
  1083                        ;
  1084 00:0D1D: 60                   rts
  1085                        ;
  1086                        ;MOVE DISK BUFFER DMA TO DEFAULT BUFFER FOR DIRECTORY SEARCH OPERATIONS
  1087                        ;AND BDOS MEDIA CHANGE ROUTINES.
  1088 00:0D1E: A9 28        SETSRC  lda     #<DflBuf        ;point to default
  1089 00:0D20: A0 01                ldy     #>DflBuf
  1090 00:0D22: A2 1A                ldx     #SETDMA
  1091 00:0D24: 4C 03 01             jmp     pem
  1092                        ;
  1093                        ;PRINT THE AMOUNT OF FREE SPACE REMAINING ON THE SELECTED DRIVE
  1094 00:0D27: A5 45        PRTFRE  lda     FreeBy          ;get space
  1095 00:0D29: A4 46                ldy     FreeBy+1
  1096 00:0D2B: 85 3B                sta     hl
  1097 00:0D2D: 84 3C                sty     hl+1
  1098 00:0D2F: 20 AB 0B             jsr     DECPRT          ;Print K free
  1099 00:0D32: A9 57                lda     #<totms6        ;point to message
  1100 00:0D34: A0 0E                ldy     #>totms6        ;Print " FREE."
  1101 00:0D36: 80 AE                bra     MsgOut
  1102                        ;
  1103                        ;ROUTINE used to compact tables. This
  1104                        ;routine assumes SORT puts the extents for a given
  1105                        ;file in order such that the last extent will be
  1106                        ;the last entry matching the name and type fields.
  1107                        ;NEXTT is the pointer to the NAME entry.
  1108                        ;At exit EQ (z=1) will be set if a match - NE (z=0)
  1109                        ;will be set if not a match.
  1110 00:0D38: A5 69        compr   lda     nmepnt          ;copy pointer
  1111 00:0D3A: A4 6A                ldy     nmepnt+1
  1112 00:0D3C: 85 55                sta     nextt           ;set second pointer
  1113 00:0D3E: 84 56                sty     nextt+1
  1114                        ;now increase nextt to point to next entry
  1115 00:0D40: 18                   clc
  1116 00:0D41: A5 55                lda     nextt           ;bump by 2
  1117 00:0D43: 69 10                adc     #16
  1118 00:0D45: 85 55                sta     nextt
  1119 00:0D47: 90 02                bcc     cc006
  1120 00:0D49: E6 56                inc     nextt+1
  1121 00:0D4B: A0 00        cc006   ldy     #0              ;set index too start
  1122 00:0D4D: A2 0B                ldx     #11             ;compare 11
  1123 00:0D4F: B1 69        comprlp lda     (nmepnt),y      ;get first
  1124 00:0D51: D1 55                cmp     (nextt),y       ;do compare
  1125 00:0D53: D0 04                bne     nz009           ;exit if mismatch
  1126 00:0D55: C8                   iny
  1127 00:0D56: CA                   dex                     ;drop count
  1128 00:0D57: D0 F6                bne     comprlp         ;loop if more
  Sat Feb 18 2023 11:03                                                                                                    Page 19


  1129 00:0D59: 60           nz009   rts
  1130                        ;
  1131                        ;SWAP ENTRIES IN THE NAME TABLE. Note that COMPARE calculates
  1132                        ;and saves the pointers JPNT and JGPNT and nothing changes them
  1133                        ;between COMPARE and call to SWAP.
  1134 00:0D5A: A2 0D        SWAP    ldx     #13             ;only 13 valid bytes
  1135 00:0D5C: A0 00                ldy     #0
  1136 00:0D5E: B1 4D        swaplp  lda     (jpnt),y        ;get low of j
  1137 00:0D60: 85 68                sta     byttmp          ;save
  1138 00:0D62: B1 51                lda     (jgpnt),y       ;get low of JG
  1139 00:0D64: 91 4D                sta     (jpnt),y        ;swap into j
  1140 00:0D66: A5 68                lda     byttmp          ;now swap into jg
  1141 00:0D68: 91 51                sta     (jgpnt),y
  1142 00:0D6A: C8                   iny
  1143 00:0D6B: CA                   dex
  1144 00:0D6C: D0 F0                bne     swaplp          ;loop if more
  1145 00:0D6E: 60                   rts
  1146                        ;
  1147                        ;This is the compare routine for the Shell sort.
  1148                        ;Compare A(J) with A(JG) and return with CS if
  1149                        ;A(J) > A(JG) and hence swap required. If CC
  1150                        ;then A(J) <= A(JG) and no swap required.
  1151                        COMPARE
  1152                        ;First  translate simple counts in J and JG to pointers
  1153                        ;to the NAME table.
  1154                        ;Do JPnt first
  1155 00:0D6F: A5 4B                lda     j
  1156 00:0D71: A4 4C                ldy     j+1
  1157 00:0D73: 85 4D                sta     jpnt            ;copy to pointer
  1158 00:0D75: 84 4E                sty     jpnt+1          ;now do 16x
  1159 00:0D77: A2 04                ldx     #4
  1160 00:0D79: 06 4D        jx16    asl     jpnt
  1161 00:0D7B: 26 4E                rol     jpnt+1
  1162 00:0D7D: CA                   dex
  1163 00:0D7E: D0 F9                bne     jx16
  1164                        ;name-16 is used to change start from 1 to 0
  1165 00:0D80: 18                   clc                     ;now add table start
  1166 00:0D81: A5 4D                lda     jpnt
  1167 00:0D83: 69 72                adc     #(name-16)*256/256      ;use actual start
  1168 00:0D85: 85 4D                sta     jpnt
  1169 00:0D87: A5 4E                lda     jpnt+1
  1170 00:0D89: 69 0E                adc     #(name-16)/256
  1171 00:0D8B: 85 4E                sta     jpnt+1
  1172                        ;now do jgpnt
  1173 00:0D8D: A5 4F                lda     jg
  1174 00:0D8F: A4 50                ldy     jg+1
  1175 00:0D91: 85 51                sta     jgpnt           ;copy to pointer
  1176 00:0D93: 84 52                sty     jgpnt+1         ;now do 16x
  1177 00:0D95: A2 04                ldx     #4
  1178 00:0D97: 06 51        jgx16   asl     jgpnt
  1179 00:0D99: 26 52                rol     jgpnt+1
  1180 00:0D9B: CA                   dex
  1181 00:0D9C: D0 F9                bne     jgx16
  1182 00:0D9E: 18                   clc                     ;now add table start
  1183 00:0D9F: A5 51                lda     jgpnt
  1184 00:0DA1: 69 72                adc     #(name-16)*256/256      ;use actual start
  1185 00:0DA3: 85 51                sta     jgpnt
  1186 00:0DA5: A5 52                lda     jgpnt+1
  1187 00:0DA7: 69 0E                adc     #(name-16)/256
  1188 00:0DA9: 85 52                sta     jgpnt+1
  1189                        ;At this point jpnt and jgpnt point to the start of an entry in NAME
  1190 00:0DAB: A2 0C                ldx     #12             ;compare first 12
  1191 00:0DAD: A0 00                ldy     #0              ;get index ready
  Sat Feb 18 2023 11:03                                                                                                    Page 20


  1192 00:0DAF: B1 4D        cmplpe  lda     (jpnt),y        ;get a(J)
  1193 00:0DB1: D1 51                cmp     (jgpnt),y       ;compare a(jg)
  1194 00:0DB3: D0 05                bne     nz030           ;done if not same
  1195 00:0DB5: C8                   iny                     ;next byte
  1196 00:0DB6: CA                   dex                     ;drop counter
  1197 00:0DB7: D0 F6                bne     cmplpe
  1198                        ;At this point all bytes tested and are equal so
  1199                        ;clear carry and return.
  1200 00:0DB9: 18                   clc
  1201                        ;        rts
  1202                        ;at this point we know there is a difference so they
  1203                        ;can not be equal. That means that a(j) must be greater
  1204                        ;if C set (no borrow) or smaller if C clear (borrow). If A(j) is
  1205                        ;smaller then no swap is required so just return. In the
  1206                        ;same path if C is set (no borrow) then swap is required
  1207                        ;so just return.
  1208 00:0DBA: 60           nz030   rts                     ;exit
  1209                        ;
  1210                        ;ERROR EXIT
  1211 00:0DBB: 85 6C        ERXIT   sta     msgsav          ;save message address
  1212 00:0DBD: 84 6D                sty     msgsav+1
  1213 00:0DBF: 20 A1 0C             jsr     CRLF            ;Space down
  1214 00:0DC2: A5 6C                lda     msgsav          ;get message pointer
  1215 00:0DC4: A4 6D                ldy     msgsav+1
  1216 00:0DC6: 20 E6 0C             jsr     msgout          ;Print it
  1217 00:0DC9: A9 09                lda     #<errms1        ;print ERROR
  1218 00:0DCB: A0 0E                ldy     #>errms1
  1219 00:0DCD: 20 E6 0C             jsr     msgout
  1220 00:0DD0: 20 A1 0C             jsr     CRLF            ;Space down fall into exit
  1221                        ;
  1222                        ;EXIT - ALL DONE
  1223 00:0DD3: A2 0B        EXIT    ldx     #CONST          ;Check console status
  1224 00:0DD5: 20 03 01             jsr     pem
  1225 00:0DD8: F0 E0                beq     nz030           ;Char waiting?
  1226 00:0DDA: A2 01                ldx     #RDCHR
  1227 00:0DDC: 4C 03 01             jmp     pem             ;Gobble up char
  1228                        ;L001    rts
  1229                        ;
  1230                        ;**********************
  1231                        ;                     *
  1232                        ; END OF PROGRAM CODE *
  1233                        ;                     *
  1234                        ;**********************
  1235                        ;
  1236                        ; INITIALIZED DATA AREA
  1237                        ;messages
  1238 00:0DDF: 44 4F 53 2F  opnmsg  defb    'DOS/65 SUPER DIRECTORY V1.04$'
       00:0DE3: 36 35 20 53 
       00:0DE7: 55 50 45 52 
       00:0DEB: 20 44 49 52 
       00:0DEF: 45 43 54 4F 
       00:0DF3: 52 59 20 56 
       00:0DF7: 31 2E 30 34 
       00:0DFB: 24 
  1239                        ;
  1240                                IF      PGPAWZ
  1241 00:0DFC: 0A 5B 20 4D  EOSMSG  DEFB    lf,'[ More ]',cr,lf,lf,'$'
       00:0E00: 6F 72 65 20 
       00:0E04: 5D 0D 0A 0A 
       00:0E08: 24 
  1242                                ENDIF
  1243                        ;
  1244 00:0E09: 20           ERRMS1  DEFB    ' '
  Sat Feb 18 2023 11:03                                                                                                    Page 21


  1245 00:0E0A: 45 52 52 4F  ERRMS2  DEFB    'ERROR$'
       00:0E0E: 52 24 
  1246                        ;
  1247                                IF      REPERR
  1248 00:0E10: 20 2D 3E 24  ERRTAG  DEFB    ' ->$'
  1249                                ENDIF
  1250                        ;
  1251 00:0E14: 0D 0A 4E 4F  NOFMS1  DEFB    cr,lf,'NO FILE ON '
       00:0E18: 20 46 49 4C 
       00:0E1C: 45 20 4F 4E 
       00:0E20: 20 
  1252 00:0E21: 20 20 2D 20  NOFMS2  DEFB    '  - $'
       00:0E25: 24 
  1253                        ;
  1254 00:0E26: 0D 0A 0D 0A  TOTMS1  DEFB    cr,lf,cr,lf,'DRIVE $'
       00:0E2A: 44 52 49 56 
       00:0E2E: 45 20 24 
  1255                        ;
  1256                                IF      REPUSR
  1257 00:0E31: 2C 20 55 53  TOTMS2  DEFB    ', USER $'
       00:0E35: 45 52 20 24 
  1258                                ENDIF
  1259                        ;
  1260 00:0E39: 20 43 4F 4E  TOTMS3  DEFB    ' CONTAINS $'
       00:0E3D: 54 41 49 4E 
       00:0E41: 53 20 24 
  1261 00:0E44: 4B 20 49 4E  TOTMS4  DEFB    'K IN $'
       00:0E48: 20 24 
  1262 00:0E4A: 20 46 49 4C  TOTMS5  DEFB    ' FILES WITH $'
       00:0E4E: 45 53 20 57 
       00:0E52: 49 54 48 20 
       00:0E56: 24 
  1263 00:0E57: 4B 20 46 52  TOTMS6  DEFB    'K FREE',cr,lf,'$'
       00:0E5B: 45 45 0D 0A 
       00:0E5F: 24 
  1264 00:0E60: 55 53 45 52  USRMSG  DEFB    'USER #$'
       00:0E64: 20 23 24 
  1265                        ;
  1266 00:0E67: 00           FNDFLG  DEFB    0               ;Flag whether any files matched
  1267                        ;
  1268                                IF      PGPAWZ
  1269 00:0E68: 00           LINCNT  DEFB    0               ;Count of lines printed on screen
  1270                                ENDIF
  1271                        ;
  1272                        ;OPTION FIELD LOOKUP TABLE.
  1273                        ;NOTE THAT YOU CAN FORCE ANY OF THESE OPTIONS AS A DEFAULT BY
  1274                        ;CHANGING THE LETTER FOR THE OPTION INTO A ZERO (ASSUMING THAT
  1275                        ;ITS ENABLING EQUATE IS TRUE). EACH OPTION THAT YOU HARD-WIRE IN
  1276                        ;THIS MANNER WILL NO LONGER BE RECOGNIZED AS A COMMAND LINE OPTION,
  1277                        ;AND IF YOU REDUNDANTLY KEY IT IN, SD WILL FLAG IT AS UNRECOGNIZED.
  1278             00000E69   OTBL    EQU     *               ;Mark start of option table
  1279                        ;
  1280                                IF      AOPT            ;All users-option flag
  1281 00:0E69: 41           AOPFLG  DEFB    'A'
  1282                                ENDIF
  1283                        ;
  1284                                IF      NOPT AND PGPAWZ ;No page-pause option flag
  1285 00:0E6A: 4E           NOPFLG  DEFB    'N'
  1286                                ENDIF
  1287                        ;
  1288             00000E6B   OEND    EQU     *               ;Mark end of option table
  1289                        ;
  1290                        ;END OF OPTION LOOKUP TABLE
  Sat Feb 18 2023 11:03                                                                                                    Page 22


  1291                        ;Locations to store printing copy of name and type fields
  1292 00:0E6B: 20 20 20 20  namcpy  defb    '        ',0
       00:0E6F: 20 20 20 20 
       00:0E73: 00 
  1293 00:0E74: 20 20 20 00  typcpy  defb    '   ',0
  1294                        ;table of mask for KB per block - use BLKSCD to index
  1295 00:0E78: 00 01 03 07  kblkm   defb    0,1,3,7,15
       00:0E7C: 0F 
  1296                        ;table of K to add for partial block
  1297 00:0E7D: 00 02 04 08  kblk    defb    0,2,4,8,16
       00:0E81: 10 
  1298                        ;
  1299                        ;UNINITIALIZED DATA AREA
  1300                        ;This area consists of one table - NAME. When SORT is
  1301                        ;executed, the entire value used for the comparison is the first 12 bytes
  1302                        ;entry in NAME containing:
  1303                        ;       name - 8 bytes
  1304                        ;       type - 3 bytes
  1305                        ;       extent - 1 byte
  1306                        ;       records - 1 byte
  1307                        ;       dummy - 3 bytes
  1308                        ;as extracted from each 32 byte directory entry.
  1309                        ;NAME
  1310                        ;       NAME    fixed start of table
  1311                        ;       nmepnt  word pointer used during table set up
  1312                        ;       NEXTT   word pointer to next table entry
  1313                        ;       COUNT   word showing number of actual table entries
  1314                        ;       COUNTS  word holding saved value of COUNT
  1315                        ;       SCOUNT  word showing number entries to sort
  1316                        ;
  1317             00000E82   NAME    EQU     *               ;name table starts here
  1318                                ends
  1319                                end


      Lines assembled: 1319
      Errors: 0
