  Mon Apr  3 2023 10:57                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C02 Macro Assembler    **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;
     2                        ;**************************************************************************************************
     3                        ;DOS/65 C02 (CMOS) RAM Version
     4                        ;
     5                        ;This is Version 3.20 - 2nd April, 2023 - KM
     6                        ;This is the bootable image for a RAM loaded version of DOS/65 (CMOS version)
     7                        ;
     8                        ;**************************************************************************************************
     9                        ; Based on Richard A. Leary's DOS/65 V3 code - many thanks Richard!!
    10                        ; below is Richard's license text from his V3 ROM version.
    11                        ;
    12                        ; Note that CCM and PEM have undergone a major rewrite by Kevin E. Maier.
    13                        ; SIM is a fresh rewrite that interfaces directly to my C02BIOS and C02Monitor code.
    14                        ; I also make all of my code with the same GNU GPL license below.
    15                        ;
    16                        ; The DOS/65 V3 ROM software and all other DOS/65 software are free software;
    17                        ; you can redistribute it and/or modify it under the terms of the GNU General Public License as
    18                        ; published by the Free Software Foundation; either version 3 of the license, or any later version.
    19                        ; This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
    20                        ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    21                        ; See the GNU General Public License for more details.
    22                        ; You should have received a copy of the GNU General Public License along with this
    23                        ; program; if not, see <http://www.gnu.org/licenses/>.
    24                        ; CP/M is a trademark of Caldera.
    25                        ;
    26                        ;**************************************************************************************************
    27                        ; The target platform for this build is:
    28                        ;  A prototype 3.3-Volt system based on the C02 Pocket SBC - KM
    29                        ;  This prototype uses a NXP 28L92 DUART and a Hitachi MicroDrive PATA interface (IDE)
    30                        ;  The system has been modified for more RAM, now 56KB RAM and 8KB ROM (less I/O), 8MHz CPU
    31                        ;
    32                        ;**************************************************************************************************
    33                        ; Assembler directives
    34                        ;
    35                                        PW      132
    36                                        PL      66
    37                                        CHIP    W65C02S ;Enable WDC 65C02 instructions
    38                                        GLOBALS ON
    39                                        CASE    OFF
    40                                        INCLIST ON
    41                        ;
    42                        ;**************************************************************************************************
    43                        ;
    44                        ; This version uses CMOS instructions and addressing modes!
    45                        ;
    46                        ; There are multiple modules that make up this bootable version and use "include" to
    47                        ; add them into the main code. The Code Modules are:
    48                        ;       DOS65-MAIN-V320.ASM (This file)
    49                        ;       DOS65-CCM-V320.ASM - Concurrent Command Module
    50                        ;       DOS65-PEM-V320.ASM - Primitive Execution Module
    51                        ;       DOS65-SIM-V320.ASM - System Interface Module
    52                        ;
    53                        ; Other files required contain system variables and constants for C02BIOS and C02Monitor,
    54                        ; which are included in the SIM source module.
    55                        ;       C02Constants.asm - C02 BIOS/Monitor constants file
    56                        ;       C02JMP_Table.asm - C02 BIOS/Monitor JMP table for routines
    57                        ;
  Mon Apr  3 2023 10:57                                                                                                    Page 2


    58                        ;  The current BIOS and Monitor versions for the Prototype system are 4.02
    59                        ;
    60                        ;**************************************************************************************************
    61                        ;
    62                        ;               18 February 2023 - KM
    63                        ;Major revision! This is an entirely RAM based version of DOS/65
    64                        ;
    65                        ; Based on my 3.04 CMOS ROM Version
    66                        ; - All data areas are included in the linked modules
    67                        ; - Allocation Maps for 8 drives are zeroed and adds 4KB to the 6KB of DOS/65 code
    68                        ; - Supports 8- 8MB drives configured on the Microdrive.
    69                        ;
    70                        ; ALL modules (CCM, PEM, SIM) have been reworked for RAM base and include data areas.
    71                        ; - Page Zero usage has been reduced - currently, 8 bytes are used.
    72                        ;
    73                        ; Major updates to this version:
    74                        ; - Traditional Track/Sector call structure has been eliminated!
    75                        ; - All calls for disk drives are at a 128-byte record level.
    76                        ; - PEM has been changed to only make calls for record numbers.
    77                        ; - SIM has been re-written to accept record numbers and perform blocking/de-blocking for LBAs.
    78                        ; - All checksum code has been removed from PEM, no longer needed with IDE block devices.
    79                        ; - Drive range (A-H) is managed with an invalid drive message shown for invalid drives.
    80                        ; - DCB structure has changed: track/sector to record based and no checksum table (now 11 bytes).
    81                        ;
    82                        ;               02 April 2023 - KM
    83                        ; Update to SIM for this version:
    84                        ; - Record Writes are now more efficient with proper blocking to the 512-byte block size of the
    85                        ;   physical media being used. This provides a significant performance advantage.
    86                        ; - PEM has been updated to remove the rest of the code associated with diskette based media.
    87                        ;
    88                        ;**************************************************************************************************
    89                        ;
    90                        ;Base addresses and definitions
    91             00000098   pzstrt          .EQU    $98             ;start of page zero system RAM
    92             00000100   btejmp          .EQU    $100            ;warm boot jump
    93             00000103   pemjmp          .EQU    $103            ;jump to PEM
    94             00000106   iostat          .EQU    $106            ;I/O status
    95             00000107   dflfcb          .EQU    $107            ;default FCB
    96             00000128   dflbuf          .EQU    $128            ;default buffer
    97             00000800   tea             .EQU    $800            ;TEA start
    98                        ;
    99                        ;C02 Pocket SBC memory parameters - 3.3V prototype
   100                        ; NOTE: The ramstrt should be changed to $B800!
   101                        ; this provides a TEA area from $0800 to $B7FF, which is 44KB
   102                        ;
   103             0000B800   ramstrt         .EQU    $B800           ;RAM location assembly
   104             00000600   hstbuf          .EQU    $0600           ;IDE host buffer
   105                        ;
   106                        ;Fixed parameters
   107             0000000A   lf              .EQU    $0A             ;linefeeed
   108             0000000D   cr              .EQU    $0D             ;return
   109             0000001A   eof             .EQU    $1A             ;end of file
   110             00000000   null            .EQU    0               ;null
   111             00000003   ctlc            .EQU    3               ;abort
   112             00000005   ctle            .EQU    5               ;physical cr lf
   113             00000009   ctli            .EQU    9               ;tab character
   114             00000010   ctlp            .EQU    $10             ;toggle printer
   115             00000012   ctlr            .EQU    $12             ;repeat line
   116             00000013   ctls            .EQU    $13             ;freeze
   117             00000018   ctlx            .EQU    $18             ;cancel
   118             0000003B   semico          .EQU    $3B             ;semicolon
   119             0000007F   delete          .EQU    $7F             ;delete character
   120             00000025   numcmd          .EQU    37              ;number of PEM commands
  Mon Apr  3 2023 10:57                                                                                                    Page 3


   121             00000006   numvar          .EQU    6               ;number of page zero variable for switch
   122             00000008   maxdrv          .EQU    8               ;maximum number of drives suppported
   123                        ;
   124                        ;Page Zero use
   125                                        PAGE0
   126                        ;CCM / PEM
   127             00000098   addinp          .EQU    pzstrt          ;initialized to a,y
   128             0000009A   bufadd          .EQU    addinp+2        ;buffer address
   129             0000009C   alcpnt          .EQU    bufadd+2        ;allocation map pointer
   130                        ;
   131             0000009E   d65flg          .EQU    alcpnt+2        ;DOS/65 flag for CCM/PEM usage
   132                                                                ;bit 7 used for blmode flag in PEM
   133                                                                ;bit 6 used for exrwfl flag in PEM
   134                                                                ;bit 5 used for drvflg flag in PEM
   135                                                                ;bit 4 used for outflg flag in PEM
   136                                                                ;bits 3,2,1 unused
   137                                                                ;bit 0 used for submit flag in CCM
   138                        ;
   139                        ;SIM
   140             0000009F   sim_recflg      .EQU    d65flg+1        ;Disk I/O status flag for SIM
   141                                                                ;bit 7 used for valid LBA
   142                                                                ;bit 6 used for dirty block
   143                                                                ;bit 5 used for read operation
   144                                                                ;bit 4 used for write operation
   145                                                                ;bits 3,2 unused
   146                                                                ;bits 1,0 used for record offset
   147                        ;
   148                                        ENDS
   149                        ;
   150                        ;**************************************************************************************************
   151                        ;
   152                        ; Main program code starts here:
   153                                        .ORG     ramstrt
   154                        ;
   155                        LOAD_HEADER
   156                        ;Below is the Load Header required by the BOOT BLOCK!
   157                        ; it contains details required to complete the loading and
   158                        ; and configuration of the Boot Image before execution.
   159                        ; The load header is a 16-byte field located at the start of
   160                        ; the Boot Image file. It is structured as:
   161                        ;
   162                        ; - The 16-bit address to start loading the Boot Image.
   163                        ; - The 16-bit address to start the Boot Image (BOOT code jumps to this).
   164                        ; - The 16-bit address for loading the offset to the start of disk data.
   165                        ; - A long word for the size of the required disk data (for assigned drives).
   166                        ; - A 5 character string ID to validate the Boot Image.
   167                        ; - A 1 byte checksum to verify the header itself.
   168                        ;
   169                        ;Note that this is not yet being used...
   170                        ; this will be used when the boot record setup is finalized.
   171                        ; timing is everything... and the timing for this part is not yet.
   172                        ;
   173 00:B800: 00 B8                .DW     ramstrt         ;Address to load Boot Image
   174 00:B802: 00 CC                .DW     simram          ;Cold Start location for SIM
   175 00:B804: A4 CE                .DW     part_offset     ;Location to copy LBA offset
   176 00:B806: 00 00 02 00          .LONG   131072          ;64MB for 8-drives (at 8MB each)
   177                        ;
   178                        string_id
   179 00:B80A: 64 6F 73 36          .DB     "dos65"         ;ID string to validate Boot image
       00:B80E: 35 
   180                        ;
   181 00:B80F: 76                   .DB     #$76            ;checksum (must be manually calculated/entered)
   182                        ;
  Mon Apr  3 2023 10:57                                                                                                    Page 4


   183                        ;**************************************************************************************************
   184                        ;
   185                                include         DOS65-CCM-V320.ASM      ;Include CCM Module
     1                        ;
     2                        ;-------------------------------
     3                        ;DOS/65 Console Command Module
     4                        ;-------------------------------
     5                        ;CCM unique definitions
     6             00000008   nbuilt  equ     8               ;number built in commands
     7             00000004   dirpln  equ     4               ;number dir listings per line
     8                        ;
     9                        ccmram
    10                        ;
    11                        ;entry point
    12 00:B810: 80 26                bra     CCMStr          ;branch to start
    13                        ;
    14                        ;$$$.sub related subroutines
    15                        ;prepare drive A and FCB pointer for $$$.sub operation
    16 00:B812: AD D3 C0     PrpSUB  lda     dfldsk          ;get default drive
    17 00:B815: 8D D5 C0             sta     dsksav          ;save it
    18 00:B818: 9C D3 C0             stz     dfldsk          ;set default to A
    19 00:B81B: 20 B6 BC             jsr     slctds          ;and select A
    20                        ;set up submit FCB pointer
    21 00:B81E: A9 AE        setsub  lda     #<subfcb        ;low byte address
    22 00:B820: A0 C0                ldy     #>subfcb        ;high byte address
    23 00:B822: 60                   rts                     ;return to caller
    24                        ;recover disk assignments after $$$.sub ops
    25 00:B823: AD D5 C0     RcvDsk  lda     dsksav          ;get saved drive,
    26 00:B826: 8D D3 C0             sta     dfldsk          ;make it default,
    27 00:B829: 4C B6 BC             jmp     slctds          ;and select it
    28                        ;delete $$$.SUB file and clear flag
    29 00:B82C: 20 1E B8     delsub  jsr     setsub          ;set up .SUB FCB address
    30 00:B82F: 20 CD BC             jsr     dltfil          ;and delete the $$$.SUB file
    31 00:B832: 20 23 B8             jsr     rcvdsk          ;restore drives
    32 00:B835: 07 9E                rmb0    d65flg          ;clear submit flag
    33 00:B837: 60                   rts                     ;return to caller
    34                        ;
    35                        ;main program
    36 00:B838: D8           CCMStr  cld                     ;ensure binary mode
    37 00:B839: AD 06 01             lda     iostat          ;else get drive and user numbers
    38 00:B83C: 4A                   lsr     a               ;move user to low nibble
    39 00:B83D: 4A                   lsr     a
    40 00:B83E: 4A                   lsr     a
    41 00:B83F: 4A                   lsr     a
    42 00:B840: 20 B5 BB             jsr     setusr          ;tell PEM user number
    43 00:B843: AD 06 01             lda     iostat          ;get data again
    44 00:B846: 29 07                and     #%00000111      ;mask for drive only
    45 00:B848: 8D D3 C0             sta     dfldsk          ;save it
    46 00:B84B: 20 B6 BC             jsr     slctds          ;select drive
    47 00:B84E: A9 28                lda     #<DflBuf        ;set default buffer
    48 00:B850: A0 01                ldy     #>DflBuf        ;address
    49 00:B852: 20 E5 BC             jsr     setbuf          ;and set it,
    50 00:B855: 20 B2 BC             jsr     rstdsk          ;then reset the disk system
    51                        ;now see if $$$.sub file on A
    52 00:B858: 07 9E                rmb0    d65flg          ;clear submit flag
    53 00:B85A: 20 12 B8             jsr     prpsub          ;get ready for $$$.sub
    54 00:B85D: 20 C2 BC             jsr     srchfr          ;search for file
    55                        ;if $$$.sub file present set subflg to use file
    56 00:B860: 30 04                bmi     nosub           ;flag ok if a=255
    57 00:B862: 87 9E                smb0    d65flg          ;set submit flag
    58 00:B864: 80 03                bra     ccmlpe          ;and go to main loop
    59 00:B866: 20 23 B8     nosub   jsr     rcvdsk          ;return to original default
    60 00:B869: A2 FF        ccmlpe  ldx     #$ff            ;set
  Mon Apr  3 2023 10:57                                                                                                    Page 5


    61 00:B86B: 9A                   txs                     ;stack
    62 00:B86C: A9 28                lda     #<DflBuf        ;get default buffer
    63 00:B86E: A0 01                ldy     #>DflBuf        ;address
    64 00:B870: 20 E5 BC             jsr     setbuf          ;and set it
    65 00:B873: 20 19 BD             jsr     hdrout          ;send header
    66 00:B876: A9 3E                lda     #'>'            ;then print
    67 00:B878: 20 A2 BC             jsr     chrout          ;prompt
    68                        ;at this point we check flag for use of $$$.SUB file
    69 00:B87B: 8F 9E 02             bbs0    d65flg,L01      ;test submit flag, branch if set
    70 00:B87E: 80 57                bra     usecns          ;else clear use console
    71                        ;we must use $$$.SUB file
    72 00:B880: 20 1E B8     L01     jsr     setsub          ;get FCB pointer
    73 00:B883: 20 BA BC             jsr     openfl          ;try to open
    74 00:B886: 10 05                bpl     L02             ;use if OK
    75 00:B888: 20 2C B8             jsr     delsub          ;get rid of file
    76 00:B88B: 80 4A                bra     usecns          ;use console if no open
    77 00:B88D: AE BD C0     L02     ldx     subrc           ;get record count
    78 00:B890: CA                   dex
    79 00:B891: 8E CE C0             stx     subcr           ;and read last record
    80 00:B894: 20 1E B8             jsr     setsub          ;get ready for sub
    81 00:B897: 20 D1 BC             jsr     rdrcrd          ;read record
    82 00:B89A: F0 05                beq     L03             ;if OK get data
    83 00:B89C: 20 2C B8             jsr     delsub          ;else clean up from EOF
    84 00:B89F: 80 36                bra     usecns          ;and use console
    85                        ;read was OK so move record to command buffer
    86 00:B8A1: A2 00        L03     ldx     #0
    87 00:B8A3: BD 28 01     movsub  lda     dflbuf,x        ;get char
    88 00:B8A6: 9D 0C C0             sta     cnslng,x        ;move it
    89 00:B8A9: E8                   inx                     ;bump index
    90 00:B8AA: 10 F7                bpl     movsub          ;loop until index is 128
    91                        ;now delete record
    92 00:B8AC: CE BD C0             dec     subrc           ;drop number records by one
    93 00:B8AF: 20 1E B8             jsr     setsub          ;get ready for sub
    94 00:B8B2: 20 BE BC             jsr     clsefl
    95 00:B8B5: 10 05                bpl     typbuf          ;if OK go type line
    96 00:B8B7: 20 2C B8             jsr     delsub          ;then delete $$$.SUB
    97 00:B8BA: 80 1B                bra     usecns          ;switch to console if bad
    98                        ;send command line to console
    99 00:B8BC: A2 00        typbuf  ldx     #0              ;start one past length
   100 00:B8BE: BD 0D C0     print0  lda     cnstxt,x        ;get char
   101 00:B8C1: F0 06                beq     gotend          ;done if zero
   102 00:B8C3: 20 38 BD             jsr     cotsxy          ;save x and send to console
   103 00:B8C6: E8                   inx
   104 00:B8C7: 10 F5                bpl     print0          ;do next
   105 00:B8C9: 20 AE BC     gotend  jsr     chkcst          ;check for key pressed
   106 00:B8CC: F0 10                beq     nobrak          ;no break if no key
   107 00:B8CE: 20 A6 BC             jsr     cnsrdx          ;get key without echo
   108 00:B8D1: 20 2C B8             jsr     delsub          ;stop $$$.SUB use
   109 00:B8D4: 4C 38 B8             jmp     CCMStr          ;and go back to start
   110                        ;next line is the entry that stops $$$.SUB processing
   111 00:B8D7: A9 0B        usecns  lda     #<cnsbuf        ;point to start
   112 00:B8D9: A0 C0                ldy     #>cnsbuf        ;of buffer
   113 00:B8DB: 20 AA BC             jsr     rdebuf          ;do buffer read
   114                        ;next line is the entry point from $$$.SUB read
   115 00:B8DE: A0 00        nobrak  ldy     #0              ;clear index
   116 00:B8E0: AE 0C C0             ldx     cnslng          ;get length
   117 00:B8E3: D0 02                bne     lwrupr          ;continue
   118 00:B8E5: 80 71                bra     ccmlp2          ;loop if empty
   119 00:B8E7: B9 0D C0     lwrupr  lda     cnstxt,y        ;else get char
   120 00:B8EA: C9 61                cmp     #'a'            ;if less than a
   121 00:B8EC: 90 09                bcc     nxtchg          ;skip convert
   122 00:B8EE: C9 7B                cmp     #'z'+1          ;if over z
   123 00:B8F0: B0 05                bcs     nxtchg          ;skip convert
  Mon Apr  3 2023 10:57                                                                                                    Page 6


   124 00:B8F2: 29 5F                and     #%01011111      ;else convert
   125 00:B8F4: 99 0D C0             sta     cnstxt,y        ;put back in buffer
   126 00:B8F7: C8           nxtchg  iny                     ;bump index
   127 00:B8F8: CA                   dex                     ;count down
   128 00:B8F9: D0 EC                bne     lwrupr          ;loop if more
   129 00:B8FB: 8A                   txa                     ;set a to zero
   130 00:B8FC: 99 0D C0             sta     cnstxt,y        ;insert stopper
   131 00:B8FF: 8D D2 C0             sta     cnbfpt          ;initialize pointer
   132 00:B902: 20 72 BE     mrecmd  jsr     stdflb          ;set default buffer
   133 00:B905: 20 E1 BC             jsr     intdsk          ;get drive number
   134 00:B908: 8D D3 C0             sta     dfldsk          ;store as default
   135 00:B90B: 20 69 BD             jsr     prslin          ;parse command
   136 00:B90E: D0 4E                bne     cmderr          ;error if afn
   137 00:B910: AD D4 C0             lda     tmpdsk          ;get temporary
   138 00:B913: F0 04                beq     nodrch          ;if zero ok
   139 00:B915: A9 10                lda     #nbuilt*2       ;else set and
   140 00:B917: 80 2A                bra     dotrns          ;do transient
   141 00:B919: A2 00        nodrch  ldx     #0              ;zero table index
   142 00:B91B: 9C D6 C0             stz     count           ;and clear count
   143 00:B91E: A0 01        tsnxfn  ldy     #1              ;set fcb index
   144 00:B920: BD E0 BF     tsnxch  lda     fnctbl,x        ;get table entry
   145 00:B923: F0 1A                beq     gotcmd          ;if zero got it
   146 00:B925: D9 8D C0             cmp     fcbone,y        ;else test
   147 00:B928: D0 04                bne     nocmpr          ;no good if not =
   148 00:B92A: E8                   inx                     ;bump
   149 00:B92B: C8                   iny                     ;pointers
   150 00:B92C: D0 F2                bne     tsnxch          ;and loop
   151 00:B92E: E8           nocmpr  inx                     ;go to end
   152 00:B92F: BD E0 BF             lda     fnctbl,x        ;of table
   153 00:B932: D0 FA                bne     nocmpr          ;entry
   154 00:B934: E8                   inx                     ;point to next
   155 00:B935: EE D6 C0             inc     count           ;bump count
   156 00:B938: AD D6 C0             lda     count           ;and if not
   157 00:B93B: C9 08                cmp     #nbuilt         ;limit then
   158 00:B93D: D0 DF                bne     tsnxfn          ;try next
   159 00:B93F: AD D6 C0     gotcmd  lda     count           ;get count
   160 00:B942: 0A                   asl     a               ;multiply by two
   161 00:B943: AA           dotrns  tax                     ;use as index
   162 00:B944: 20 5B B9             jsr     ccm_cmd         ;call execute command
   163 00:B947: 20 EA BC     extcmd  jsr     rstddr          ;restore default
   164 00:B94A: 20 69 BD     extwod  jsr     prslin          ;parse more
   165 00:B94D: AD 8E C0             lda     fcbone+1        ;if first
   166 00:B950: 38                   sec                     ;character
   167 00:B951: E9 20                sbc     #' '            ;not a space
   168 00:B953: 0D D4 C0             ora     tmpdsk          ;or if temporary
   169 00:B956: D0 06                bne     cmderr          ;then an error
   170 00:B958: 4C 69 B8     ccmlp2  jmp     ccmlpe          ;else loop
   171 00:B95B: 7C 54 BF     ccm_cmd jmp     (xqfntb,x)      ;execute command
   172                        ;
   173                        ;command error syntax handler
   174 00:B95E: 20 93 BC     cmderr  jsr     ccrlf           ;do a cr lf
   175 00:B961: AC D7 C0             ldy     curpnt          ;get command pointer
   176 00:B964: B9 0D C0     cmerlp  lda     cnstxt,y        ;get char
   177 00:B967: F0 0A                beq     cmerex          ;if null then done
   178 00:B969: C9 20                cmp     #' '            ;if space
   179 00:B96B: F0 06                beq     cmerex          ;then done
   180 00:B96D: 20 38 BD             jsr     cotsxy          ;output with save
   181 00:B970: C8                   iny                     ;point to next
   182 00:B971: D0 F1                bne     cmerlp          ;and loop
   183 00:B973: A9 3F        cmerex  lda     #'?'            ;send a
   184 00:B975: 20 A2 BC             jsr     chrout          ;question mark
   185 00:B978: 80 DE                bra     ccmlp2          ;and start over
   186                        ;
  Mon Apr  3 2023 10:57                                                                                                    Page 7


   187                        ;execute dir command
   188                        ; dir <afn>
   189 00:B97A: 20 69 BD     dir     jsr     prslin          ;find object file
   190 00:B97D: 20 79 BE             jsr     clrslt          ;clear auto and select
   191 00:B980: A9 20                lda     #' '            ;if name
   192 00:B982: CD 8E C0             cmp     fcbone+1        ;and
   193 00:B985: D0 0F                bne     findfr          ;type are
   194 00:B987: CD 96 C0             cmp     fcbone+9        ;not empty
   195 00:B98A: D0 0A                bne     findfr          ;then use it
   196 00:B98C: A9 3F                lda     #'?'            ;else
   197 00:B98E: A0 0B                ldy     #11             ;fill
   198 00:B990: 99 8D C0     fillqu  sta     fcbone,y        ;fcb
   199 00:B993: 88                   dey                     ;with
   200 00:B994: D0 FA                bne     fillqu          ;question marks
   201 00:B996: 20 0F BD     findfr  jsr     srchf1          ;search for first match
   202 00:B999: 30 53                bmi     notfnd          ;error if none
   203 00:B99B: A9 04        fnddir  lda     #dirpln         ;set across
   204 00:B99D: 8D DF C0             sta     across          ;to entries per line
   205 00:B9A0: 20 93 BC             jsr     ccrlf           ;do a crlf
   206 00:B9A3: 20 1C BD     dirl    jsr     hdr             ;do header
   207 00:B9A6: A9 3A                lda     #':'            ;then a
   208 00:B9A8: 20 A2 BC             jsr     chrout          ;colon
   209 00:B9AB: AD D8 C0             lda     diradd          ;get number
   210 00:B9AE: 0A                   asl     a               ;and
   211 00:B9AF: 0A                   asl     a               ;multiply
   212 00:B9B0: 0A                   asl     a               ;by
   213 00:B9B1: 0A                   asl     a               ;thirty two
   214 00:B9B2: 0A                   asl     a               ;then
   215 00:B9B3: 29 60                and     #%01100000      ;mask out insignificant
   216 00:B9B5: A8                   tay                     ;make a pointer
   217 00:B9B6: C8                   iny                     ;and bump
   218 00:B9B7: A2 01                ldx     #1              ;set counter
   219 00:B9B9: B9 28 01     nmelpe  lda     dflbuf,y        ;get name
   220 00:B9BC: 20 38 BD             jsr     cotsxy          ;else send to console
   221 00:B9BF: C8           noname  iny                     ;bump index
   222 00:B9C0: E8                   inx                     ;and count
   223 00:B9C1: E0 0C                cpx     #12             ;if count is 12
   224 00:B9C3: F0 0B                beq     endnme          ;then done
   225 00:B9C5: E0 09                cpx     #9              ;or if not 9
   226 00:B9C7: D0 F0                bne     nmelpe          ;then loop
   227 00:B9C9: A9 2E                lda     #'.'            ;else send
   228 00:B9CB: 20 38 BD             jsr     cotsxy          ;a period
   229 00:B9CE: 80 E9                bra     nmelpe          ;and loop
   230 00:B9D0: 20 AE BC     endnme  jsr     chkcst          ;check console status
   231 00:B9D3: D0 18                bne     extdir          ;if key down quit
   232 00:B9D5: 20 5D BD             jsr     setone          ;else point to fcb
   233 00:B9D8: 20 C6 BC             jsr     srchnx          ;else search for next
   234 00:B9DB: 8D D8 C0             sta     diradd          ;save number
   235 00:B9DE: 30 0D                bmi     extdir          ;quit if not found
   236 00:B9E0: CE DF C0             dec     across          ;drop count
   237 00:B9E3: F0 B6                beq     fnddir          ;new line if 0
   238 00:B9E5: 20 A0 BC             jsr     spcout          ;send two spaces
   239 00:B9E8: 20 A0 BC             jsr     spcout          ; between names
   240 00:B9EB: 80 B6                bra     dirl            ;loop for more filenames
   241 00:B9ED: 60           extdir  rts                     ;else done
   242                        ;
   243                        ;not found error handler
   244 00:B9EE: A0 33        notfnd  ldy     #ntfnms         ;point to message
   245 00:B9F0: 80 5D                bra     remsg           ;send and exit
   246                        ;
   247                        ;execute ren command
   248                        ; ren <ufn> <ufn>
   249                        ;where first ufn is from name and second is to name
  Mon Apr  3 2023 10:57                                                                                                    Page 8


   250 00:B9F2: 20 69 BD     ren     jsr     prslin          ;get old name
   251 00:B9F5: D0 53                bne     renerr          ;error if afn
   252 00:B9F7: 20 62 BD             jsr     tmpold          ;save drive
   253 00:B9FA: 20 79 BE             jsr     clrslt          ;clear auto and select
   254 00:B9FD: 20 0F BD             jsr     srchf1          ;if file does not exist
   255 00:BA00: 30 4B                bmi     fntfnd          ;then branch for error
   256 00:BA02: 20 AA BE             jsr     frssec          ;move name to second half
   257 00:BA05: AC D2 C0             ldy     cnbfpt          ;get pointer
   258 00:BA08: B9 0D C0             lda     cnstxt,y        ;and then char
   259 00:BA0B: C9 20                cmp     #' '            ;if not a space
   260 00:BA0D: D0 38                bne     rensyn          ;then error
   261 00:BA0F: 20 69 BD             jsr     prslin          ;get new name
   262 00:BA12: D0 33                bne     rensyn          ;error if afn
   263 00:BA14: AD D4 C0             lda     tmpdsk          ;get new drive
   264 00:BA17: F0 10                beq     nonwdr          ;if zero ok
   265 00:BA19: CD DC C0             cmp     oldtmp          ;compare to old
   266 00:BA1C: F0 0B                beq     nonwdr          ;ok if same
   267 00:BA1E: 3A                   dec     a               ;subtract one ;-)
   268 00:BA1F: CD D3 C0             cmp     dfldsk          ;if not default
   269 00:BA22: D0 23                bne     rensyn          ;is error
   270 00:BA24: AD DC C0             lda     oldtmp          ;and then if from not
   271 00:BA27: D0 1E                bne     rensyn          ;default is error
   272 00:BA29: AD DC C0     nonwdr  lda     oldtmp          ;else get old
   273 00:BA2C: 8D D4 C0             sta     tmpdsk          ;and save
   274 00:BA2F: 9C 9D C0             stz     fcbone+16       ;clear fcb offset
   275 00:BA32: 20 79 BE             jsr     clrslt          ;reselect
   276 00:BA35: 20 0F BD             jsr     srchf1          ;search for old
   277 00:BA38: 10 09                bpl     filexs          ;error if found
   278 00:BA3A: 20 AA BE             jsr     frssec          ;swap names
   279 00:BA3D: 20 5D BD             jsr     setone          ;point to fcb
   280 00:BA40: 4C DD BC             jmp     renmfl          ;and do it
   281                        ;ren file exists error handler
   282 00:BA43: A0 3D        filexs  ldy     #flexms         ;point to
   283 00:BA45: 80 08                bra     remsg           ;and send
   284                        ;ren syntax error handler
   285 00:BA47: 20 EA BC     rensyn  jsr     rstddr          ;restore default
   286 00:BA4A: 4C 5E B9     renerr  jmp     cmderr          ;do error
   287                        ;ren source file not found error handler
   288 00:BA4D: A0 33        fntfnd  ldy     #ntfnms         ;point to
   289 00:BA4F: 4C 8A BE     remsg   jmp     sndmsg          ;and send
   290                        ;
   291                        ;execute save command
   292                        ; save <length> <drive:>ufn (<address>)
   293 00:BA52: A9 00        save    lda     #<tea           ;set start address to tea start
   294 00:BA54: A0 08                ldy     #>tea
   295 00:BA56: 8D E5 C0             sta     sadr
   296 00:BA59: 8C E6 C0             sty     sadr+1
   297 00:BA5C: 20 CF BE             jsr     bldnum          ;calculate length
   298 00:BA5F: D0 7A                bne     saverr          ;error if > 255 pages
   299 00:BA61: 8D DB C0             sta     length          ;else save low
   300 00:BA64: 0D DB C0             ora     length          ;test for zero length
   301 00:BA67: F0 72                beq     saverr          ;error if is
   302 00:BA69: 20 69 BD             jsr     prslin          ;get file name
   303 00:BA6C: D0 6D                bne     saverr          ;error if afn
   304 00:BA6E: 20 AA BE             jsr     frssec          ;move name to second half
   305 00:BA71: 20 62 BD             jsr     tmpold          ;save drive
   306 00:BA74: 20 CF BE             jsr     bldnum          ;it is so find value
   307 00:BA77: AE 8E C0             ldx     fcbone+1        ;see if there
   308 00:BA7A: E0 20                cpx     #' '
   309 00:BA7C: F0 0A                beq     nosadr          ;it is not
   310 00:BA7E: 8D E5 C0             sta     sadr            ;and set address
   311 00:BA81: 8C E6 C0             sty     sadr+1
   312 00:BA84: C0 02                cpy     #2              ;make sure is high enough
  Mon Apr  3 2023 10:57                                                                                                    Page 9


   313 00:BA86: 90 53                bcc     saverr          ;error if not
   314 00:BA88: 20 BD BE     nosadr  jsr     secfrs          ;move name back
   315 00:BA8B: 20 79 BE             jsr     clrslt          ;clear auto and select
   316 00:BA8E: 20 CA BC             jsr     dlt1            ;delete
   317 00:BA91: 20 5D BD             jsr     setone          ;then create
   318 00:BA94: 20 D9 BC             jsr     cratfl          ;new file
   319 00:BA97: 30 44                bmi     noroom          ;say no room if error
   320 00:BA99: 20 FD BC             jsr     open1           ;open file
   321 00:BA9C: 30 43                bmi     noopen          ;if error
   322 00:BA9E: 18                   clc                     ;now find end page
   323 00:BA9F: AD E6 C0             lda     sadr+1
   324 00:BAA2: 6D DB C0             adc     length
   325 00:BAA5: 8D DB C0             sta     length
   326 00:BAA8: AD E5 C0             lda     sadr            ;get start address
   327 00:BAAB: AC E6 C0             ldy     sadr+1
   328 00:BAAE: 8D DD C0     wrtmre  sta     dskbuf          ;set
   329 00:BAB1: 8C DE C0             sty     dskbuf+1        ;buffer
   330 00:BAB4: 20 6E CA             jsr     mv128           ;move data to buffer
   331 00:BAB7: 20 5D BD             jsr     setone          ;point to fcb
   332 00:BABA: 20 D5 BC             jsr     wrrcrd          ;write record
   333 00:BABD: D0 26                bne     wrterr          ;exit if error
   334 00:BABF: 18                   clc                     ;else
   335 00:BAC0: AD DD C0             lda     dskbuf          ;get old
   336 00:BAC3: AC DE C0             ldy     dskbuf+1        ;buffer
   337 00:BAC6: 69 80                adc     #128            ;add 128
   338 00:BAC8: 90 03                bcc     donotc          ;if carry
   339 00:BACA: C8                   iny                     ;bump upper
   340 00:BACB: F0 05                beq     clssav          ;done if page zero
   341 00:BACD: CC DB C0     donotc  cpy     length          ;loop if upper
   342 00:BAD0: D0 DC                bne     wrtmre          ;not at limit
   343 00:BAD2: 20 5D BD     clssav  jsr     setone          ;else point to
   344 00:BAD5: 20 BE BC             jsr     clsefl          ;and close file
   345 00:BAD8: 30 0F                bmi     cantcl          ;say so if error
   346 00:BADA: 60           extera  rts                     ;return to caller
   347                        ;save error handler
   348 00:BADB: 80 62        saverr  bra     typafn          ;do error
   349                        ;save no room error handler
   350 00:BADD: A0 00        noroom  ldy     #nospms         ;point to
   351 00:BADF: 80 67                bra     temsg           ;and send
   352                        ;save can not open error handler
   353 00:BAE1: A0 54        noopen  ldy     #cnnoms         ;point to
   354 00:BAE3: 80 63                bra     temsg           ;and send
   355                        ;save write error handler
   356 00:BAE5: A0 61        wrterr  ldy     #wrerms         ;point
   357 00:BAE7: 80 5F                bra     temsg           ;to and send
   358                        ;save can not close error
   359 00:BAE9: A0 09        cantcl  ldy     #ntclms         ;point to
   360 00:BAEB: 80 5B                bra     temsg           ;and send
   361                        ;
   362                        ;execute era command
   363                        ; era <afn>
   364 00:BAED: 20 69 BD     era     jsr     prslin          ;get file name
   365 00:BAF0: C9 0B                cmp     #11             ;if not all ?
   366 00:BAF2: D0 13                bne     nteral          ;then skip verify
   367 00:BAF4: A0 17                ldy     #alflms         ;else point to
   368 00:BAF6: 20 8A BE             jsr     sndmsg          ;and send all files
   369 00:BAF9: 20 9C BC             jsr     cnsrde          ;get an input
   370 00:BAFC: 48                   pha                     ;and save
   371 00:BAFD: 20 93 BC             jsr     ccrlf           ;do a cr lf
   372 00:BB00: 68                   pla                     ;restore char
   373 00:BB01: 29 5F                and     #$5f            ;convert to upper case
   374 00:BB03: C9 59                cmp     #'Y'            ;if not y
   375 00:BB05: D0 D3                bne     extera          ;then quit
  Mon Apr  3 2023 10:57                                                                                                    Page 10


   376 00:BB07: 20 79 BE     nteral  jsr     clrslt          ;clear auto and select
   377 00:BB0A: 4C CA BC             jmp     dlt1            ;delete first, return
   378                        ;
   379                        ;execute type command
   380                        ; type d:ufn
   381 00:BB0D: 20 69 BD     type    jsr     prslin          ;get file
   382 00:BB10: D0 2D                bne     typafn          ;error if afn
   383 00:BB12: 20 FA BC             jsr     casdo1          ;clear - select - open file 1
   384 00:BB15: 30 2F                bmi     notype          ;error if not found
   385 00:BB17: 20 93 BC             jsr     ccrlf           ;else do cr lf
   386 00:BB1A: 20 0A BD     typmre  jsr     read1           ;read record
   387 00:BB1D: F0 04                beq     okread          ;if ok continue
   388 00:BB1F: 10 B9                bpl     extera          ;exit if just end
   389 00:BB21: 30 1F                bmi     typerr          ;else error
   390 00:BB23: A2 00        okread  ldx     #0              ;clear index
   391 00:BB25: BD 28 01     typlpe  lda     dflbuf,x        ;get char
   392 00:BB28: C9 1A                cmp     #eof            ;if eof
   393 00:BB2A: F0 AE                beq     extera          ;then exit
   394 00:BB2C: 20 38 BD             jsr     cotsxy          ;else send
   395 00:BB2F: 20 AE BC             jsr     chkcst          ;if key down
   396 00:BB32: D0 08                bne     exttok          ;then exit
   397 00:BB34: AE D9 C0             ldx     savx            ;else get index
   398 00:BB37: E8                   inx                     ;bump it
   399 00:BB38: 10 EB                bpl     typlpe          ;and loop if < 128
   400 00:BB3A: 30 DE                bmi     typmre          ;else read more
   401 00:BB3C: 4C A6 BC     exttok  jmp     cnsrdx          ;clear console, no echo
   402                        ;type syntax error handler
   403 00:BB3F: 4C 5E B9     typafn  jmp     cmderr          ;error return
   404                        ;type read error handler
   405 00:BB42: A0 28        typerr  ldy     #rderms         ;point to
   406 00:BB44: 80 02                bra     temsg           ;and send
   407                        ;type not found error handler
   408 00:BB46: A0 33        notype  ldy     #ntfnms         ;point to
   409 00:BB48: 4C 8A BE     temsg   jmp     sndmsg          ;and send
   410                        ;
   411                        ;execute load command
   412                        ; load <ufn> (<address>)
   413 00:BB4B: 20 9F BE     load    jsr     setddb          ;set load start to tea start
   414 00:BB4E: 20 69 BD             jsr     prslin          ;build fcb
   415 00:BB51: D0 EC                bne     typafn          ;error if afn
   416 00:BB53: 20 AA BE             jsr     frssec          ;save in second half
   417 00:BB56: 20 62 BD             jsr     tmpold          ;save file
   418 00:BB59: 20 CF BE             jsr     bldnum          ;find start address
   419 00:BB5C: AE 8E C0             ldx     fcbone+1        ;see if number
   420 00:BB5F: E0 20                cpx     #' '
   421 00:BB61: F0 03                beq     usedfl          ;if none use default
   422 00:BB63: 20 A3 BE             jsr     setdb           ;and set
   423 00:BB66: 20 BD BE     usedfl  jsr     secfrs          ;move name back
   424 00:BB69: 20 FA BC             jsr     casdo1          ;clear - select - open file 1
   425 00:BB6C: 30 D8                bmi     notype          ;exit if not found
   426 00:BB6E: AD DD C0             lda     dskbuf          ;get load start
   427 00:BB71: AC DE C0             ldy     dskbuf+1
   428 00:BB74: 20 E5 BC     lcmdlp  jsr     setbuf          ;set as disk buffer
   429 00:BB77: 20 0A BD             jsr     read1           ;read record
   430 00:BB7A: D0 05                bne     loadnd          ;done if not zero
   431 00:BB7C: 20 5B CA             jsr     adjdb           ;bump address
   432 00:BB7F: 80 F3                bra     lcmdlp          ;and loop
   433 00:BB81: 30 BF        loadnd  bmi     typerr          ;if error say so
   434 00:BB83: 4C 72 BE             jmp     stdflb          ;back to default buffer
   435                        ;
   436                        ;execute GO command
   437                        ; go (<address>)
   438 00:BB86: 20 CF BE     go      jsr     bldnum          ;get address
  Mon Apr  3 2023 10:57                                                                                                    Page 11


   439 00:BB89: AE 8E C0             ldx     fcbone+1        ;get first char
   440 00:BB8C: E0 20                cpx     #' '            ;see if nothing
   441 00:BB8E: F0 03                beq     nolnum          ;nothing so use tea
   442 00:BB90: 4C 27 BC             jmp     godoit          ;then execute
   443 00:BB93: 4C 23 BC     nolnum  jmp     gotea
   444                        ;
   445                        ;execute USER command
   446                        ; user (<number>)
   447 00:BB96: 20 CF BE     user    jsr     bldnum          ;build number
   448 00:BB99: AE 8E C0             ldx     fcbone+1        ;get first character
   449 00:BB9C: E0 20                cpx     #' '            ;see if nothing
   450 00:BB9E: F0 0E                beq     usrext          ;done if nothing
   451 00:BBA0: AD E2 C0             lda     num+1           ;check high
   452 00:BBA3: D0 0A                bne     usrerr          ;error if too big
   453 00:BBA5: AD E1 C0             lda     num             ;get low
   454 00:BBA8: C9 10                cmp     #16             ;see if too big
   455 00:BBAA: B0 03                bcs     usrerr          ;error if is
   456 00:BBAC: 80 07                bra     setusr          ;set if 0-15
   457 00:BBAE: 60           usrext  rts                     ;return to caller
   458                        ;bad user number entered
   459 00:BBAF: A0 6D        usrerr  ldy     #userms         ;get error message
   460 00:BBB1: 80 95                bra     temsg
   461                        ;user code (usrcde) related routines
   462                        ;get user code from PEM
   463 00:BBB3: A9 FF        getusr  lda     #255            ;query parameter
   464                        ;set user code to A
   465 00:BBB5: A2 24        setusr  ldx     #36             ;37th function
   466 00:BBB7: 4C 03 01             jmp     pemjmp          ;execute
   467                        ;Save user code in A in case of action that may
   468                        ;destroy or alter it.
   469 00:BBBA: 20 B3 BB     savusr  jsr     getusr          ;get usrcde from PEM
   470 00:BBBD: 0A                   asl     a               ;shift code to high nibble
   471 00:BBBE: 0A                   asl     a
   472 00:BBBF: 0A                   asl     a
   473 00:BBC0: 0A                   asl     a
   474 00:BBC1: 0D D3 C0             ora     dfldsk          ;paste default disk into
   475 00:BBC4: 8D 06 01             sta     iostat          ;iostat and save
   476 00:BBC7: 60                   rts                     ;return to caller
   477                        ;
   478                        ;execute trns (transient) command
   479                        ; <ufn> (<fn>) (<fn>)
   480 00:BBC8: AD 8E C0     trns    lda     fcbone+1        ;get first char
   481 00:BBCB: C9 20                cmp     #' '            ;if not space
   482 00:BBCD: D0 0F                bne     chktyp          ;check type
   483 00:BBCF: AD D4 C0             lda     tmpdsk          ;else test temp
   484 00:BBD2: F0 07                beq     skpdrv          ;if none skip
   485 00:BBD4: 3A                   dec     a               ;subtract one ;-)
   486 00:BBD5: 8D D3 C0             sta     dfldsk          ;set default
   487 00:BBD8: 20 B6 BC             jsr     slctds          ;and select
   488 00:BBDB: 4C 4A B9     skpdrv  jmp     extwod          ;return
   489 00:BBDE: AD 96 C0     chktyp  lda     fcbone+9        ;get type
   490 00:BBE1: C9 20                cmp     #' '            ;if space
   491 00:BBE3: F0 03                beq     typemp          ;then ok
   492 00:BBE5: 4C 8B BC             jmp     trnerr          ;else error
   493 00:BBE8: A2 02        typemp  ldx     #2              ;make
   494 00:BBEA: BD CF C0     setcom  lda     typcom,x        ;type
   495 00:BBED: 9D 96 C0             sta     fcbone+9,x      ;com
   496 00:BBF0: CA                   dex                     ;then
   497 00:BBF1: 10 F7                bpl     setcom          ;continue
   498 00:BBF3: 20 FA BC             jsr     casdo1          ;clear - select - open file one
   499 00:BBF6: 10 03                bpl     gottrn          ;jump if ok
   500 00:BBF8: 4C 88 BC             jmp     topner          ;else do error
   501 00:BBFB: 20 9F BE     gottrn  jsr     setddb          ;set start to tea
  Mon Apr  3 2023 10:57                                                                                                    Page 12


   502 00:BBFE: 20 E5 BC     nxtrcr  jsr     setbuf          ;set address
   503 00:BC01: 20 0A BD             jsr     read1           ;read fcb 1
   504 00:BC04: D0 1B                bne     endlde          ;branch if error or eof
   505 00:BC06: 20 5B CA             jsr     adjdb           ;adjust address up by 128
   506 00:BC09: C9 10                cmp     #<ccmram        ;if new low
   507 00:BC0B: 90 06                bcc     tryhig          ;ok try high
   508 00:BC0D: C0 B8                cpy     #>ccmram        ;else if high
   509 00:BC0F: 90 ED                bcc     nxtrcr          ;ok do more
   510 00:BC11: B0 06                bcs     chklnd          ;else check for end
   511 00:BC13: C0 B8        tryhig  cpy     #>ccmram        ;if high less
   512 00:BC15: 90 E7                bcc     nxtrcr          ;then ok
   513 00:BC17: F0 E5                beq     nxtrcr          ;or ok if same
   514 00:BC19: 20 72 BE     chklnd  jsr     stdflb          ;set buffer to default
   515 00:BC1C: 20 0A BD             jsr     read1           ;read (should be eof)
   516 00:BC1F: F0 6D                beq     tlderr          ;error if more
   517 00:BC21: 30 6B        endlde  bmi     tlderr          ;do error
   518 00:BC23: A9 00        gotea   lda     #<tea           ;set go address to tea start
   519 00:BC25: A0 08                ldy     #>tea
   520 00:BC27: 8D 7D BC     godoit  sta     do+1            ;set to ay
   521 00:BC2A: 8C 7E BC             sty     do+2
   522 00:BC2D: 20 EA BC             jsr     rstddr          ;else restore default
   523 00:BC30: 20 69 BD             jsr     prslin          ;parse file
   524 00:BC33: AD D4 C0             lda     tmpdsk          ;set auto
   525 00:BC36: 8D 8D C0             sta     fcbone          ;select position
   526 00:BC39: A2 10                ldx     #16             ;do a second
   527 00:BC3B: 20 6B BD             jsr     prsmre          ;fcb if there
   528 00:BC3E: AD D4 C0             lda     tmpdsk          ;set auto select
   529 00:BC41: 8D 9D C0             sta     fcbone+16       ;again
   530 00:BC44: A0 00                ldy     #0              ;clear record
   531 00:BC46: 8C AD C0             sty     fcbone+32       ;counter
   532 00:BC49: A2 20                ldx     #32             ;move
   533 00:BC4B: BD 8D C0     movfcb  lda     fcbone,x        ;all
   534 00:BC4E: 9D 07 01             sta     dflfcb,x        ;to
   535 00:BC51: CA                   dex                     ;default
   536 00:BC52: 10 F7                bpl     movfcb          ;fcb
   537 00:BC54: E8                   inx                     ;set x to zero
   538 00:BC55: B9 0D C0     tstbuf  lda     cnstxt,y        ;get char
   539 00:BC58: F0 07                beq     isnull          ;if null jump
   540 00:BC5A: C9 20                cmp     #' '            ;or if space
   541 00:BC5C: F0 03                beq     isnull          ;jump
   542 00:BC5E: C8                   iny                     ;else bump pointer
   543 00:BC5F: D0 F4                bne     tstbuf          ;and loop
   544 00:BC61: 9C 28 01     isnull  stz     dflbuf          ;clear count
   545 00:BC64: B9 0D C0     movbuf  lda     cnstxt,y        ;get char
   546 00:BC67: 9D 29 01             sta     dflbuf+1,x      ;and move
   547 00:BC6A: F0 07                beq     fillov          ;exit if null
   548 00:BC6C: E8                   inx                     ;increment
   549 00:BC6D: C8                   iny                     ;counters
   550 00:BC6E: EE 28 01             inc     dflbuf          ;and length
   551 00:BC71: D0 F1                bne     movbuf          ;and loop
   552 00:BC73: 20 93 BC     fillov  jsr     ccrlf           ;do a cr lf
   553 00:BC76: 20 72 BE             jsr     stdflb          ;set default
   554 00:BC79: 20 BA BB             jsr     savusr          ;save user code
   555 00:BC7C: 20 00 08     do      jsr     tea             ;call execute jmp
   556 00:BC7F: AD D3 C0             lda     dfldsk          ;get default
   557 00:BC82: 20 B6 BC             jsr     slctds          ;and set
   558 00:BC85: 4C 69 B8             jmp     ccmlpe          ;then loop
   559                        ;trns syntax error handler
   560 00:BC88: 20 EA BC     topner  jsr     rstddr          ;restore default
   561 00:BC8B: 4C 5E B9     trnerr  jmp     cmderr          ;do error
   562                        ;trns load error
   563 00:BC8E: A0 49        tlderr  ldy     #lderms         ;point to
   564 00:BC90: 4C 8A BE             jmp     sndmsg          ;and send
  Mon Apr  3 2023 10:57                                                                                                    Page 13


   565                        ;
   566                        ;carriage return and linefeed
   567 00:BC93: A9 0D        ccrlf   lda     #cr             ;get a cr
   568 00:BC95: 20 A2 BC             jsr     chrout          ;send
   569 00:BC98: A9 0A                lda     #lf             ;get a lf
   570 00:BC9A: 80 06                bra     chrout          ;and send
   571                        ;
   572                        ;general PEM calls
   573 00:BC9C: A2 01        cnsrde  ldx     #1              ;console read
   574 00:BC9E: 80 47                bra     pemgo
   575 00:BCA0: A9 20        spcout  lda     #' '            ;output space
   576 00:BCA2: A2 02        chrout  ldx     #2              ;console output
   577 00:BCA4: 80 41                bra     pemgo
   578 00:BCA6: A2 06        cnsrdx  ldx     #6              ;console read without echo
   579 00:BCA8: 80 3D                bra     pemgo
   580 00:BCAA: A2 0A        rdebuf  ldx     #10             ;buffered input
   581 00:BCAC: 80 39                bra     pemgo
   582 00:BCAE: A2 0B        chkcst  ldx     #11             ;check console
   583 00:BCB0: 80 35                bra     pemgo
   584 00:BCB2: A2 0D        rstdsk  ldx     #13             ;initialize system
   585 00:BCB4: 80 31                bra     pemgo
   586 00:BCB6: A2 0E        slctds  ldx     #14             ;select drive
   587 00:BCB8: 80 2D                bra     pemgo
   588 00:BCBA: A2 0F        openfl  ldx     #15             ;open file
   589 00:BCBC: 80 29                bra     pemgo
   590 00:BCBE: A2 10        clsefl  ldx     #16             ;close file
   591 00:BCC0: 80 25                bra     pemgo
   592 00:BCC2: A2 11        srchfr  ldx     #17             ;first match
   593 00:BCC4: 80 21                bra     pemgo
   594 00:BCC6: A2 12        srchnx  ldx     #18             ;next match
   595 00:BCC8: 80 1D                bra     pemgo
   596                        ;delete file one
   597 00:BCCA: 20 5D BD     dlt1    jsr     setone          ;point to fcb
   598 00:BCCD: A2 13        dltfil  ldx     #19             ;delete file
   599 00:BCCF: 80 16                bra     pemgo
   600 00:BCD1: A2 14        rdrcrd  ldx     #20             ;read record
   601 00:BCD3: 80 12                bra     pemgo
   602 00:BCD5: A2 15        wrrcrd  ldx     #21             ;write record
   603 00:BCD7: 80 0E                bra     pemgo
   604 00:BCD9: A2 16        cratfl  ldx     #22             ;create file
   605 00:BCDB: 80 0A                bra     pemgo
   606 00:BCDD: A2 17        renmfl  ldx     #23             ;rename file
   607 00:BCDF: 80 06                bra     pemgo
   608 00:BCE1: A2 19        intdsk  ldx     #25             ;read drive num
   609 00:BCE3: 80 02                bra     pemgo
   610 00:BCE5: A2 1A        setbuf  ldx     #26             ;set buffer add
   611 00:BCE7: 4C 03 01     pemgo   jmp     pemjmp          ;go to pem
   612                        ;
   613                        ;restore default drive
   614 00:BCEA: AD D4 C0     rstddr  lda     tmpdsk          ;get temp drive,
   615 00:BCED: F0 1A                beq     extddr          ;if zero, exit
   616 00:BCEF: 3A                   dec     a               ;else, subtract one
   617 00:BCF0: CD D3 C0             cmp     dfldsk          ;compare to default
   618 00:BCF3: F0 14                beq     extddr          ;exit if same
   619 00:BCF5: AD D3 C0     seldfl  lda     dfldsk          ;else, get default
   620 00:BCF8: 80 BC                bra     slctds          ;and select
   621                        ;
   622                        ;clear auto - select disk - open file at fcbone
   623 00:BCFA: 20 79 BE     casdo1  jsr     clrslt          ;clear auto and select
   624                        ;open file one
   625                        ; returns:n=1 if not found
   626 00:BCFD: 9C AD C0     open1   stz     fcbone+32       ;clear record number
   627 00:BD00: 20 5D BD             jsr     setone          ;point to fcb
  Mon Apr  3 2023 10:57                                                                                                    Page 14


   628 00:BD03: 20 BA BC             jsr     openfl          ;open it
   629 00:BD06: 8D D8 C0             sta     diradd          ;save number
   630 00:BD09: 60           extddr  rts                     ;return to caller
   631                        ;read file one
   632 00:BD0A: 20 5D BD     read1   jsr     setone          ;point to fcb
   633 00:BD0D: 80 C2                bra     rdrcrd          ;do read
   634                        ;search for first file one
   635                        ; returns:n=1 if not found
   636 00:BD0F: 20 5D BD     srchf1  jsr     setone          ;point to fcb
   637 00:BD12: 20 C2 BC             jsr     srchfr          ;search for first
   638 00:BD15: 8D D8 C0             sta     diradd          ;save number
   639 00:BD18: 60                   rts                     ;return to caller
   640                        ;header output
   641 00:BD19: 20 93 BC     hdrout  jsr     ccrlf           ;do cr lf
   642 00:BD1C: 20 E1 BC     hdr     jsr     intdsk          ;get drive number
   643 00:BD1F: 18                   clc                     ;add "A" to make it
   644 00:BD20: 69 41                adc     #'A'            ;a drive letter
   645 00:BD22: 20 38 BD             jsr     cotsxy          ;send drive letter
   646                        ;drive letter is written now do user number
   647 00:BD25: 20 B3 BB             jsr     getusr          ;get user number
   648 00:BD28: C9 0A                cmp     #10             ;see if < 10
   649 00:BD2A: 90 0A                bcc     usr09           ;if so use as is
   650 00:BD2C: 48                   pha                     ;else, save number,
   651 00:BD2D: A9 31                lda     #'1'            ;send an ASCII 1
   652 00:BD2F: 20 38 BD             jsr     cotsxy          ;to the console
   653 00:BD32: 68                   pla                     ;get user number back
   654 00:BD33: 38                   sec                     ;subtract 10,
   655 00:BD34: E9 0A                sbc     #10             ;then get remainder
   656 00:BD36: 09 30        usr09   ora     #'0'            ;convert to ASCII
   657                        ;
   658                        ;drop in to cotsxy
   659                        ;
   660                        ;output with save of x and y
   661                        ;this routine calls the pem resident routine
   662                        ;tstchr to see if a char is a printing char.
   663                        ;if it is then c=1 upon return from tstchr.
   664 00:BD38: 8E D9 C0     cotsxy  stx     savx            ;save x
   665 00:BD3B: 8C DA C0             sty     savy            ;and y
   666 00:BD3E: 20 82 C8             jsr     tstchr          ;see if printing
   667 00:BD41: B0 10                bcs     isprnt          ;jump if is
   668 00:BD43: 48                   pha                     ;else save
   669 00:BD44: AD 3B CC             lda     sysdef+4        ;get invert
   670 00:BD47: 20 A2 BC             jsr     chrout          ;send it
   671 00:BD4A: 68                   pla                     ;get char
   672 00:BD4B: 09 40                ora     #'@'            ;make printing
   673 00:BD4D: 20 A2 BC             jsr     chrout          ;send it
   674 00:BD50: AD 3A CC             lda     sysdef+3        ;get normal
   675 00:BD53: 20 A2 BC     isprnt  jsr     chrout          ;do output
   676 00:BD56: AC DA C0             ldy     savy            ;get y
   677 00:BD59: AE D9 C0             ldx     savx            ;and x
   678 00:BD5C: 60                   rts                     ;return to caller
   679                        ;
   680                        ;set up fcb one pointer
   681 00:BD5D: A9 8D        setone  lda     #<fcbone        ;low
   682 00:BD5F: A0 C0                ldy     #>fcbone        ;and high
   683 00:BD61: 60                   rts                     ;return to caller
   684                        ;
   685                        ;save tmpdsk in oldtmp
   686 00:BD62: AD D4 C0     tmpold  lda     tmpdsk
   687 00:BD65: 8D DC C0             sta     oldtmp
   688 00:BD68: 60                   rts                     ;return to caller
   689                        ;
   690                        ;parse command line
  Mon Apr  3 2023 10:57                                                                                                    Page 15


   691 00:BD69: A2 00        prslin  ldx     #0              ;clear index
   692 00:BD6B: DA           prsmre  phx                     ;save index
   693 00:BD6C: 9C D4 C0             stz     tmpdsk          ;clear temp drive flag
   694 00:BD6F: AC D2 C0             ldy     cnbfpt          ;get buffer pointer
   695 00:BD72: 20 40 BE             jsr     skpspc          ;find first non-space
   696 00:BD75: 8C D7 C0             sty     curpnt          ;save index
   697 00:BD78: F0 0D                beq     nulchr          ;branch if null
   698                        ;
   699                        ;The "and" instruction below is to strip off ascii bits that are drive letter related!
   700                        ; by doing so, A - H becomes %0001 - %1000 (1-8), which can be a real problem...
   701                        ; if the next character is a semicolon (:). that 4-bit masked value becomes the
   702                        ; TMPDSK variable, which is spliced into the FCB and becomes the selected drive.
   703                        ; As a result, any ascii character can be entered and you wind up with a list of
   704                        ; phantom drive letters, depending on what was entered, alpha or not.
   705                        ;
   706                        ; The fix here is to mask off the lower 7 bits for true ascii, then let this
   707                        ; routine below starting at "drvinp" complete the check for a valid drive letter.
   708                        ;
   709 00:BD7A: 29 7F                and     #%01111111      ;strip off bit 7 for ascii only
   710 00:BD7C: 48                   pha                     ;and save to stack
   711 00:BD7D: C8                   iny                     ;point to next char
   712 00:BD7E: B9 0D C0             lda     cnstxt,y        ;and get it
   713 00:BD81: C9 3A                cmp     #':'            ;if it's a colon
   714 00:BD83: F0 0A                beq     drvinp          ;branch and set drive
   715 00:BD85: 68                   pla                     ;else clear stack
   716 00:BD86: 88                   dey                     ;backup the index
   717 00:BD87: AD D3 C0     nulchr  lda     dfldsk          ;set automatic
   718 00:BD8A: 9D 8D C0             sta     fcbone,x        ;to default drive
   719 00:BD8D: 80 1A                bra     trynme          ;then branch to parse name
   720                        ;
   721                        ;at this stage, we get the ascii character back from the stack, which is the
   722                        ; assumed drive letter. Now we need to range check this and ensure it's within
   723                        ; the range of a-z or A-Z. First, we'll convert lower case to upper case, then
   724                        ; check for the proper range. If the character is outside of the range, we can
   725                        ; simply set it for the acceptable range plus one. This will be caught by the
   726                        ; PEM routine and flagged as a drive out of range.
   727                        ;
   728 00:BD8F: 68           drvinp  pla                     ;get the "drive letter" back
   729 00:BD90: C9 61                cmp     #$61            ;check for lower case ascii/control characters
   730 00:BD92: 90 02                bcc     ucok            ;if lower, upper case is okay
   731 00:BD94: E9 20                sbc     #$20            ;else subtract $20 to convert to upper case
   732 00:BD96: C9 41        ucok    cmp     #'A'            ;compare for ascii "A" or higher
   733 00:BD98: 90 04                bcc     baddrv          ;branch if too low
   734 00:BD9A: C9 49                cmp     #maxdrv+$41     ;check for ascii of maxdrv or higher
   735 00:BD9C: 90 02                bcc     drvok           ;if okay, branch and set drive
   736 00:BD9E: A9 49        baddrv  lda     #maxdrv+$41     ;else, get first out of range drive
   737                        ;
   738 00:BDA0: 29 0F        drvok   and     #%00001111      ;mask off upper 4 bits
   739 00:BDA2: 8D D4 C0             sta     tmpdsk          ;set as temp disk
   740 00:BDA5: 9D 8D C0             sta     fcbone,x        ;and into fcb
   741 00:BDA8: C8                   iny                     ;increment pointer past colon
   742 00:BDA9: A9 08        trynme  lda     #8              ;set name count
   743 00:BDAB: 8D D6 C0             sta     count           ;to eight
   744 00:BDAE: 20 4D BE     tstnme  jsr     tstlgl          ;test for illegal
   745 00:BDB1: F0 1D                beq     flnmsp          ;if illegal jump
   746 00:BDB3: E8                   inx                     ;bump pointer
   747 00:BDB4: C9 2A                cmp     #'*'            ;if not *
   748 00:BDB6: D0 07                bne     notafn          ;skip ? fill
   749 00:BDB8: A9 3F                lda     #'?'            ;get a ?
   750 00:BDBA: 9D 8D C0             sta     fcbone,x        ;store it,
   751 00:BDBD: 80 04                bra     nxtout          ;then branch
   752 00:BDBF: 9D 8D C0     notafn  sta     fcbone,x        ;store char
   753 00:BDC2: C8                   iny                     ;bump source
  Mon Apr  3 2023 10:57                                                                                                    Page 16


   754 00:BDC3: CE D6 C0     nxtout  dec     count           ;drop counter down
   755 00:BDC6: D0 E6                bne     tstnme          ;and loop
   756 00:BDC8: 20 4D BE     skpmre  jsr     tstlgl          ;if illegal
   757 00:BDCB: F0 11                beq     trytyp          ;try type
   758 00:BDCD: C8                   iny                     ;else bump index
   759 00:BDCE: D0 F8                bne     skpmre          ;and loop
   760 00:BDD0: E8           flnmsp  inx                     ;next position
   761 00:BDD1: A9 20                lda     #' '            ;get a space
   762 00:BDD3: 9D 8D C0             sta     fcbone,x        ;store
   763 00:BDD6: CE D6 C0             dec     count           ;count down
   764 00:BDD9: D0 F5                bne     flnmsp          ;and loop
   765 00:BDDB: B9 0D C0             lda     cnstxt,y        ;get char again
   766 00:BDDE: 48           trytyp  pha                     ;save char
   767 00:BDDF: A9 03                lda     #3              ;set count
   768 00:BDE1: 8D D6 C0             sta     count           ;to three
   769 00:BDE4: 68                   pla                     ;get char
   770 00:BDE5: C9 2E                cmp     #'.'            ;if not .
   771 00:BDE7: D0 23                bne     fltysp          ;then fill spaces
   772 00:BDE9: C8                   iny                     ;else bump source
   773 00:BDEA: 20 4D BE     tsttyp  jsr     tstlgl          ;if not legal
   774 00:BDED: F0 1D                beq     fltysp          ;then fill spaces
   775 00:BDEF: E8                   inx                     ;else bump index
   776 00:BDF0: C9 2A                cmp     #'*'            ;if not *
   777 00:BDF2: D0 07                bne     notaft          ;then skip fill
   778 00:BDF4: A9 3F                lda     #'?'            ;else get ?
   779 00:BDF6: 9D 8D C0             sta     fcbone,x        ;move to fcb
   780 00:BDF9: D0 04                bne     mrtyfl          ;and loop
   781 00:BDFB: 9D 8D C0     notaft  sta     fcbone,x        ;move char to fcb
   782 00:BDFE: C8                   iny                     ;bump source
   783 00:BDFF: CE D6 C0     mrtyfl  dec     count           ;count down
   784 00:BE02: D0 E6                bne     tsttyp          ;and loop
   785 00:BE04: 20 4D BE     nttype  jsr     tstlgl          ;if illegal
   786 00:BE07: F0 0E                beq     filnul          ;fill out nulls
   787 00:BE09: C8                   iny                     ;else bump source
   788 00:BE0A: D0 F8                bne     nttype          ;and loop
   789 00:BE0C: E8           fltysp  inx                     ;bump fcb pointer
   790 00:BE0D: A9 20                lda     #' '            ;get space
   791 00:BE0F: 9D 8D C0             sta     fcbone,x        ;put in fcb
   792 00:BE12: CE D6 C0             dec     count           ;count down
   793 00:BE15: D0 F5                bne     fltysp          ;and continue
   794 00:BE17: A9 03        filnul  lda     #3              ;clear
   795 00:BE19: 8D D6 C0             sta     count           ;three
   796 00:BE1C: E8           mrnlty  inx                     ;bump fcb pointer
   797 00:BE1D: 9E 8D C0             stz     fcbone,x        ;clear fcb
   798 00:BE20: CE D6 C0             dec     count           ;count down
   799 00:BE23: D0 F7                bne     mrnlty          ;loop until done
   800 00:BE25: 8C D2 C0             sty     cnbfpt          ;update start pointer
   801 00:BE28: 9C D6 C0             stz     count           ;clear count
   802 00:BE2B: 7A                   ply                     ;restore stack
   803 00:BE2C: A2 0B                ldx     #11             ;counter to 11
   804 00:BE2E: C8           tstqus  iny                     ;point to
   805 00:BE2F: B9 8D C0             lda     fcbone,y        ;and get char
   806 00:BE32: C9 3F                cmp     #'?'            ;if not a ?
   807 00:BE34: D0 03                bne     nxtqus          ;then jump
   808 00:BE36: EE D6 C0             inc     count           ;else bump count
   809 00:BE39: CA           nxtqus  dex                     ;loop until
   810 00:BE3A: D0 F2                bne     tstqus          ;11 tested
   811 00:BE3C: AD D6 C0             lda     count           ;get count
   812 00:BE3F: 60                   rts                     ;and return
   813                        ;skip space
   814 00:BE40: B9 0D C0     skpspc  lda     cnstxt,y        ;get char
   815 00:BE43: F0 07                beq     extskp          ;jump if null
   816 00:BE45: C9 20                cmp     #' '            ;if not space
  Mon Apr  3 2023 10:57                                                                                                    Page 17


   817 00:BE47: D0 03                bne     extskp          ;then exit
   818 00:BE49: C8                   iny                     ;else go to next
   819 00:BE4A: D0 F4                bne     skpspc          ;and test
   820 00:BE4C: 60           extskp  rts                     ;return to caller
   821                        ;test legal
   822 00:BE4D: B9 0D C0     tstlgl  lda     cnstxt,y        ;get char
   823 00:BE50: F0 1C                beq     extlgl
   824 00:BE52: C9 20                cmp     #' '            ;if space
   825 00:BE54: 90 19                bcc     badinp          ;ok - less is error
   826 00:BE56: F0 16                beq     extlgl
   827 00:BE58: C9 3D                cmp     #'='
   828 00:BE5A: F0 12                beq     extlgl
   829 00:BE5C: C9 2E                cmp     #'.'
   830 00:BE5E: F0 0E                beq     extlgl
   831 00:BE60: C9 3A                cmp     #':'
   832 00:BE62: F0 0A                beq     extlgl
   833 00:BE64: C9 3B                cmp     #semico
   834 00:BE66: F0 06                beq     extlgl
   835 00:BE68: C9 3C                cmp     #'<'
   836 00:BE6A: F0 02                beq     extlgl
   837 00:BE6C: C9 3E                cmp     #'>'
   838 00:BE6E: 60           extlgl  rts                     ;return to caller
   839 00:BE6F: 4C 5E B9     badinp  jmp     cmderr
   840                        ;
   841                        ;set default buffer address
   842 00:BE72: A9 28        stdflb  lda     #<dflbuf        ;point to
   843 00:BE74: A0 01                ldy     #>dflbuf        ;location
   844 00:BE76: 4C E5 BC             jmp     setbuf          ;and set
   845                        ;
   846                        ;clear automatic and select
   847 00:BE79: 9C 8D C0     clrslt  stz     fcbone          ;clear auto select
   848 00:BE7C: AD D4 C0     slttmp  lda     tmpdsk          ;get temp
   849 00:BE7F: F0 1D                beq     extsnd          ;if zero exit
   850 00:BE81: 3A                   dec     a               ;subtract one ;-)
   851 00:BE82: CD D3 C0             cmp     dfldsk          ;if same as default
   852 00:BE85: F0 17                beq     extsnd          ;then quit
   853 00:BE87: 4C B6 BC             jmp     slctds          ;else set
   854                        ;
   855                        ;send message
   856 00:BE8A: 8C DA C0     sndmsg  sty     savy            ;save index
   857 00:BE8D: 20 93 BC             jsr     ccrlf           ;do cr and lf
   858 00:BE90: AC DA C0             ldy     savy            ;get index
   859 00:BE93: B9 66 BF     lpesnd  lda     msgtbl,y        ;get char
   860 00:BE96: F0 06                beq     extsnd          ;if null quit
   861 00:BE98: 20 38 BD             jsr     cotsxy          ;else send
   862 00:BE9B: C8                   iny                     ;point to next
   863 00:BE9C: D0 F5                bne     lpesnd          ;and loop
   864 00:BE9E: 60           extsnd  rts                     ;return to caller
   865                        ;
   866                        ;set load start address
   867 00:BE9F: A9 00        setddb  lda     #<tea           ;to tea start
   868 00:BEA1: A0 08                ldy     #>tea
   869 00:BEA3: 8D DD C0     setdb   sta     dskbuf          ;to ay
   870 00:BEA6: 8C DE C0             sty     dskbuf+1
   871 00:BEA9: 60                   rts                     ;return to caller
   872                        ;
   873                        ;move first part of fcb to second half
   874                        ;and move second part to first part.
   875                        ;only ren depends upon this routine to actually
   876                        ;swap fcb halves.
   877                        ;alters:a,x,p
   878                        ;returns:x=$ff
   879 00:BEAA: A2 0F        frssec  ldx     #15             ;set index to last
  Mon Apr  3 2023 10:57                                                                                                    Page 18


   880 00:BEAC: BD 8D C0     frsclp  lda     fcbone,x        ;get byte
   881 00:BEAF: BC 9D C0             ldy     fcbone+16,x
   882 00:BEB2: 9D 9D C0             sta     fcbone+16,x     ;move it
   883 00:BEB5: 98                   tya
   884 00:BEB6: 9D 8D C0             sta     fcbone,x
   885 00:BEB9: CA                   dex
   886 00:BEBA: 10 F0                bpl     frsclp          ;until 16 moved
   887 00:BEBC: 60                   rts                     ;return to caller
   888                        ;
   889                        ;move second part of fcb to first half
   890                        ;restore tmpdsk from save location
   891                        ;alters:a,x,p
   892                        ;returns:x=$ff
   893 00:BEBD: A2 0F        secfrs  ldx     #15             ;set index to last
   894 00:BEBF: BD 9D C0     scfrlp  lda     fcbone+16,x     ;get byte
   895 00:BEC2: 9D 8D C0             sta     fcbone,x        ;move it
   896 00:BEC5: CA                   dex
   897 00:BEC6: 10 F7                bpl     scfrlp          ;loop until done
   898 00:BEC8: AD DC C0             lda     oldtmp          ;get old flag
   899 00:BECB: 8D D4 C0             sta     tmpdsk          ;and set
   900 00:BECE: 60                   rts                     ;return to caller
   901                        ;
   902                        ;build a number from command line and leave in num
   903                        ;will handle either decimal (e.g., 578) or hexadecimal (e.g., $3f2)
   904                        ;move parse index past number
   905                        ;modifies:all
   906                        ;returns:a,y set to low and high of number
   907                        ; flags set according to y which is high part of number
   908 00:BECF: A9 09        bldnum  lda     #9              ;preset to decimal
   909 00:BED1: 8D E0 C0             sta     moduls
   910 00:BED4: 20 69 BD             jsr     prslin          ;put in fcb
   911 00:BED7: AD D4 C0             lda     tmpdsk          ;if temp
   912 00:BEDA: D0 67                bne     numerr          ;is error
   913 00:BEDC: 8D E1 C0             sta     num             ;else clear num
   914 00:BEDF: 8D E2 C0             sta     num+1
   915 00:BEE2: A8                   tay                     ;and index
   916 00:BEE3: B9 8E C0             lda     fcbone+1,y      ;get first char
   917 00:BEE6: C9 24                cmp     #'$'            ;see if hex signal
   918 00:BEE8: D0 06                bne     bnumlp          ;skip if not
   919 00:BEEA: A9 0F                lda     #15             ;set for modulus
   920 00:BEEC: 8D E0 C0             sta     moduls
   921 00:BEEF: C8                   iny                     ;bump past $
   922 00:BEF0: C8           bnumlp  iny                     ;next char
   923 00:BEF1: B9 8D C0             lda     fcbone,y        ;get digit
   924 00:BEF4: C9 20                cmp     #' '            ;see if space
   925 00:BEF6: F0 4E                beq     endnlp          ;done if is
   926 00:BEF8: 20 46 CA             jsr     tstdec          ;see if decimal
   927 00:BEFB: 90 0E                bcc     usedig          ;use if is
   928 00:BEFD: 20 50 CA             jsr     tsthex          ;see if hex
   929 00:BF00: B0 41                bcs     numerr          ;error if not
   930 00:BF02: E9 06                sbc     #6              ;remove offset
   931 00:BF04: A2 0F                ldx     #15             ;test for hex modulus
   932 00:BF06: EC E0 C0             cpx     moduls
   933 00:BF09: D0 38                bne     numerr          ;error if not
   934 00:BF0B: 29 0F        usedig  and     #%00001111      ;eliminate ascii bias
   935 00:BF0D: 48                   pha                     ;save result
   936 00:BF0E: AD E1 C0             lda     num             ;move number to temp
   937 00:BF11: 8D E3 C0             sta     tnum
   938 00:BF14: AD E2 C0             lda     num+1
   939 00:BF17: 8D E4 C0             sta     tnum+1
   940 00:BF1A: AE E0 C0             ldx     moduls          ;get modulus
   941 00:BF1D: 18                   clc
   942 00:BF1E: AD E1 C0     addlpe  lda     num             ;add number to itself
  Mon Apr  3 2023 10:57                                                                                                    Page 19


   943 00:BF21: 6D E3 C0             adc     tnum
   944 00:BF24: 8D E1 C0             sta     num
   945 00:BF27: AD E2 C0             lda     num+1           ;modulus times
   946 00:BF2A: 6D E4 C0             adc     tnum+1
   947 00:BF2D: 8D E2 C0             sta     num+1
   948 00:BF30: B0 11                bcs     numerr          ;error if carry out
   949 00:BF32: CA                   dex
   950 00:BF33: D0 E9                bne     addlpe          ;loop if more
   951 00:BF35: 68                   pla                     ;get input back
   952 00:BF36: 6D E1 C0             adc     num             ;add in
   953 00:BF39: 8D E1 C0             sta     num
   954 00:BF3C: 90 B2                bcc     bnumlp          ;loop if no carry
   955 00:BF3E: EE E2 C0             inc     num+1           ;else bump high
   956 00:BF41: D0 AD                bne     bnumlp          ;and loop for more
   957                        ;error in bldnum - handle and quit
   958 00:BF43: 4C 5E B9     numerr  jmp     cmderr          ;do general error
   959                        ;end of use of name part - check type
   960 00:BF46: AD 96 C0     endnlp  lda     fcbone+9        ;get first
   961 00:BF49: C9 20                cmp     #' '            ;see if space
   962 00:BF4B: D0 F6                bne     numerr          ;error if not
   963 00:BF4D: AD E1 C0             lda     num             ;return with result
   964 00:BF50: AC E2 C0             ldy     num+1
   965 00:BF53: 60                   rts                     ;return to caller
   966                        ;
   967                        ;function entry vector table
   968 00:BF54: 7A B9        xqfntb  .DW     dir
   969 00:BF56: 52 BA                .DW     save
   970 00:BF58: ED BA                .DW     era
   971 00:BF5A: 0D BB                .DW     type
   972 00:BF5C: F2 B9                .DW     ren
   973 00:BF5E: 86 BB                .DW     go
   974 00:BF60: 4B BB                .DW     load
   975 00:BF62: 96 BB                .DW     user
   976 00:BF64: C8 BB                .DW     trns
   977                        ;
   978                        ;Messages
   979                        msgtbl
   980                        ;
   981             00000000   nospms  .EQU    *-msgtbl
   982 00:BF66: 4E 4F 20 53          .DB     "NO SPACE",0
       00:BF6A: 50 41 43 45 
       00:BF6E: 00 
   983             00000009   ntclms  .EQU    *-msgtbl
   984 00:BF6F: 43 41 4E 20          .DB     "CAN NOT CLOSE",0
       00:BF73: 4E 4F 54 20 
       00:BF77: 43 4C 4F 53 
       00:BF7B: 45 00 
   985             00000017   alflms  .EQU    *-msgtbl
   986 00:BF7D: 41 4C 4C 20          .DB     "ALL FILES (Y/N)?",0
       00:BF81: 46 49 4C 45 
       00:BF85: 53 20 28 59 
       00:BF89: 2F 4E 29 3F 
       00:BF8D: 00 
   987             00000028   rderms  .EQU    *-msgtbl
   988 00:BF8E: 52 45 41 44          .DB     "READ ERROR",0
       00:BF92: 20 45 52 52 
       00:BF96: 4F 52 00 
   989             00000033   ntfnms  .EQU    *-msgtbl
   990 00:BF99: 4E 4F 54 20          .DB     "NOT FOUND",0
       00:BF9D: 46 4F 55 4E 
       00:BFA1: 44 00 
   991             0000003D   flexms  .EQU    *-msgtbl
   992 00:BFA3: 46 49 4C 45          .DB     "FILE EXISTS",0
  Mon Apr  3 2023 10:57                                                                                                    Page 20


       00:BFA7: 20 45 58 49 
       00:BFAB: 53 54 53 00 
   993             00000049   lderms  .EQU    *-msgtbl
   994 00:BFAF: 4C 4F 41 44          .DB     "LOAD ERROR",0
       00:BFB3: 20 45 52 52 
       00:BFB7: 4F 52 00 
   995             00000054   cnnoms  .EQU    *-msgtbl
   996 00:BFBA: 43 41 4E 20          .DB     "CAN NOT OPEN",0
       00:BFBE: 4E 4F 54 20 
       00:BFC2: 4F 50 45 4E 
       00:BFC6: 00 
   997             00000061   wrerms  .EQU    *-msgtbl
   998 00:BFC7: 57 52 49 54          .DB     "WRITE ERROR",0
       00:BFCB: 45 20 45 52 
       00:BFCF: 52 4F 52 00 
   999             0000006D   userms  .EQU    *-msgtbl
  1000 00:BFD3: 49 4E 56 41          .DB     "INVALID USER",0
       00:BFD7: 4C 49 44 20 
       00:BFDB: 55 53 45 52 
       00:BFDF: 00 
  1001                        ;
  1002                        ;Function name table
  1003                        fnctbl
  1004 00:BFE0: 44 49 52 20          .DB     "DIR ",0
       00:BFE4: 00 
  1005 00:BFE5: 53 41 56 45          .DB     "SAVE ",0
       00:BFE9: 20 00 
  1006 00:BFEB: 45 52 41 20          .DB     "ERA ",0
       00:BFEF: 00 
  1007 00:BFF0: 54 59 50 45          .DB     "TYPE ",0
       00:BFF4: 20 00 
  1008 00:BFF6: 52 45 4E 20          .DB     "REN ",0
       00:BFFA: 00 
  1009 00:BFFB: 47 4F 20 00          .DB     "GO ",0
  1010 00:BFFF: 4C 4F 41 44          .DB     "LOAD ",0
       00:C003: 20 00 
  1011 00:C005: 55 53 45 52          .DB     "USER ",0
       00:C009: 20 00 
  1012                        ;
  1013                        ;ccm variable storage
  1014                        ;
  1015                        ;input buffer
  1016                        cnsbuf
  1017 00:C00B: 7F           cnsmax  .DB     127
  1018 00:C00C: 00           cnslng  .DB     0
  1019 00:C00D:              cnstxt  DEFS    128             ;set to 128 for safety
  1020                        ;fcb one
  1021 00:C08D:              fcbone  DEFS    33
  1022                        ;
  1023                        ;submit FCB
  1024 00:C0AE: 00           subfcb  .DB     0               ;will be drive A
  1025 00:C0AF: 24 24 24 20          .DB     '$$$     '      ;name field
       00:C0B3: 20 20 20 20 
  1026 00:C0B7: 53 55 42             .DB     'SUB'           ;type field
  1027 00:C0BA: 00                   .DB     0               ;extent
  1028 00:C0BB: 00 00                .DB     0,0             ;unused
  1029 00:C0BD: 00           SUBRC   .DB     0               ;number of records
  1030 00:C0BE:                      DEFS    16              ;block number area
  1031 00:C0CE: 00           SUBCR   .DB     0               ;current record to read
  1032                        ;
  1033                        ;com type field
  1034 00:C0CF: 43 4F 4D     typcom  .DB     "COM"
  1035                        ;
  Mon Apr  3 2023 10:57                                                                                                    Page 21


  1036                        ;variable storage
  1037 00:C0D2: 00           cnbfpt  .DB     0               ;buffer index
  1038 00:C0D3: 00           dfldsk  .DB     0               ;default drive
  1039 00:C0D4: 00           tmpdsk  .DB     0               ;temporary drive
  1040 00:C0D5: 00           dsksav  .DB     0               ;save default during $$$.sub ops
  1041 00:C0D6: 00           count   .DB     0               ;counter
  1042 00:C0D7: 00           curpnt  .DB     0               ;input parse start
  1043 00:C0D8: 00           diradd  .DB     0               ;directory number
  1044 00:C0D9: 00           savx    .DB     0               ;save x location
  1045 00:C0DA: 00           savy    .DB     0               ;save y location
  1046 00:C0DB: 00           length  .DB     0               ;number pages to save
  1047 00:C0DC: 00           oldtmp  .DB     0               ;temp drive in ren
  1048 00:C0DD: 00 08        dskbuf  .DW     tea             ;disk buffer start
  1049 00:C0DF: 00           across  .DB     0               ;dir count on line
  1050 00:C0E0: 09           moduls  .DB     9               ;modulus-1 for number input
  1051 00:C0E1: 00 00        num     .DW     0               ;input number
  1052 00:C0E3: 00 00        tnum    .DW     0               ;temp in bldnum
  1053 00:C0E5: 00 08        sadr    .DW     tea             ;save start address
  1054                        ;
  1055                                END
   186                        ;
   187                                        .ORG    $/256*256+256           ;Align to Page address
   188                        ;
   189                                include         DOS65-PEM-V320.ASM      ;Include PEM Module
     1                        ;
     2                        ;----------------------------------------
     3                        ;dos/65 primitive execution module (pem)
     4                        ;----------------------------------------
     5                        ;
     6                        ; Note: The checksum routine and all associated code
     7                        ; to support the checksum operations have been removed
     8                        ; from PEM. This is no longer required with standard
     9                        ; IDE or other nonremovable block devices.
    10                        ;  - clcchk and clcckp routines are also removed.
    11                        ;
    12                        ; Other routines which are specific to diskette media
    13                        ; has also been removed. Many of these routines are
    14                        ; specific to checking for a diskette being removed,
    15                        ; which is considered removable media.
    16                        ;
    17                        ; As this new version of DOS/65 works specifically with
    18                        ; newer Block level devices (IDE, Compact Flash, SD-Card,
    19                        ; SCSI, etc.) there's no longer a need to keep these
    20                        ; routines in play.
    21                        ;
    22                        pemram
    23                        ;
    24                        ;main program
    25                        ; input:x=command,a=value,a&y=address
    26                        ; returns:a=value,a&y=address
    27                        ; alters:all
    28 00:C100: D8                   cld                     ;ensure binary mode
    29 00:C101: 8D 45 CB             sta     lowin           ;save value and
    30 00:C104: 8C 46 CB             sty     lowin+1         ;address to pointers
    31 00:C107: E0 25                cpx     #numcmd         ;check for valid cmd number
    32 00:C109: B0 35                bcs     noswot          ;exit without switch, if over
    33 00:C10B: DA                   phx                     ;else, save command to stack
    34 00:C10C: 20 94 C3             jsr     switch          ;switch data to/from page zero
    35 00:C10F: 68                   pla                     ;then restore command to A reg
    36 00:C110: 9C 13 CB             stz     tmpdrv          ;clear drive switch flag
    37 00:C113: 0A                   asl     a               ;multiply command by two
    38 00:C114: AA                   tax                     ;xfer back for index pointer
    39 00:C115: A5 98                lda     addinp          ;get input value
  Mon Apr  3 2023 10:57                                                                                                    Page 22


    40 00:C117: A4 99                ldy     addinp+1        ;and address value
    41 00:C119: 20 47 C1             jsr     cmd_exe         ;call execute PEM command
    42                        ;
    43                        ;The next line is the exit entry location for
    44                        ;all PEM function calls.
    45 00:C11C: 8D 10 CB     extexq  sta     bytout          ;save value
    46 00:C11F: 8C 11 CB             sty     addout+1        ;and address
    47                        ;First step is to restore original drive
    48 00:C122: AD 13 CB             lda     tmpdrv          ;see if temp drive flag set
    49 00:C125: F0 09                beq     notmpd          ;no so skip following
    50 00:C127: AD 1A CB             lda     olddrv          ;get original drive number
    51 00:C12A: 8D 07 CB             sta     drvcmd          ;set up like input
    52 00:C12D: 20 D8 C3             jsr     chgdrv          ;change drive back
    53                        ;
    54                        ;At this point OLDDRV is mapped with USRCDE in
    55                        ;byte 0 of FCB. Now clear that byte and restore
    56                        ;original drive designator.
    57 00:C130: 5F 9E 0A     notmpd  bbr5    d65flg,skptmp   ;test flag, branch if clear
    58 00:C133: 57 9E                rmb5    d65flg          ;clear drive flag bit
    59                        ;
    60 00:C135: AD 13 CB             lda     tmpdrv          ;get temp drive
    61 00:C138: 92 98                sta     (addinp)        ;put back into fcb
    62 00:C13A: 9C 13 CB             stz     tmpdrv          ;clear flag
    63 00:C13D: 20 94 C3     skptmp  jsr     switch          ;switch memory to/from page zero
    64 00:C140: AC 11 CB     noswot  ldy     addout+1        ;get address
    65 00:C143: AD 10 CB             lda     bytout          ;and value (address low)
    66 00:C146: 60                   rts                     ;return to caller
    67                        ;
    68 00:C147: 7C 4A C1     cmd_exe jmp     (cmdtbl,x)      ;execute PEM command via table
    69                        ;
    70                        ;command vector table
    71                        cmdtbl
    72 00:C14A: A8 C1                .DW     xwboot          ;warm boot (x=0)
    73 00:C14C: 86 C3                .DW     xcnsin          ;console input with echo (x=1)
    74 00:C14E: D0 C8                .DW     sndchr          ;console output (x=2)
    75 00:C150: 15 CC                .DW     simram+21       ;tape reader (x=3)
    76 00:C152: 12 CC                .DW     simram+18       ;tape punch (x=4)
    77 00:C154: 0F CC                .DW     simram+15       ;printer output (x=5)
    78 00:C156: 53 C8                .DW     getcon          ;console input w/o echo (x=6)
    79 00:C158: E0 C1                .DW     xgtios          ;read i/o status (x=7)
    80 00:C15A: EB C1                .DW     xstios          ;set i/o status (x=8)
    81 00:C15C: 91 C8                .DW     sndstr          ;print buffer (x=9)
    82 00:C15E: 37 C9                .DW     bufinp          ;read buffer (x=10)
    83 00:C160: 5E C8                .DW     kbdsts          ;test console ready (x=11)
    84 00:C162: 2D CC                .DW     simram+45       ;read list status (x=12)
    85 00:C164: EF C3                .DW     xintds          ;initialize system (x=13)
    86 00:C166: CF C3                .DW     xchgdr          ;log in drive (x=14)
    87 00:C168: E7 C5                .DW     xopen           ;open file (x=15)
    88 00:C16A: 22 C6                .DW     xclose          ;close file (x=16)
    89 00:C16C: 46 C6                .DW     xfndfr          ;find first match (x=17)
    90 00:C16E: FB C1                .DW     xfndnx          ;find next match (x=18)
    91 00:C170: 61 C2                .DW     xdltfl          ;delete file (x=19)
    92 00:C172: 03 C2                .DW     xread           ;read record (x=20)
    93 00:C174: 86 C2                .DW     xwrite          ;write record (x=21)
    94 00:C176: E6 C6                .DW     xmake           ;create file (x=22)
    95 00:C178: 3F C2                .DW     xrenme          ;rename file (x=23)
    96 00:C17A: F3 C1                .DW     xintlg          ;interrogate log in status (x=24)
    97 00:C17C: EF C1                .DW     xintdr          ;interrogate current drive (x=25)
    98 00:C17E: A4 C3                .DW     chgdma          ;set buffer address (x=26)
    99 00:C180: E4 C1                .DW     xrdalv          ;read allocation map start (x=27)
   100 00:C182: B3 C5                .DW     setron          ;set r/w status (x=28)
   101 00:C184: F7 C1                .DW     xrdros          ;read r/w status (x=29)
   102 00:C186: 94 C1                .DW     setlst          ;set list echo status (x=30)
  Mon Apr  3 2023 10:57                                                                                                    Page 23


   103 00:C188: 98 C1                .DW     lststs          ;read list echo status (x=31)
   104 00:C18A: BB C1                .DW     xrtclo          ;read low clock (x=32)
   105 00:C18C: CF C1                .DW     xrtchi          ;read high clock (x=33)
   106 00:C18E: D9 C1                .DW     xrddcb          ;read dcb address (x=34)
   107 00:C190: 33 CC                .DW     simram+51       ;translate sector (x=35) - obsolete
   108 00:C192: 9C C1                .DW     xgsusr          ;get or set user code (x=36)
   109                        ;
   110                        ;set list echo status
   111 00:C194: 8D 0E CB     setlst  sta     lstflg          ;set flag
   112 00:C197: 60                   rts
   113                        ;
   114                        ;read list echo status
   115 00:C198: AD 0E CB     lststs  lda     lstflg          ;read flag
   116 00:C19B: 60                   rts
   117                        ;
   118                        ;execute get or set user code
   119                        ; when A reg is #255, it's a request to get the user code
   120                        ; otherwise, A reg is #0-15 to set the user code
   121 00:C19C: C9 FF        xgsusr  cmp     #255            ;check if request
   122 00:C19E: F0 04                beq     rtnusr          ;if #255, get user code
   123 00:C1A0: 8D 08 CB             sta     usrcde          ;else, set user code
   124 00:C1A3: 60                   rts                     ;then exit
   125 00:C1A4: AD 08 CB     rtnusr  lda     usrcde          ;get user code
   126 00:C1A7: 60                   rts                     ;then exit
   127                        ;
   128                        ;execute warm boot
   129                        ; ***this command does not return to pem***
   130                        ; SIM handles reloading of CCM and PEM,
   131                        ; then initializes Page zero, the CPU stack
   132                        ; the PEM vectors at $0100, then jumps to CCM.
   133 00:C1A8: 20 94 C3     xwboot  jsr     switch          ;switch memory
   134 00:C1AB: AD 08 CB             lda     usrcde          ;get user code
   135 00:C1AE: 0A                   asl     a               ;shift to high nibble
   136 00:C1AF: 0A                   asl     a
   137 00:C1B0: 0A                   asl     a
   138 00:C1B1: 0A                   asl     a
   139 00:C1B2: 0D 1B CB             ora     curdrv          ;or in current drive
   140 00:C1B5: 8D 06 01             sta     iostat          ;save for SIM
   141 00:C1B8: 4C 03 CC             jmp     simram+3        ;go to sim to execute
   142                        ;
   143                        ;execute read real time clock
   144 00:C1BB: 20 30 CC     xrtclo  jsr     simram+48       ;read clock
   145 00:C1BE: 8D 33 CB             sta     rtclk           ;save low
   146 00:C1C1: 8C 34 CB             sty     rtclk+1         ;middle
   147 00:C1C4: 8E 35 CB             stx     rtclk+2         ;high
   148 00:C1C7: 8A                   txa
   149 00:C1C8: 29 80                and     #%10000000      ;test for valid
   150 00:C1CA: A8                   tay
   151 00:C1CB: AD 33 CB             lda     rtclk           ;get low
   152 00:C1CE: 60                   rts
   153                        ;
   154                        ;execute read real time clock high
   155 00:C1CF: AD 35 CB     xrtchi  lda     rtclk+2         ;get high
   156 00:C1D2: 29 7F                and     #%01111111      ;clear status
   157 00:C1D4: A8                   tay
   158 00:C1D5: AD 34 CB             lda     rtclk+1         ;get middle
   159 00:C1D8: 60                   rts
   160                        ;
   161                        ;execute read dcb address
   162 00:C1D9: AD 22 C4     xrddcb  lda     cptdcb+1        ;get address
   163 00:C1DC: AC 23 C4             ldy     cptdcb+2
   164 00:C1DF: 60                   rts
   165                        ;
  Mon Apr  3 2023 10:57                                                                                                    Page 24


   166                        ;execute read i/o status
   167 00:C1E0: AD 06 01     xgtios  lda     iostat          ;get status byte
   168 00:C1E3: 60                   rts
   169                        ;
   170                        ;execute read allocation map starting address
   171 00:C1E4: AD 41 CB     xrdalv  lda     alcmap          ;get
   172 00:C1E7: AC 42 CB             ldy     alcmap+1        ;starting address
   173 00:C1EA: 60                   rts                     ;then return
   174                        ;
   175                        ;execute set i/o status
   176 00:C1EB: 8D 06 01     xstios  sta     iostat          ;set status
   177 00:C1EE: 60                   rts
   178                        ;
   179                        ;execute interrogate current drive
   180 00:C1EF: AD 1B CB     xintdr  lda     curdrv          ;get number
   181 00:C1F2: 60                   rts
   182                        ;
   183                        ;execute read log in status
   184 00:C1F3: AD 1C CB     xintlg  lda     lginvc          ;get status
   185 00:C1F6: 60                   rts
   186                        ;
   187                        ;execute read read/write status
   188 00:C1F7: AD 1D CB     xrdros  lda     ronlst          ;get status
   189 00:C1FA: 60                   rts
   190                        ;
   191                        ;execute find next match
   192 00:C1FB: 20 AF C3     xfndnx  jsr     autodr          ;auto drive select
   193 00:C1FE: A9 0D                lda     #13             ;match including
   194 00:C200: 4C 50 C6             jmp     search          ;extent
   195                        ;
   196                        ;execute read next record
   197 00:C203: 20 AF C3     xread   jsr     autodr          ;auto drive select
   198 00:C206: 20 C7 C5             jsr     inrcct          ;initialize record counters
   199 00:C209: AD 26 CB             lda     nxtrec          ;if next record less
   200 00:C20C: CD 27 CB             cmp     numrec          ;then number records
   201 00:C20F: 90 11                bcc     tryrde          ;then try to read
   202 00:C211: C9 80                cmp     #128            ;but if not and
   203 00:C213: F0 03                beq     tryext          ;is max try to extend
   204 00:C215: A9 01        rdeeof  lda     #1              ;else set eof
   205 00:C217: 60                   rts                     ;code and return
   206 00:C218: E7 9E        tryext  smb6    d65flg          ;set bit for read
   207 00:C21A: 20 20 C7             jsr     extend          ;file extension
   208 00:C21D: D0 F6                bne     rdeeof          ;with jump back
   209 00:C21F: 8D 26 CB             sta     nxtrec          ;clear next record
   210 00:C222: 20 8B C7     tryrde  jsr     getblk          ;and get block
   211 00:C225: AD 21 CB             lda     blknum          ;if block not zero
   212 00:C228: 0D 22 CB             ora     blknum+1
   213 00:C22B: D0 03                bne     dorde           ;do the read
   214 00:C22D: A9 02                lda     #2              ;else set unwritten
   215 00:C22F: 60                   rts                     ;code and exit
   216 00:C230: 20 95 C6     dorde   jsr     calrcn          ;calculate record number
   217 00:C233: 20 4B C5             jsr     setrec          ;set record number
   218 00:C236: 20 23 C8             jsr     rderec          ;do record read
   219 00:C239: 20 D6 C5             jsr     updtrc          ;update counters
   220 00:C23C: A9 00                lda     #0              ;return w/o error
   221 00:C23E: 60           extrde  rts
   222                        ;
   223                        ;execute file rename
   224 00:C23F: 20 AF C3     xrenme  jsr     autodr          ;automatic drive select
   225 00:C242: 20 07 C8             jsr     tstron          ;test for r/o
   226 00:C245: A9 0C                lda     #12             ;match name
   227 00:C247: 20 4B C6             jsr     frstsr          ;and type
   228 00:C24A: 30 14                bmi     extren          ;exit if not found
  Mon Apr  3 2023 10:57                                                                                                    Page 25


   229 00:C24C: B2 98        doren   lda     (addinp)
   230 00:C24E: A0 10                ldy     #16             ;in new name
   231 00:C250: 91 98                sta     (addinp),y      ;part of fcb
   232 00:C252: A9 0C                lda     #12             ;then move
   233 00:C254: A2 10                ldx     #16             ;new name
   234 00:C256: 20 B5 C6             jsr     dirchg          ;to directory
   235 00:C259: A9 0C                lda     #12             ;see if
   236 00:C25B: 20 50 C6             jsr     search          ;another match
   237 00:C25E: 10 EC                bpl     doren           ;loop if found
   238 00:C260: 60           extren  rts                     ;number
   239                        ;
   240                        ;execute delete file
   241 00:C261: 20 AF C3     xdltfl  jsr     autodr          ;automatic drive select
   242 00:C264: 20 07 C8             jsr     tstron          ;test for r/o
   243 00:C267: A9 0C                lda     #12             ;match name
   244 00:C269: 20 4B C6             jsr     frstsr          ;and type
   245 00:C26C: 30 17                bmi     extdlt          ;done if not found
   246 00:C26E: A2 00        dodlt   ldx     #0              ;else do a
   247 00:C270: 20 CB C7             jsr     mapdir          ;delete
   248 00:C273: AC 20 CB             ldy     subrec          ;then change
   249 00:C276: AD EE CA             lda     empty           ;byte zero to
   250 00:C279: 91 9A                sta     (bufadd),y      ;empty code
   251 00:C27B: 20 2A C8             jsr     wrtrec
   252 00:C27E: A9 0C                lda     #12             ;search
   253 00:C280: 20 50 C6             jsr     search          ;for next
   254 00:C283: 10 E9                bpl     dodlt           ;loop if found
   255 00:C285: 60           extdlt  rts                     ;exit
   256                        ;
   257                        ;execute write next record
   258 00:C286: 20 AF C3     xwrite  jsr     autodr          ;automatic drive select
   259 00:C289: 20 07 C8             jsr     tstron          ;test for r/o
   260 00:C28C: 20 C7 C5             jsr     inrcct          ;initialize counters
   261 00:C28F: AD 26 CB             lda     nxtrec          ;get next record
   262 00:C292: C9 80                cmp     #128            ;compare to max
   263 00:C294: 90 03                bcc     ntexte          ;continue if less
   264 00:C296: A9 01                lda     #1              ;else flag as extend
   265 00:C298: 60                   rts                     ;error and exit
   266 00:C299: 20 8B C7     ntexte  jsr     getblk          ;calculate block num
   267 00:C29C: AD 21 CB             lda     blknum          ;get it and if
   268 00:C29F: 0D 22 CB             ora     blknum+1
   269 00:C2A2: F0 03                beq     zwrt            ;zero then get number
   270 00:C2A4: 4C 57 C3             jmp     blkopn          ;else go write
   271 00:C2A7: AD 0A CB     zwrt    lda     fcbind          ;get index from prior
   272 00:C2AA: 48                   pha                     ;and save
   273 00:C2AB: C9 10                cmp     #16             ;if first block
   274 00:C2AD: F0 16                beq     isfrst          ;then don't change
   275 00:C2AF: A8                   tay                     ;else make an index
   276 00:C2B0: 88                   dey                     ;point to last
   277 00:C2B1: 7F 9E 01             bbr7    d65flg,blm0     ;test mode, branch if byte
   278 00:C2B4: 88                   dey                     ;else drop for word
   279 00:C2B5: B1 98        blm0    lda     (addinp),y      ;and get that number
   280 00:C2B7: 8D 21 CB             sta     blknum          ;store as starting
   281 00:C2BA: C8                   iny                     ;bump for word
   282 00:C2BB: A9 00                lda     #0              ;preset for byte
   283 00:C2BD: 7F 9E 02             bbr7    d65flg,blm1     ;test mode, branch if byte
   284 00:C2C0: B1 98                lda     (addinp),y      ;else get high
   285 00:C2C2: 8D 22 CB     blm1    sta     blknum+1        ;then set high
   286 00:C2C5: AD 21 CB     isfrst  lda     blknum          ;get block
   287 00:C2C8: 8D 16 CB             sta     lkdown          ;set lower and
   288 00:C2CB: 8D 18 CB             sta     lookup          ;upper pointers
   289 00:C2CE: AD 22 CB             lda     blknum+1        ;now set high part
   290 00:C2D1: 8D 17 CB             sta     lkdown+1
   291 00:C2D4: 8D 19 CB             sta     lookup+1
  Mon Apr  3 2023 10:57                                                                                                    Page 26


   292 00:C2D7: AD 18 CB     srblag  lda     lookup          ;if upper pointer
   293 00:C2DA: CD 38 CB             cmp     maxblk          ;not at max
   294 00:C2DD: D0 08                bne     upnemx          ;then keep going
   295 00:C2DF: AC 19 CB             ldy     lookup+1        ;now check high
   296 00:C2E2: CC 39 CB             cpy     maxblk+1
   297 00:C2E5: F0 12                beq     tstdwn          ;go test down
   298 00:C2E7: EE 18 CB     upnemx  inc     lookup          ;else bump upper
   299 00:C2EA: D0 03                bne     skpup
   300 00:C2EC: EE 19 CB             inc     lookup+1
   301 00:C2EF: AD 16 CB     skpup   lda     lkdown          ;then if lower
   302 00:C2F2: 0D 17 CB             ora     lkdown+1
   303 00:C2F5: F0 18                beq     dotest          ;is zero start test
   304 00:C2F7: D0 0B                bne     dcdown          ;else drop lower
   305 00:C2F9: AD 16 CB     tstdwn  lda     lkdown          ;if upper & lower at
   306 00:C2FC: 0D 17 CB             ora     lkdown+1
   307 00:C2FF: D0 03                bne     dcdown          ;drop if not zero
   308 00:C301: A8                   tay                     ;also set y
   309 00:C302: F0 2F                beq     extsbl          ;then exit
   310 00:C304: AD 16 CB     dcdown  lda     lkdown          ;drop lower
   311 00:C307: D0 03                bne     skpdn
   312 00:C309: CE 17 CB             dec     lkdown+1
   313 00:C30C: CE 16 CB     skpdn   dec     lkdown
   314 00:C30F: AD 16 CB     dotest  lda     lkdown          ;get lower
   315 00:C312: AC 17 CB             ldy     lkdown+1
   316 00:C315: 20 97 C5             jsr     tstblk          ;and test
   317 00:C318: D0 08                bne     trylup          ;if full try upper
   318 00:C31A: AD 16 CB             lda     lkdown          ;else use lower
   319 00:C31D: AC 17 CB             ldy     lkdown+1
   320 00:C320: 80 11                bra     extsbl          ;as result
   321 00:C322: AD 18 CB     trylup  lda     lookup          ;get upper
   322 00:C325: AC 19 CB             ldy     lookup+1
   323 00:C328: 20 97 C5             jsr     tstblk          ;if full
   324 00:C32B: D0 AA                bne     srblag          ;then loop
   325 00:C32D: AD 18 CB             lda     lookup          ;else use upper
   326 00:C330: AC 19 CB             ldy     lookup+1
   327 00:C333: 8D 21 CB     extsbl  sta     blknum          ;then save number
   328 00:C336: 8C 22 CB             sty     blknum+1
   329 00:C339: 0D 22 CB             ora     blknum+1        ;see if zero
   330 00:C33C: D0 04                bne     gtgood          ;then proceed
   331 00:C33E: 68                   pla                     ;clear stack
   332 00:C33F: A9 02                lda     #2              ;set end
   333 00:C341: 60                   rts                     ;of data return
   334 00:C342: AD 21 CB     gtgood  lda     blknum          ;get low again
   335 00:C345: 20 AB C5             jsr     setblk          ;set allocation map
   336 00:C348: 7A                   ply                     ;get block pointer back
   337 00:C349: AD 21 CB             lda     blknum          ;get number
   338 00:C34C: 91 98                sta     (addinp),y      ;and put in fcb
   339 00:C34E: AD 22 CB             lda     blknum+1        ;get high
   340 00:C351: C8                   iny
   341 00:C352: 7F 9E 02             bbr7    d65flg,blkopn   ;test mode, branch if byte
   342 00:C355: 91 98                sta     (addinp),y      ;else set high
   343 00:C357: 20 95 C6     blkopn  jsr     calrcn          ;calculate record num
   344 00:C35A: 20 4B C5             jsr     setrec          ;set record number
   345 00:C35D: 20 2A C8             jsr     wrtrec          ;do write
   346 00:C360: AE 26 CB             ldx     nxtrec          ;get next record
   347 00:C363: EC 27 CB             cpx     numrec          ;if less than max
   348 00:C366: 90 05                bcc     notful          ;then ok
   349 00:C368: E8                   inx                     ;else bump count
   350 00:C369: 8E 27 CB             stx     numrec          ;and save
   351 00:C36C: CA                   dex                     ;back down
   352 00:C36D: E0 7F        notful  cpx     #127            ;if not at max
   353 00:C36F: D0 0F                bne     noawex          ;skip extending
   354 00:C371: 20 D6 C5             jsr     updtrc          ;update record counters
  Mon Apr  3 2023 10:57                                                                                                    Page 27


   355 00:C374: 67 9E                rmb6    d65flg          ;set bit to zero for write
   356 00:C376: 20 20 C7             jsr     extend          ;file extension
   357 00:C379: D0 0A                bne     extwrt          ;exit
   358 00:C37B: A9 FF                lda     #255            ;else start counter
   359 00:C37D: 8D 26 CB             sta     nxtrec          ;at one short
   360 00:C380: 20 D6 C5     noawex  jsr     updtrc          ;then update counters
   361 00:C383: A9 00                lda     #0              ;good return
   362 00:C385: 60           extwrt  rts                     ;exit
   363                        ;
   364                        ;execute console input
   365 00:C386: 20 53 C8     xcnsin  jsr     getcon          ;get input
   366 00:C389: 20 82 C8             jsr     tstchr          ;test it and
   367 00:C38C: 90 05                bcc     extxci          ;if control exit
   368 00:C38E: 48                   pha                     ;else save
   369 00:C38F: 20 D0 C8             jsr     sndchr          ;echo
   370 00:C392: 68                   pla                     ;restore
   371 00:C393: 60           extxci  rts                     ;return
   372                        ;
   373                        ;switch memory
   374                        ;page zero block begins at pzstrt and is numvar bytes long.
   375 00:C394: A2 05        switch  ldx     #numvar-1       ;get number to switch
   376 00:C396: B5 98        nxtswh  lda     pzstrt,x        ;get zero page
   377 00:C398: BC 45 CB             ldy     varblk,x        ;and save area
   378 00:C39B: 9D 45 CB             sta     varblk,x        ;save zero
   379 00:C39E: 94 98                sty     pzstrt,x        ;and high
   380 00:C3A0: CA                   dex                     ;count down
   381 00:C3A1: 10 F3                bpl     nxtswh          ;and loop until done
   382 00:C3A3: 60                   rts                     ;then return
   383                        ;
   384                        ;change dma address
   385                        ; input:addinp=address
   386                        ; returns:none
   387                        ; alters:all
   388 00:C3A4: A5 98        chgdma  lda     addinp          ;get low
   389 00:C3A6: A4 99                ldy     addinp+1        ;and high address
   390 00:C3A8: 85 9A                sta     bufadd          ;then store
   391 00:C3AA: 84 9B                sty     bufadd+1        ;in address
   392 00:C3AC: 4C 24 CC             jmp     simram+36       ;then go to sim
   393                        ;
   394                        ;automatic drive select
   395                        ; input:(addinp) 0=no change
   396                        ; 1-8 or 'A'-'H' = change
   397                        ; returns:none
   398                        ; alters:all
   399 00:C3AF: B2 98        autodr  lda     (addinp)        ;first byte of fcb
   400 00:C3B1: F0 11                beq     qtatdr          ;if 0 skip drive set
   401 00:C3B3: 3A                   dec     a               ;subtract one
   402 00:C3B4: 29 07                and     #%00000111      ;look at lower 3 bits
   403 00:C3B6: 8D 07 CB             sta     drvcmd          ;make parameter for CHGDRV
   404 00:C3B9: AD 1B CB             lda     curdrv          ;get current
   405 00:C3BC: 8D 1A CB             sta     olddrv          ;and save
   406 00:C3BF: B2 98                lda     (addinp)        ;get fcb entry
   407 00:C3C1: 8D 13 CB             sta     tmpdrv          ;and save as flag
   408 00:C3C4: AD 08 CB     qtatdr  lda     usrcde          ;get user code
   409 00:C3C7: 92 98                sta     (addinp)        ;save in byte zero in fcb
   410 00:C3C9: 20 D8 C3             jsr     chgdrv          ;change the drive
   411 00:C3CC: D7 9E                smb5    d65flg          ;set drive flag bit
   412 00:C3CE: 60           drvsme  rts
   413                        ;
   414                        ;change drive
   415                        ; input:addinp
   416                        ; returns:none
   417                        ; alters:all
  Mon Apr  3 2023 10:57                                                                                                    Page 28


   418 00:C3CF: A5 98        xchgdr  lda     addinp          ;get inout
   419 00:C3D1: C9 08                cmp     #maxdrv         ;check valid maxdrv range
   420 00:C3D3: B0 10                bcs     drnger          ;if over, send range error
   421 00:C3D5: 8D 07 CB             sta     drvcmd          ;and save
   422 00:C3D8: AD 07 CB     chgdrv  lda     drvcmd          ;get input
   423 00:C3DB: CD 1B CB             cmp     curdrv          ;if same as current
   424 00:C3DE: F0 EE                beq     drvsme          ;do nothing
   425 00:C3E0: 8D 1B CB             sta     curdrv          ;else change current
   426 00:C3E3: 80 18                bra     mapdrv          ;then log it in
   427                        ;
   428 00:C3E5: A9 DE        drnger  lda     #<rngmsg        ;point to
   429 00:C3E7: A0 CA                ldy     #>rngmsg        ;select message
   430 00:C3E9: 20 91 C8             jsr     sndstr          ;and send it
   431 00:C3EC: 4C A8 C1             jmp     xwboot          ;and abort
   432                        ;
   433                        ;execute initialize system
   434                        ; input:none
   435                        ; returns:none
   436                        ; alters:all,lginvc,bufadd
   437 00:C3EF: 9C 1C CB     xintds  stz     lginvc          ;clear log in status
   438 00:C3F2: A9 28                lda     #<dflbuf        ;get default buffer
   439 00:C3F4: A0 01                ldy     #>dflbuf        ;address
   440 00:C3F6: 85 98                sta     addinp          ;and set up
   441 00:C3F8: 84 99                sty     addinp+1        ;parameters
   442 00:C3FA: 20 A4 C3             jsr     chgdma          ;change address
   443                        ;
   444                        ;log in drive, set pointers and maps
   445                        ; input:curdrv
   446                        ; returns:none
   447                        ; alters:all
   448 00:C3FD: AD 1B CB     mapdrv  lda     curdrv          ;if current drive
   449 00:C400: C9 08                cmp     #maxdrv         ;check valid maxdrv range
   450 00:C402: 90 0D                bcc     vlddrv          ;then log it in
   451 00:C404: 20 43 C8     drserr  jsr     errout          ;send error message
   452 00:C407: A9 CD                lda     #<sltmsg        ;point to
   453 00:C409: A0 CA                ldy     #>sltmsg        ;select message
   454 00:C40B: 20 91 C8             jsr     sndstr          ;and send it
   455 00:C40E: 4C A8 C1             jmp     xwboot          ;and abort
   456 00:C411: 20 1B CC     vlddrv  jsr     simram+27       ;go to sim to set
   457 00:C414: 8D 22 C4             sta     cptdcb+1        ;save
   458 00:C417: 8C 23 C4             sty     cptdcb+2
   459 00:C41A: 0D 23 C4             ora     cptdcb+2        ;see if invalid
   460 00:C41D: F0 E5                beq     drserr          ;error if is
   461                        ;capture dcb
   462 00:C41F: A0 0A                ldy     #11-1           ;do 11 bytes (new DCB)
   463 00:C421: B9 FF FF     cptdcb  lda     $FFFF,y         ;get value from sim
   464 00:C424: 99 38 CB             sta     dcb,y           ;store it
   465 00:C427: 88                   dey
   466 00:C428: 10 F7                bpl     cptdcb          ;loop for more
   467 00:C42A: AD 3E CB             lda     blkscd          ;get block size code
   468 00:C42D: A8                   tay                     ;save in y
   469 00:C42E: 18                   clc
   470 00:C42F: 69 03                adc     #3              ;convert to sxb
   471 00:C431: 8D 32 CB             sta     sxb             ;and save
   472 00:C434: B9 02 CB             lda     sabtbl,y        ;get sab
   473 00:C437: 8D 31 CB             sta     sab             ;and set
   474 00:C43A: AD 3F CB             lda     maxdir          ;get max dir
   475 00:C43D: 8D 2F CB             sta     maxdrc          ;set max dir record
   476 00:C440: AD 40 CB             lda     maxdir+1
   477 00:C443: 4A                   lsr     a               ;divide by 4
   478 00:C444: 6E 2F CB             ror     maxdrc
   479 00:C447: 4A                   lsr     a
   480 00:C448: 6E 2F CB             ror     maxdrc
  Mon Apr  3 2023 10:57                                                                                                    Page 29


   481 00:C44B: 8D 30 CB             sta     maxdrc+1        ;then save high
   482 00:C44E: 77 9E                rmb7    d65flg          ;reset mode to byte
   483 00:C450: AD 39 CB             lda     maxblk+1        ;branch if max block
   484 00:C453: F0 03                beq     ntm255          ;not over 255
   485                        ; Y reg contains the block size code, which can be 0,
   486                        ; so the initial comment about it being an error is not
   487                        ; correct, so nothing to handle here as an error.
   488                        ;
   489 00:C455: 88                   dey                     ;back up index
   490 00:C456: F7 9E                smb7    d65flg          ;set mode to word
   491 00:C458: B9 FF CA     ntm255  lda     exmtbl,y        ;get extent mask
   492 00:C45B: 8D 43 CB             sta     exm
   493 00:C45E: 38                   sec                     ;now calculate cexm1f
   494 00:C45F: A9 1F                lda     #31
   495 00:C461: F9 FF CA             sbc     exmtbl,y
   496 00:C464: 8D 44 CB             sta     cexm1f
   497 00:C467: AE 1B CB             ldx     curdrv          ;get drive as pointer
   498 00:C46A: BD F7 CA             lda     bitmap,x        ;get bit
   499 00:C46D: 2D 1C CB             and     lginvc          ;if logged in
   500 00:C470: D0 0B                bne     extstm          ;then exit
   501 00:C472: BD F7 CA             lda     bitmap,x        ;get bit back
   502 00:C475: 0D 1C CB             ora     lginvc          ;set in log-in
   503 00:C478: 8D 1C CB             sta     lginvc          ;and update
   504 00:C47B: 80 01                bra     flinal          ;then fill in maps
   505 00:C47D: 60           extstm  rts                     ;and return
   506                        ;
   507                        ;fill in allocation map
   508 00:C47E: 20 19 C8     flinal  jsr     setrw           ;set to read/write
   509 00:C481: AD 38 CB             lda     maxblk          ;divide max block by
   510 00:C484: 8D 36 CB             sta     gpcnt           ;eight to get max
   511 00:C487: AD 39 CB             lda     maxblk+1
   512                        ;
   513 00:C48A: 4A                   lsr     a               ;use a for speed
   514 00:C48B: 6E 36 CB             ror     gpcnt
   515 00:C48E: 4A                   lsr     a               ;use a for speed
   516 00:C48F: 6E 36 CB             ror     gpcnt
   517 00:C492: 4A                   lsr     a               ;use a for speed
   518 00:C493: 6E 36 CB             ror     gpcnt
   519                        ;
   520 00:C496: 8D 37 CB             sta     gpcnt+1         ;save high
   521 00:C499: EE 36 CB             inc     gpcnt           ;bump by one
   522 00:C49C: D0 03                bne     skpam
   523 00:C49E: EE 37 CB             inc     gpcnt+1         ;with carry
   524 00:C4A1: AD 41 CB     skpam   lda     alcmap          ;get map start
   525 00:C4A4: AC 42 CB             ldy     alcmap+1
   526 00:C4A7: 85 9C                sta     alcpnt          ;set pointer to start
   527 00:C4A9: 84 9D                sty     alcpnt+1
   528 00:C4AB: A9 00        clraml  lda     #0              ;clear byte
   529 00:C4AD: 92 9C                sta     (alcpnt)        ;put in map
   530 00:C4AF: E6 9C                inc     alcpnt          ;bump pointer
   531 00:C4B1: D0 02                bne     skpal
   532 00:C4B3: E6 9D                inc     alcpnt+1        ;with carry
   533 00:C4B5: AD 36 CB     skpal   lda     gpcnt           ;get low of count
   534 00:C4B8: D0 03                bne     skpgp           ;skip if not zero
   535 00:C4BA: CE 37 CB             dec     gpcnt+1         ;else drop high
   536 00:C4BD: CE 36 CB     skpgp   dec     gpcnt           ;always drop low
   537 00:C4C0: AD 36 CB             lda     gpcnt           ;test for zero
   538 00:C4C3: 0D 37 CB             ora     gpcnt+1
   539 00:C4C6: D0 E3                bne     clraml          ;loop if more
   540                        ;at this point complete map is cleared
   541 00:C4C8: AD 2F CB             lda     maxdrc          ;get low of max dir record
   542 00:C4CB: 8D 36 CB             sta     gpcnt
   543 00:C4CE: AD 30 CB             lda     maxdrc+1        ;high in a
  Mon Apr  3 2023 10:57                                                                                                    Page 30


   544 00:C4D1: AE 32 CB             ldx     sxb             ;set x according to block size
   545 00:C4D4: 4A           clcmdb  lsr     a               ;do division
   546 00:C4D5: 6E 36 CB             ror     gpcnt
   547 00:C4D8: CA                   dex
   548 00:C4D9: D0 F9                bne     clcmdb          ;until x is zero
   549 00:C4DB: 8D 37 CB             sta     gpcnt+1         ;set high
   550 00:C4DE: EE 36 CB             inc     gpcnt           ;then bump by one
   551 00:C4E1: D0 03                bne     skpgp2
   552 00:C4E3: EE 37 CB             inc     gpcnt+1
   553 00:C4E6: 8E 21 CB     skpgp2  stx     blknum          ;clear block number
   554 00:C4E9: 8E 22 CB             stx     blknum+1
   555 00:C4EC: AD 21 CB     fildal  lda     blknum          ;get block number
   556 00:C4EF: AC 22 CB             ldy     blknum+1
   557 00:C4F2: 20 AB C5             jsr     setblk          ;set bit
   558 00:C4F5: EE 21 CB             inc     blknum          ;bump block number
   559 00:C4F8: D0 03                bne     skpblk
   560 00:C4FA: EE 22 CB             inc     blknum+1
   561 00:C4FD: AD 36 CB     skpblk  lda     gpcnt           ;get low of count
   562 00:C500: D0 03                bne     skpgp3          ;skip if not zero
   563 00:C502: CE 37 CB             dec     gpcnt+1         ;else drop high
   564 00:C505: CE 36 CB     skpgp3  dec     gpcnt           ;always do low
   565 00:C508: AD 36 CB             lda     gpcnt           ;test for zero
   566 00:C50B: 0D 37 CB             ora     gpcnt+1
   567 00:C50E: D0 DC                bne     fildal          ;loop if more
   568                        ;at this point directory space is mapped
   569 00:C510: 20 61 C7             jsr     cldrnm          ;clear directory number
   570 00:C513: A2 01        fillpe  ldx     #1              ;parameter for fill
   571 00:C515: 20 4B C7             jsr     nxtdir          ;execute for next directory
   572 00:C518: 30 10                bmi     extfil          ;done if invalid
   573 00:C51A: AC 20 CB             ldy     subrec          ;get offset
   574 00:C51D: B1 9A                lda     (bufadd),y      ;get empty/valid flag
   575 00:C51F: C9 E5                cmp     #$E5            ;if empty
   576 00:C521: F0 F0                beq     fillpe          ;try next
   577 00:C523: A2 01                ldx     #1              ;parameter for fill in
   578 00:C525: 20 CB C7             jsr     mapdir          ;do directory map
   579 00:C528: 80 E9                bra     fillpe          ;then loop
   580 00:C52A: 60           extfil  rts                     ;return
   581                        ;
   582                        ;directory record set up
   583                        ; input:dirnum
   584                        ; returns:none
   585                        ; alters:all,recnum,dirrec
   586 00:C52B: AD 1F CB     drrcsu  lda     dirnum+1        ;move high dir number
   587 00:C52E: 8D 22 CB             sta     recnum+1        ;to record number
   588 00:C531: AD 1E CB             lda     dirnum          ;divide
   589 00:C534: 4E 22 CB             lsr     recnum+1        ;directory by four
   590 00:C537: 6A                   ror     a
   591 00:C538: 4E 22 CB             lsr     recnum+1
   592 00:C53B: 6A                   ror     a
   593 00:C53C: 8D 28 CB             sta     dirrec          ;and save
   594 00:C53F: 8D 21 CB             sta     recnum          ;set low record number
   595 00:C542: AD 22 CB             lda     recnum+1        ;get high
   596 00:C545: 8D 29 CB             sta     dirrec+1        ;and set
   597 00:C548: 9C 23 CB             stz     recnum+2
   598                        ;
   599                        ;new routine here for using Records
   600                        ; note that the SIM call has changed to xfer the requested Record
   601                        ;
   602                        ; input:recnum, resrec
   603                        ; returns:none
   604                        ; alters:all
   605                        ;
   606                        ; first check to see if there are reserved records for the drive
  Mon Apr  3 2023 10:57                                                                                                    Page 31


   607                        ; if yes, these need to be added into the calculated record number
   608                        ; and then sent to SIM.
   609                        ;
   610                        setrec
   611 00:C54B: AD 3C CB             lda     resrec          ;get the reserved record lo count
   612 00:C54E: 0D 3D CB             ora     resrec+1        ;or in hi count
   613 00:C551: D0 09                bne     addres          ;if non-zero, add in reserved records
   614                        ;
   615                        ; no reserved records are in the current DCB
   616                        ; just send the current record number to SIM
   617                        ;
   618 00:C553: AD 21 CB             lda     recnum          ;get record number lo
   619 00:C556: AC 22 CB             ldy     recnum+1        ;get record number hi
   620 00:C559: 4C 21 CC             jmp     simram+33       ;call sim to set requested record, return
   621                        ;
   622 00:C55C: 18           addres  clc                     ;clear carry for add
   623 00:C55D: AD 21 CB             lda     recnum          ;get lo record number
   624 00:C560: 6D 3C CB             adc     resrec          ;add reserved record lo number
   625 00:C563: 8D 14 CB             sta     simrec          ;save it to sim record
   626 00:C566: AD 22 CB             lda     recnum+1        ;get hi record number
   627 00:C569: 6D 3D CB             adc     resrec+1        ;add reserved record hi number
   628 00:C56C: 8D 15 CB             sta     simrec+1        ;save it to sim record
   629                        ;
   630 00:C56F: A8                   tay                     ;xfer record hi to Y reg
   631 00:C570: AD 14 CB             lda     simrec          ;get sim record lo
   632 00:C573: 4C 21 CC             jmp     simram+33       ;call sim to set requested record, return
   633                        ;
   634                        ;get block bit mask and index
   635                        ; input:a&y=block number
   636                        ; returns:a=bit mask
   637                        ; alters:all and alcpnt
   638 00:C576: 48           blkmsk  pha                     ;save block number
   639 00:C577: 84 9D                sty     alcpnt+1        ;including high
   640                        ;
   641 00:C579: 46 9D                lsr     alcpnt+1        ;shift high
   642 00:C57B: 6A                   ror     a
   643 00:C57C: 46 9D                lsr     alcpnt+1
   644 00:C57E: 6A                   ror     a
   645 00:C57F: 46 9D                lsr     alcpnt+1
   646 00:C581: 6A                   ror     a
   647                        ;
   648 00:C582: 18                   clc                     ;now add map start
   649 00:C583: 6D 41 CB             adc     alcmap
   650 00:C586: 85 9C                sta     alcpnt
   651 00:C588: A5 9D                lda     alcpnt+1
   652 00:C58A: 6D 42 CB             adc     alcmap+1
   653 00:C58D: 85 9D                sta     alcpnt+1
   654 00:C58F: 68                   pla                     ;get number back
   655 00:C590: 29 07                and     #%00000111      ;look at 3 lsbs
   656 00:C592: AA                   tax                     ;get
   657 00:C593: BD EF CA             lda     bitmsk,x        ;mask
   658 00:C596: 60                   rts                     ;and return
   659                        ;
   660                        ;test block
   661                        ; input:a&y=block number
   662                        ; returns:z=1 if unassigned
   663                        ;          =0 if assigned and bit in a is set
   664                        ; alters:all
   665 00:C597: 20 76 C5     tstblk  jsr     blkmsk          ;get mask and index
   666 00:C59A: 32 9C                and     (alcpnt)        ;mask with map entry
   667 00:C59C: 60                   rts                     ;then return
   668                        ;
   669                        ;alter block status
  Mon Apr  3 2023 10:57                                                                                                    Page 32


   670                        ; input:a&y=block number,x=1 if set
   671                        ;                         =0 if reset
   672                        ; returns:none
   673                        ; alters:all and allocation map
   674 00:C59D: E0 01        altalc  cpx     #1              ;if set
   675 00:C59F: F0 0A                beq     setblk          ;go do it
   676 00:C5A1: 20 76 C5     clrblk  jsr     blkmsk          ;else get mask
   677 00:C5A4: 49 FF                eor     #$FF            ;and complement
   678 00:C5A6: 32 9C                and     (alcpnt)        ;preserve others
   679 00:C5A8: 92 9C                sta     (alcpnt)        ;and save
   680 00:C5AA: 60                   rts                     ;then return
   681                        ;
   682 00:C5AB: 20 76 C5     setblk  jsr     blkmsk          ;get mask
   683 00:C5AE: 12 9C                ora     (alcpnt)        ;set bit
   684 00:C5B0: 92 9C                sta     (alcpnt)        ;and put back
   685 00:C5B2: 60                   rts                     ;then return
   686                        ;
   687                        ;set current drive to read only
   688                        ; input:curdrv,ronlst,bitmap
   689                        ; returns:none
   690                        ; alters:a,x,p and ronlst
   691 00:C5B3: AE 1B CB     setron  ldx     curdrv          ;get number
   692 00:C5B6: BD F7 CA             lda     bitmap,x        ;and get mask
   693 00:C5B9: 0C 1D CB             tsb     ronlst          ;set drive bit
   694 00:C5BC: 60                   rts                     ;then return
   695                        ;
   696                        ;check read/write status
   697                        ; input:curdrv,ronlst
   698                        ; returns:z=0 if r/o or z=1 if r/w
   699                        ; alters:a,x,p
   700 00:C5BD: AE 1B CB     chkron  ldx     curdrv          ;get current drive
   701 00:C5C0: BD F7 CA             lda     bitmap,x        ;get mask
   702 00:C5C3: 2D 1D CB             and     ronlst          ;and test status
   703 00:C5C6: 60                   rts
   704                        ;
   705                        ;initialize record counters from fcb
   706                        ; input:fcb@(addinp)
   707                        ; returns:none
   708                        ; alters:a,y,p,nxtrec,numrec
   709 00:C5C7: A0 20        inrcct  ldy     #32             ;next record offset
   710 00:C5C9: B1 98                lda     (addinp),y      ;get next record
   711 00:C5CB: 8D 26 CB             sta     nxtrec          ;and save
   712 00:C5CE: A0 0F                ldy     #15             ;number records offset
   713 00:C5D0: B1 98                lda     (addinp),y      ;get number
   714 00:C5D2: 8D 27 CB             sta     numrec          ;and save
   715 00:C5D5: 60                   rts                     ;and return
   716                        ;
   717                        ;update record counters in fcb
   718                        ; input:nxtrec,numrec
   719                        ; returns:none
   720                        ; alters:all,fcb@(addinp)
   721 00:C5D6: AE 26 CB     updtrc  ldx     nxtrec          ;get next record
   722 00:C5D9: E8                   inx                     ;bump it
   723 00:C5DA: 8A                   txa                     ;transfer
   724 00:C5DB: A0 20                ldy     #32             ;set offset
   725 00:C5DD: 91 98                sta     (addinp),y      ;and store in fcb
   726 00:C5DF: AD 27 CB             lda     numrec          ;get number
   727 00:C5E2: A0 0F                ldy     #15             ;and its offset
   728 00:C5E4: 91 98                sta     (addinp),y      ;and store
   729 00:C5E6: 60                   rts                     ;then return
   730                        ;
   731                        ;execute open file
   732 00:C5E7: 20 AF C3     xopen   jsr     autodr          ;auto drive select
  Mon Apr  3 2023 10:57                                                                                                    Page 33


   733                        ;
   734                        ;open file
   735                        ; input:fcb @ (addinp)
   736                        ; returns:n=1 if not found,a=dirmod (255 if not found)
   737                        ; alters:all
   738 00:C5EA: 20 49 C6     opnfle  jsr     fndf13          ;match all including extent
   739 00:C5ED: 30 32                bmi     extopn          ;done if not found
   740 00:C5EF: A9 0C                lda     #12             ;point to first char
   741 00:C5F1: 0D 20 CB             ora     subrec          ;add offset
   742 00:C5F4: A8                   tay                     ;make it a pointer
   743 00:C5F5: B1 9A        nxopmv  lda     (bufadd),y      ;get buffer contents
   744 00:C5F7: AA                   tax                     ;and save
   745 00:C5F8: 98                   tya                     ;save index
   746 00:C5F9: 29 1F                and     #%00011111      ;remove offset
   747 00:C5FB: A8                   tay                     ;back to index
   748 00:C5FC: 8A                   txa                     ;get byte back
   749 00:C5FD: 91 98                sta     (addinp),y      ;and store in fcb
   750 00:C5FF: 98                   tya                     ;get index
   751 00:C600: 0D 20 CB             ora     subrec          ;add offset back
   752 00:C603: A8                   tay                     ;and make index again
   753 00:C604: C8                   iny                     ;next position
   754 00:C605: 98                   tya                     ;if index
   755 00:C606: 29 1F                and     #%00011111      ;not gone past
   756 00:C608: D0 EB                bne     nxopmv          ;end then loop
   757                        ;now correct extent and max records
   758 00:C60A: A0 0C                ldy     #12             ;point at extent in fcb
   759 00:C60C: AD 0B CB             lda     savext          ;get save from search
   760 00:C60F: D1 98                cmp     (addinp),y      ;compare
   761 00:C611: F0 0B                beq     extsme          ;jump ahead if same
   762 00:C613: 91 98                sta     (addinp),y      ;else change extent
   763 00:C615: A9 80                lda     #128            ;assume fcb ext < dir ext
   764 00:C617: 90 01                bcc     fcbxls          ;jump ahead if true
   765 00:C619: 0A                   asl     a               ;clear a
   766 00:C61A: A0 0F        fcbxls  ldy     #15             ;point to max
   767 00:C61C: 91 98                sta     (addinp),y      ;and set
   768 00:C61E: AD 2A CB     extsme  lda     dirmod          ;else get number
   769 00:C621: 60           extopn  rts                     ;and return
   770                        ;
   771                        ;execute close file
   772 00:C622: 20 AF C3     xclose  jsr     autodr          ;auto drive select
   773                        ;
   774                        ;close file
   775                        ;if file is r/o then no actual close
   776                        ;operation is performed.
   777                        ; input:fcb @ (addinp)
   778                        ; returns:n=1 if not valid,a=dirmod (255 if invalid)
   779                        ; alters:all
   780 00:C625: 20 49 C6     clsfle  jsr     fndf13          ;match including extent
   781 00:C628: 30 1B                bmi     extcls          ;exit if not found
   782 00:C62A: 20 BD C5             jsr     chkron          ;see if r/o
   783 00:C62D: D0 13                bne     noclse          ;branch if is
   784                        ;now set flag to ensure directory extent and number of
   785                        ;records fields are only changed if necessary.
   786                        ;The decision to change is determined by whether or
   787                        ;not the system is closing an extent less than the
   788                        ;maximum extent in the directory entry. If that is
   789                        ;the case, the directory extent and number of record
   790                        ;fields are not changed.
   791 00:C62F: A0 0C                ldy     #12             ;get extent
   792 00:C631: B1 98                lda     (addinp),y
   793 00:C633: 48                   pha                     ;save it
   794 00:C634: 98                   tya                     ;now look in directory
   795 00:C635: 0D 20 CB             ora     subrec
  Mon Apr  3 2023 10:57                                                                                                    Page 34


   796 00:C638: A8                   tay
   797 00:C639: 68                   pla                     ;get extent back
   798 00:C63A: D1 9A                cmp     (bufadd),y
   799 00:C63C: 6E 09 CB             ror     skpdir          ;save result
   800                        ;now go do it
   801 00:C63F: 20 B1 C6             jsr     updtdr          ;update directory
   802 00:C642: AD 2A CB     noclse  lda     dirmod          ;get directory number
   803 00:C645: 60           extcls  rts                     ;and return
   804                        ;
   805                        ;execute find first match
   806 00:C646: 20 AF C3     xfndfr  jsr     autodr          ;auto drive select
   807 00:C649: A9 0D        fndf13  lda     #13             ;match including extent
   808                        ;search for first match
   809                        ; input:a=number char to match
   810                        ; returns:n=1 if invalid,a=dirmod (255 if invalid)
   811                        ; alters:all
   812 00:C64B: 48           frstsr  pha                     ;save number to match
   813 00:C64C: 20 61 C7             jsr     cldrnm          ;clear directory number to -1
   814 00:C64F: 68                   pla                     ;get number to match
   815                        ;search for directory match
   816                        ; input:a=number char to match
   817                        ; returns:n=1 if not found,a=dirmod (255 if invalid)
   818                        ; alters:all
   819 00:C650: 8D 24 CB     search  sta     chrcnt          ;save number
   820 00:C653: A2 00        newtry  ldx     #0              ;set for search
   821 00:C655: 9C 25 CB             stz     cmppnt          ;clear pointer
   822 00:C658: 20 4B C7             jsr     nxtdir          ;get next entry
   823 00:C65B: 30 37                bmi     exitsr          ;exit if not found
   824 00:C65D: AE 24 CB             ldx     chrcnt          ;get count
   825 00:C660: AC 25 CB     mremch  ldy     cmppnt          ;get pointer
   826 00:C663: EE 25 CB             inc     cmppnt          ;and bump
   827 00:C666: B1 98                lda     (addinp),y      ;get fcb entry
   828 00:C668: C0 0C                cpy     #12             ;see if at extent
   829 00:C66A: D0 13                bne     notaex          ;jump if not
   830 00:C66C: 8D 0B CB             sta     savext          ;save for later use
   831 00:C66F: 48                   pha                     ;save extent
   832 00:C670: 98                   tya                     ;change to directory
   833 00:C671: 0D 20 CB             ora     subrec          ;coordinates
   834 00:C674: A8                   tay
   835 00:C675: 68                   pla                     ;get extent back
   836 00:C676: 51 9A                eor     (bufadd),y      ;exclusive or with dir
   837 00:C678: 2D 44 CB             and     cexm1f          ;and with exm complement + 1f
   838 00:C67B: F0 11                beq     trynxt          ;ok if zero
   839 00:C67D: 80 D4                bra     newtry          ;else get next directory
   840 00:C67F: C9 3F        notaex  cmp     #'?'            ;if a ? then
   841 00:C681: F0 0B                beq     trynxt          ;is a match
   842 00:C683: 48                   pha                     ;save char
   843 00:C684: 98                   tya                     ;then add
   844 00:C685: 0D 20 CB             ora     subrec          ;offset to
   845 00:C688: A8                   tay                     ;make pointer
   846 00:C689: 68                   pla                     ;get char back
   847 00:C68A: D1 9A                cmp     (bufadd),y      ;if not same
   848 00:C68C: D0 C5                bne     newtry          ;try next directory
   849 00:C68E: CA           trynxt  dex                     ;else count number down
   850 00:C68F: D0 CF                bne     mremch          ;and loop if more
   851 00:C691: AD 2A CB             lda     dirmod          ;return with directory
   852 00:C694: 60           exitsr  rts                     ;number mod 4
   853                        ;
   854                        ;calculate logical record number
   855                        ; input:blknum
   856                        ; returns:none
   857                        ; alters:a,x,p,recnum
   858 00:C695: AE 32 CB     calrcn  ldx     sxb             ;set x according to blkscd
  Mon Apr  3 2023 10:57                                                                                                    Page 35


   859 00:C698: 0E 21 CB     mulmre  asl     blknum          ;multiply block
   860 00:C69B: 2E 22 CB             rol     blknum+1        ;number
   861 00:C69E: 2E 23 CB             rol     blknum+2
   862 00:C6A1: CA                   dex                     ;by code
   863 00:C6A2: D0 F4                bne     mulmre
   864 00:C6A4: AD 31 CB             lda     sab             ;set mask in a
   865 00:C6A7: 2D 26 CB             and     nxtrec          ;and with next record
   866 00:C6AA: 0D 21 CB             ora     recnum          ;or with number
   867 00:C6AD: 8D 21 CB             sta     recnum          ;and save
   868 00:C6B0: 60                   rts
   869                        ;
   870                        ;update directory
   871 00:C6B1: A9 20        updtdr  lda     #32             ;change all
   872 00:C6B3: A2 00                ldx     #0              ;from start
   873                        ;
   874                        ;change directory entry
   875                        ; input:a=number char to change,x=starting position,fcb@(addinp)
   876                        ; returns:none
   877                        ; alters:all,directory,checksums
   878 00:C6B5: 8D 24 CB     dirchg  sta     chrcnt          ;save count
   879 00:C6B8: CE 24 CB             dec     chrcnt          ;back up
   880 00:C6BB: 18           mrechg  clc                     ;clear carry
   881 00:C6BC: 8A                   txa                     ;get offset
   882 00:C6BD: 6D 24 CB             adc     chrcnt          ;compute index
   883 00:C6C0: A8                   tay                     ;and set
   884 00:C6C1: C0 0C                cpy     #12             ;see if at extent
   885 00:C6C3: F0 04                beq     docare          ;if so do special
   886 00:C6C5: C0 0F                cpy     #15             ;see if at number rec
   887 00:C6C7: D0 05                bne     dntcar          ;if not skip
   888 00:C6C9: 2C 09 CB     docare  bit     skpdir          ;check flag
   889 00:C6CC: 10 0D                bpl     nochng          ;skip if ok
   890 00:C6CE: B1 98        dntcar  lda     (addinp),y      ;get char
   891 00:C6D0: 48                   pha                     ;save it
   892 00:C6D1: AD 24 CB             lda     chrcnt          ;get count
   893 00:C6D4: 0D 20 CB             ora     subrec          ;add offset
   894 00:C6D7: A8                   tay                     ;make an index
   895 00:C6D8: 68                   pla                     ;get char back
   896 00:C6D9: 91 9A                sta     (bufadd),y      ;and put in buffer
   897 00:C6DB: CE 24 CB     nochng  dec     chrcnt          ;count down
   898 00:C6DE: 10 DB                bpl     mrechg          ;and loop
   899 00:C6E0: 20 2B C5             jsr     drrcsu          ;set it up
   900 00:C6E3: 4C 2A C8             jmp     wrtrec          ;write record
   901                        ;
   902                        ;execute create file
   903 00:C6E6: 20 AF C3     xmake   jsr     autodr          ;auto drive select
   904                        ;
   905                        ;create file
   906                        ; input:fcb@(addinp)
   907                        ; returns:n=1 if not valid,a=dirmod (255 if not valid)
   908                        ; alters:dirnum,dirmod,fcb@(addinp)
   909 00:C6E9: 20 07 C8     mkefle  jsr     tstron          ;test for r/o
   910 00:C6EC: A5 98                lda     addinp          ;save fcb
   911 00:C6EE: 48                   pha                     ;address
   912 00:C6EF: A5 99                lda     addinp+1        ;on
   913 00:C6F1: 48                   pha                     ;stack
   914 00:C6F2: A9 EE                lda     #<empty         ;then point
   915 00:C6F4: A0 CA                ldy     #>empty         ;to empty
   916 00:C6F6: 85 98                sta     addinp          ;dummy
   917 00:C6F8: 84 99                sty     addinp+1        ;fcb
   918 00:C6FA: A9 01                lda     #1              ;match only
   919 00:C6FC: 20 4B C6             jsr     frstsr          ;first char
   920 00:C6FF: 68                   pla                     ;restore
   921 00:C700: 85 99                sta     addinp+1        ;fcb
  Mon Apr  3 2023 10:57                                                                                                    Page 36


   922 00:C702: 68                   pla                     ;address
   923 00:C703: 85 98                sta     addinp          ;from stack
   924 00:C705: AD 2A CB             lda     dirmod          ;get number mod 4
   925 00:C708: 30 15                bmi     extmke          ;quit if not found
   926 00:C70A: A0 0D                ldy     #13             ;else set up
   927 00:C70C: A9 00                lda     #0              ;to clear
   928 00:C70E: 91 98        mkeagn  sta     (addinp),y      ;rest of
   929 00:C710: C8                   iny                     ;fcb
   930 00:C711: C0 21                cpy     #33             ;including next
   931 00:C713: D0 F9                bne     mkeagn          ;record
   932                        ;the next two lines ensure that the extent and
   933                        ;number of records fields are updated
   934 00:C715: 38                   sec
   935 00:C716: 6E 09 CB             ror     skpdir
   936 00:C719: 20 B1 C6             jsr     updtdr          ;update directory
   937 00:C71C: AD 2A CB             lda     dirmod          ;get number
   938 00:C71F: 60           extmke  rts                     ;and quit
   939                        ;
   940                        ;extend file
   941                        ; input:fcb@(addinp), x=1 read
   942                        ;                       0 write
   943                        ; d65flg bit 6 used instead of X reg.
   944                        ; calling routine sets flag bit before calling here.
   945 00:C720: 20 25 C6     extend  jsr     clsfle          ;close current extent
   946 00:C723: 30 25                bmi     extext          ;exit if not found
   947 00:C725: A0 0C                ldy     #12             ;else
   948 00:C727: B1 98                lda     (addinp),y      ;get extent
   949 00:C729: 1A                   inc     a               ;add one ;-)
   950 00:C72A: 29 1F                and     #%00011111      ;see if overflow
   951 00:C72C: F0 14                beq     exteof          ;eof if so
   952 00:C72E: 91 98                sta     (addinp),y      ;and save
   953 00:C730: 20 49 C6             jsr     fndf13          ;see if next extent exists
   954 00:C733: 10 08                bpl     opnext          ;if so open
   955 00:C735: EF 9E 12             bbs6    d65flg,extext   ;test extend flag, branch if write
   956 00:C738: 20 E9 C6     dwrtex  jsr     mkefle          ;create file
   957 00:C73B: 80 03                bra     tstext          ;and test
   958 00:C73D: 20 EA C5     opnext  jsr     opnfle          ;open
   959 00:C740: 10 03        tstext  bpl     extnok          ;continue if ok
   960 00:C742: A9 01        exteof  lda     #1              ;else set eof
   961 00:C744: 60                   rts                     ;and return
   962 00:C745: 20 C7 C5     extnok  jsr     inrcct          ;initialize counters
   963 00:C748: A9 00                lda     #0              ;good
   964 00:C74A: 60           extext  rts                     ;return
   965                        ;
   966                        ;set up next directory block
   967                        ; input:dirnum,x=1 for update checksum
   968                        ; returns:a=dirmod (255 if invalid),n=1 if invalid
   969                        ; alters:alll,dirnum,dirmod
   970 00:C74B: EE 1E CB     nxtdir  inc     dirnum          ;bump directory
   971 00:C74E: D0 03                bne     skpdr
   972 00:C750: EE 1F CB             inc     dirnum+1
   973 00:C753: AD 3F CB     skpdr   lda     maxdir          ;if not at limit continue
   974 00:C756: CD 1E CB             cmp     dirnum
   975 00:C759: AD 40 CB             lda     maxdir+1
   976 00:C75C: ED 1F CB             sbc     dirnum+1
   977 00:C75F: B0 0C                bcs     gtnxdr          ;then continue
   978                        ;
   979                        ;clear directory number to $FFFF
   980                        ; input:none
   981                        ; returns:a=$ff,n=1,z=0
   982                        ; alters:a,p,dirnum,dirmod
   983 00:C761: A9 FF        cldrnm  lda     #$FF            ;set to $FF
   984 00:C763: 8D 1E CB             sta     dirnum
  Mon Apr  3 2023 10:57                                                                                                    Page 37


   985 00:C766: 8D 1F CB             sta     dirnum+1
   986 00:C769: 8D 2A CB             sta     dirmod
   987 00:C76C: 60                   rts
   988                        ;
   989 00:C76D: AD 1E CB     gtnxdr  lda     dirnum          ;get low again
   990 00:C770: 29 03                and     #%00000011      ;look at 2 lsbs
   991 00:C772: 8D 2A CB             sta     dirmod          ;save mod 4
   992 00:C775: 0A                   asl     a               ;multiply
   993 00:C776: 0A                   asl     a               ;by
   994 00:C777: 0A                   asl     a               ;32 to
   995 00:C778: 0A                   asl     a               ;get pointer
   996 00:C779: 0A                   asl     a               ;offset
   997 00:C77A: 8D 20 CB             sta     subrec          ;and save
   998 00:C77D: F0 02                beq     getdir          ;if zero read new
   999 00:C77F: 80 06                bra     gotdir          ;and exit
  1000 00:C781: 20 2B C5     getdir  jsr     drrcsu          ;set up to read
  1001 00:C784: 20 23 C8             jsr     rderec          ;do read
  1002 00:C787: AD 2A CB     gotdir  lda     dirmod          ;and return
  1003 00:C78A: 60           exnxdr  rts                     ;with number
  1004                        ;
  1005                        ;get block number
  1006                        ; input:nxtrec,blmode,fcb@(addinp),sxb,exm
  1007                        ; returns:none
  1008                        ; alters:all,blknum
  1009 00:C78B: AE 32 CB     getblk  ldx     sxb             ;set x according to blkscd
  1010 00:C78E: AD 26 CB             lda     nxtrec          ;get next record
  1011 00:C791: 4A           gblp    lsr     a               ;divide by 2 x times
  1012 00:C792: CA                   dex
  1013 00:C793: D0 FC                bne     gblp
  1014 00:C795: 8D 21 CB             sta     blknum          ;save previous as temp
  1015                        ;use extent as offset but first use sxb to create param
  1016 00:C798: 38                   sec
  1017 00:C799: A9 08                lda     #8
  1018 00:C79B: ED 32 CB             sbc     sxb
  1019 00:C79E: AA                   tax
  1020                        ;now get extent from fcb
  1021 00:C79F: A0 0C                ldy     #12
  1022 00:C7A1: B1 98                lda     (addinp),y
  1023 00:C7A3: 2D 43 CB             and     exm             ;and with mask
  1024 00:C7A6: 4A                   lsr     a               ;shift with lsb to c
  1025 00:C7A7: 2A           gbxlp   rol     a               ;now go other way
  1026 00:C7A8: CA                   dex
  1027 00:C7A9: D0 FC                bne     gbxlp
  1028 00:C7AB: 18                   clc                     ;now add saved value
  1029 00:C7AC: 6D 21 CB             adc     blknum          ;back
  1030 00:C7AF: 7F 9E 01             bbr7    d65flg,blm2     ;test mode, branch if byte
  1031 00:C7B2: 0A                   asl     a               ;else times two
  1032 00:C7B3: 18           blm2    clc                     ;then add
  1033 00:C7B4: 69 10                adc     #16             ;offset into fcb
  1034 00:C7B6: 8D 0A CB             sta     fcbind          ;save for later
  1035 00:C7B9: A8                   tay                     ;set index
  1036 00:C7BA: B1 98                lda     (addinp),y      ;get number
  1037 00:C7BC: 8D 21 CB             sta     blknum          ;store
  1038 00:C7BF: C8                   iny
  1039 00:C7C0: A9 00                lda     #0              ;clear
  1040 00:C7C2: 7F 9E 02             bbr7    d65flg,blm3     ;test mode, branch if byte
  1041 00:C7C5: B1 98                lda     (addinp),y      ;else get high
  1042 00:C7C7: 8D 22 CB     blm3    sta     blknum+1        ;high byte
  1043 00:C7CA: 60                   rts                     ;and return
  1044                        ;
  1045                        ;change allocation map
  1046                        ; input:subrec,directory record @ (bufadd)
  1047                        ; returns:none
  Mon Apr  3 2023 10:57                                                                                                    Page 38


  1048                        ; alters:all,allocation map
  1049                        ;
  1050                        ; Note: the "gthibn" routine has been integrated
  1051                        ; into this routine. While it does take a few
  1052                        ; extra bytes of code space, it eliminates a pair
  1053                        ; of JSR/RTS sequences, improving performance.
  1054 00:C7CB: 18           mapdir  clc                     ;add 16 to
  1055 00:C7CC: AD 20 CB             lda     subrec          ;to subrec to point
  1056 00:C7CF: 69 10                adc     #16             ;to block number field
  1057 00:C7D1: A8                   tay                     ;make index
  1058 00:C7D2: 8C 2D CB     lpmpdr  sty     mpdrsy          ;save index
  1059 00:C7D5: DA                   phx                     ;save x operation
  1060 00:C7D6: B1 9A                lda     (bufadd),y      ;get block number
  1061 00:C7D8: 8D 2E CB             sta     mpdrtm          ;save in temp
  1062 00:C7DB: C8                   iny                     ;bump index for word
  1063                        ;
  1064                        ;get high part of block number if word (zero if byte)
  1065                        ; input:y=index to high,blmode,directory@(bufadd)+subrec
  1066                        ; returns:a=high part of block number
  1067                        ; alters:a,p,mpdrsy if word
  1068                        ;gthibn
  1069 00:C7DC: A9 00                lda     #0              ;preset for byte
  1070 00:C7DE: 7F 9E 05             bbr7    d65flg,mpdrnw   ;test mode, branch if byte
  1071 00:C7E1: B1 9A                lda     (bufadd),y      ;get high
  1072 00:C7E3: 8C 2D CB             sty     mpdrsy          ;alter y
  1073                        ;
  1074 00:C7E6: 0D 2E CB     mpdrnw  ora     mpdrtm          ;see if zero
  1075 00:C7E9: F0 11                beq     skpedr          ;skip if zero
  1076                        ;
  1077                        ;get high part of block number if word (zero if byte)
  1078                        ; input:y=index to high,blmode,directory@(bufadd)+subrec
  1079                        ; returns:a=high part of block number
  1080                        ; alters:a,p,mpdrsy if word
  1081                        ;gthibn
  1082 00:C7EB: A9 00                lda     #0              ;preset for byte
  1083 00:C7ED: 7F 9E 05             bbr7    d65flg,gthiex   ;test mode, branch if byte
  1084 00:C7F0: B1 9A                lda     (bufadd),y      ;get high
  1085 00:C7F2: 8C 2D CB             sty     mpdrsy          ;alter y
  1086                        ;
  1087 00:C7F5: A8           gthiex  tay                     ;move to y
  1088 00:C7F6: AD 2E CB             lda     mpdrtm          ;get low again
  1089 00:C7F9: 20 9D C5             jsr     altalc          ;else alter map
  1090 00:C7FC: FA           skpedr  plx                     ;get operation back
  1091 00:C7FD: AC 2D CB             ldy     mpdrsy          ;get index back
  1092 00:C800: C8                   iny                     ;bump it
  1093 00:C801: 98                   tya                     ;if still
  1094 00:C802: 29 0F                and     #%00001111      ;in field
  1095 00:C804: D0 CC                bne     lpmpdr          ;then loop
  1096 00:C806: 60                   rts                     ;else quit
  1097                        ;
  1098                        ;test r/w status
  1099                        ;does warm boot if r/o
  1100                        ; input:curdrv,ronlst
  1101                        ; returns:none
  1102                        ; alters:a,x,p
  1103 00:C807: 20 BD C5     tstron  jsr     chkron          ;test bit
  1104 00:C80A: F0 16                beq     exttro          ;exit if r/w
  1105 00:C80C: 20 43 C8             jsr     errout          ;else send error
  1106 00:C80F: A9 86                lda     #<romsg         ;point to r/o
  1107 00:C811: A0 CA                ldy     #>romsg         ;message
  1108 00:C813: 20 91 C8             jsr     sndstr          ;send it
  1109 00:C816: 4C A8 C1     wrerr   jmp     xwboot          ;then abort
  1110                        ;
  Mon Apr  3 2023 10:57                                                                                                    Page 39


  1111                        ;set current drive to r/w
  1112                        ; input:curdrv,ronlst
  1113                        ; returns:ronlst
  1114                        ; alters:a,x,p,ronlst
  1115 00:C819: AE 1B CB     setrw   ldx     curdrv          ;get drive
  1116 00:C81C: BD F7 CA             lda     bitmap,x        ;and mask
  1117 00:C81F: 1C 1D CB             trb     ronlst          ;reset drive bit
  1118 00:C822: 60           exttro  rts                     ;return
  1119                        ;
  1120                        ;read record
  1121 00:C823: 20 27 CC     rderec  jsr     simram+39       ;do read
  1122 00:C826: F0 FA                beq     exttro          ;done if A= zero
  1123 00:C828: 80 05                bra     rwerrt          ;else handle error
  1124                        ;
  1125                        ;write record
  1126 00:C82A: 20 2A CC     wrtrec  jsr     simram+42       ;do write
  1127 00:C82D: F0 F3        chkrwe  beq     exttro          ;done if A= zero
  1128                        ;
  1129                        ;read/write error
  1130 00:C82F: 20 43 C8     rwerrt  jsr     errout          ;send error message
  1131 00:C832: A9 93                lda     #<bdsmsg        ;point to
  1132 00:C834: A0 CA                ldy     #>bdsmsg        ;bad record message
  1133 00:C836: 20 91 C8             jsr     sndstr          ;and send
  1134 00:C839: 20 53 C8             jsr     getcon          ;get input
  1135 00:C83C: C9 0D                cmp     #cr             ;if a cr
  1136 00:C83E: D0 D6                bne     wrerr           ;if not cr, exit
  1137 00:C840: 4C 0E CA     ignerr  jmp     pcrlf           ;crlf and return
  1138                        ;
  1139                        ;error output routine
  1140                        ; input:curdrv,pemmvc
  1141                        ; returns:none
  1142                        ; alters:all
  1143 00:C843: A9 BD        errout  lda     #<pemmsg        ;point to
  1144 00:C845: A0 CA                ldy     #>pemmsg        ;error message
  1145 00:C847: 20 91 C8             jsr     sndstr          ;send it
  1146 00:C84A: AD 1B CB             lda     curdrv          ;get drive number
  1147 00:C84D: 18                   clc                     ;add
  1148 00:C84E: 69 41                adc     #'A'            ;ascii a
  1149 00:C850: 4C D0 C8             jmp     sndchr          ;and send it
  1150                        ;
  1151                        ;get console input
  1152                        ; input:pndkey
  1153                        ; returns:a=character
  1154                        ; alters:all,pndkey
  1155 00:C853: AD 0D CB     getcon  lda     pndkey          ;get pending key
  1156 00:C856: 9C 0D CB             stz     pndkey          ;clear pending key
  1157 00:C859: D0 26                bne     extkbd          ;exit if not null
  1158 00:C85B: 4C 09 CC             jmp     simram+9        ;else get new key, return
  1159                        ;
  1160                        ;check keyboard status
  1161                        ;handles <ctl-s> for freeze and <ctl-c> for boot
  1162                        ; input:pndkey
  1163                        ; returns:a=0 if no input or <>0 if input
  1164                        ; alters:all,pndkey
  1165 00:C85E: AD 0D CB     kbdsts  lda     pndkey          ;get pending key
  1166 00:C861: D0 1E                bne     extkbd          ;if there is one, exit
  1167 00:C863: 20 06 CC             jsr     simram+6        ;else check console status
  1168 00:C866: F0 19                beq     extkbd          ;if no character in console, exit
  1169 00:C868: 20 09 CC             jsr     simram+9        ;else get input from console
  1170 00:C86B: C9 13                cmp     #ctls           ;check for freeze
  1171 00:C86D: D0 0D                bne     newpnd          ;if not, save input
  1172 00:C86F: 20 09 CC             jsr     simram+9        ;else wait for next input
  1173 00:C872: C9 03                cmp     #ctlc           ;check for cancel
  Mon Apr  3 2023 10:57                                                                                                    Page 40


  1174 00:C874: D0 03                bne     nowarm          ;if not, then finish
  1175 00:C876: 4C A8 C1             jmp     xwboot          ;else do a warm boot
  1176 00:C879: A9 00        nowarm  lda     #0              ;clear
  1177 00:C87B: 60                   rts                     ;and return
  1178 00:C87C: 8D 0D CB     newpnd  sta     pndkey          ;save input
  1179 00:C87F: A9 FF                lda     #$FF            ;set ready
  1180 00:C881: 60           extkbd  rts                     ;and return
  1181                        ;
  1182                        ;test character
  1183                        ; input:a=character
  1184                        ; returns:c=0 if control or c=1 if printing
  1185                        ; alters:p
  1186 00:C882: C9 0D        tstchr  cmp     #cr             ;if cr
  1187 00:C884: F0 0A                beq     chtext          ;quit
  1188 00:C886: C9 0A                cmp     #lf             ;if linefeed
  1189 00:C888: F0 06                beq     chtext          ;quit
  1190 00:C88A: C9 09                cmp     #ctli           ;if tab
  1191 00:C88C: F0 02                beq     chtext          ;quit
  1192 00:C88E: C9 20                cmp     #' '            ;see if control
  1193 00:C890: 60           chtext  rts                     ;and return
  1194                        ;
  1195                        ;send string ending in $
  1196                        ; input:ay=string address
  1197                        ; returns:none
  1198                        ; alters:all,index,sndlpe+1 and +2
  1199 00:C891: 8D 9A C8     sndstr  sta     sndlpe+1        ;set pointer
  1200 00:C894: 8C 9B C8             sty     sndlpe+2
  1201 00:C897: A0 00                ldy     #0
  1202 00:C899: B9 FF FF     sndlpe  lda     $FFFF,y         ;get char
  1203 00:C89C: C9 24                cmp     #'$'            ;if terminator
  1204 00:C89E: F0 08                beq     sndext          ;then exit
  1205 00:C8A0: C8                   iny                     ;else bump
  1206 00:C8A1: 5A                   phy                     ;save index
  1207 00:C8A2: 20 D0 C8             jsr     sndchr          ;send char
  1208 00:C8A5: 7A                   ply                     ;restore index
  1209 00:C8A6: D0 F1                bne     sndlpe          ;and loop
  1210 00:C8A8: 60           sndext  rts                     ;return
  1211                        ;
  1212                        ;send char to printer if enabled
  1213                        ; input:a=character,lstflg
  1214                        ; returns:a=character
  1215                        ; alters:x,y,p
  1216                        ; ensure A reg is preserved by SIM routine!
  1217 00:C8A9: 2C 0E CB     lstout  bit     lstflg          ;test flag
  1218 00:C8AC: 10 FA                bpl     sndext          ;exit if off
  1219 00:C8AE: CF 9E F7             bbs4    d65flg,sndext   ;test out flag, branch if set
  1220 00:C8B1: 4C 0F CC             jmp     simram+15       ;send (dummy routine), return
  1221                        ;
  1222                        ;output a character
  1223                        ; input:a=character,console definition block in sim
  1224                        ; returns:none
  1225                        ; alters:all,positn
  1226 00:C8B4: 20 82 C8     output  jsr     tstchr          ;test it
  1227 00:C8B7: B0 17                bcs     sndchr          ;if not control jump
  1228 00:C8B9: 48                   pha                     ;else save
  1229 00:C8BA: AD 3B CC             lda     sysdef+4        ;get invert
  1230 00:C8BD: 20 E9 C8             jsr     nolist          ;send to console
  1231 00:C8C0: A9 5E                lda     #'^'            ;get arrow
  1232 00:C8C2: 20 A9 C8             jsr     lstout          ;send to printer
  1233 00:C8C5: 68                   pla                     ;get character
  1234 00:C8C6: 09 40                ora     #'A'-1          ;convert to ascii
  1235 00:C8C8: 20 E1 C8             jsr     pchrot          ;send to all
  1236 00:C8CB: AD 3A CC             lda     sysdef+3        ;get normal
  Mon Apr  3 2023 10:57                                                                                                    Page 41


  1237 00:C8CE: 80 19                bra     nolist          ;to console
  1238 00:C8D0: C9 09        sndchr  cmp     #ctli           ;if not tab
  1239 00:C8D2: D0 0D                bne     pchrot          ;send
  1240 00:C8D4: A9 20        tabspc  lda     #' '            ;else get space
  1241 00:C8D6: 20 E1 C8             jsr     pchrot          ;send
  1242 00:C8D9: AD 0F CB             lda     positn          ;get count
  1243 00:C8DC: 29 07                and     #7              ;if not mod 8
  1244 00:C8DE: D0 F4                bne     tabspc          ;loop
  1245 00:C8E0: 60                   rts                     ;else exit
  1246 00:C8E1: 48           pchrot  pha                     ;save char
  1247 00:C8E2: 20 5E C8             jsr     kbdsts          ;test input
  1248 00:C8E5: 68                   pla                     ;restore
  1249 00:C8E6: 20 A9 C8             jsr     lstout          ;to printer if on
  1250 00:C8E9: 48           nolist  pha                     ;save again
  1251 00:C8EA: CF 9E 03             bbs4    d65flg,no_oflg  ;test out flag, branch if set
  1252 00:C8ED: 20 0C CC             jsr     simram+12       ;send to console
  1253 00:C8F0: 68           no_oflg pla                     ;restore
  1254 00:C8F1: EE 0F CB             inc     positn          ;bump col
  1255 00:C8F4: C9 20                cmp     #' '            ;if space or more
  1256 00:C8F6: B0 24                bcs     extchr          ;is ok
  1257 00:C8F8: CD 39 CC             cmp     sysdef+2        ;also ok
  1258 00:C8FB: F0 1F                beq     extchr          ;if forward
  1259 00:C8FD: CE 0F CB             dec     positn          ;else drop back
  1260 00:C900: CD 37 CC             cmp     sysdef+0        ;see if bs
  1261 00:C903: D0 06                bne     tryotr          ;branch if not
  1262 00:C905: CE 0F CB             dec     positn          ;else drop again
  1263 00:C908: 30 0F                bmi     zrocol          ;zero if <0
  1264 00:C90A: 60                   rts                     ;else ok, return
  1265 00:C90B: C9 0D        tryotr  cmp     #cr             ;if a cr
  1266 00:C90D: F0 0A                beq     zrocol          ;clear col
  1267 00:C90F: CD 3E CC             cmp     sysdef+7        ;if a formfeed
  1268 00:C912: F0 05                beq     zrocol          ;also clear
  1269 00:C914: CD 3F CC             cmp     sysdef+8        ;if not home
  1270 00:C917: D0 03                bne     extchr          ;then done
  1271 00:C919: 9C 0F CB     zrocol  stz     positn          ;column
  1272 00:C91C: 60           extchr  rts                     ;and exit
  1273                        ;
  1274                        ;go to left and space past prompt
  1275                        ; input:frscol,positn
  1276                        ; returns:none
  1277                        ; alters:positn
  1278 00:C91D: A9 0D        spcovr  lda     #cr             ;get cr
  1279 00:C91F: 20 E1 C8             jsr     pchrot          ;send to all
  1280 00:C922: A9 0A                lda     #lf             ;send lf
  1281 00:C924: 20 A9 C8             jsr     lstout          ;only to printer
  1282 00:C927: AD 0C CB     mreovr  lda     frscol          ;get first
  1283 00:C92A: CD 0F CB             cmp     positn          ;see if there
  1284 00:C92D: F0 ED                beq     extchr          ;done if is
  1285 00:C92F: AD 39 CC             lda     sysdef+2        ;get forward
  1286 00:C932: 20 E9 C8             jsr     nolist          ;send it
  1287 00:C935: 80 F0                bra     mreovr          ;and loop
  1288                        ;
  1289                        ;buffered read
  1290                        ; input:buffer@(addinp)
  1291                        ; returns:none
  1292                        ; alters:all,buffer@(addinp)
  1293 00:C937: A9 00        bufinp  lda     #0              ;clear
  1294 00:C939: A0 01                ldy     #1              ;length
  1295 00:C93B: 91 98                sta     (addinp),y      ;position in buffer
  1296 00:C93D: 8C 12 CB             sty     bufpsn          ;set point to 1
  1297 00:C940: AD 0F CB             lda     positn          ;get current
  1298 00:C943: 8D 0C CB             sta     frscol          ;and save
  1299 00:C946: 20 53 C8     nxtinp  jsr     getcon          ;get input
  Mon Apr  3 2023 10:57                                                                                                    Page 42


  1300 00:C949: AC 12 CB             ldy     bufpsn          ;get index
  1301 00:C94C: C9 0D                cmp     #cr             ;if not a cr
  1302 00:C94E: D0 03                bne     notcr           ;then jump
  1303 00:C950: 4C 15 CA             jmp     endlin          ;else done
  1304 00:C953: C9 7F        notcr   cmp     #delete         ;if not delete
  1305 00:C955: D0 59                bne     ntdelt          ;then jump
  1306 00:C957: C0 01                cpy     #1              ;else if start
  1307 00:C959: F0 EB                beq     nxtinp          ;then loop
  1308 00:C95B: B1 98                lda     (addinp),y      ;get last
  1309 00:C95D: 48                   pha                     ;save char
  1310 00:C95E: A0 01                ldy     #1              ;point to count
  1311 00:C960: 38                   sec                     ;set carry
  1312 00:C961: B1 98                lda     (addinp),y      ;get count
  1313 00:C963: E9 01                sbc     #1              ;decrement
  1314 00:C965: 91 98                sta     (addinp),y      ;then save
  1315 00:C967: 68                   pla                     ;restore char
  1316 00:C968: CE 12 CB             dec     bufpsn          ;backup pointer
  1317 00:C96B: C9 20                cmp     #' '            ;if space or more
  1318 00:C96D: B0 3C                bcs     nrmbs           ;just backspace
  1319 00:C96F: C9 09                cmp     #ctli           ;see if tab
  1320 00:C971: D0 2C                bne     ctlbs           ;if not is control
  1321 00:C973: C7 9E                smb4    d65flg          ;set out flag bit
  1322 00:C975: AD 0F CB             lda     positn          ;get position and save
  1323 00:C978: 8D 2C CB             sta     lstcol
  1324 00:C97B: 20 1D C9             jsr     spcovr          ;else go back
  1325 00:C97E: 20 18 CA             jsr     rptlne          ;and retype
  1326 00:C981: AD 0F CB             lda     positn          ;get new last position
  1327 00:C984: 48                   pha                     ;save on stack
  1328 00:C985: 38                   sec                     ;subtract to get delta
  1329 00:C986: AD 2C CB             lda     lstcol
  1330 00:C989: ED 0F CB             sbc     positn
  1331 00:C98C: 8D 2C CB             sta     lstcol          ;and save
  1332 00:C98F: 47 9E                rmb4    d65flg          ;clear out flag bit
  1333 00:C991: 20 36 CA     bstab   jsr     dobs            ;do one
  1334 00:C994: CE 2C CB             dec     lstcol          ;drop count
  1335 00:C997: D0 F8                bne     bstab           ;loop if more
  1336 00:C999: 68                   pla                     ;get position
  1337 00:C99A: 8D 0F CB             sta     positn          ;and set
  1338 00:C99D: 80 A7                bra     nxtinp          ;then loop
  1339 00:C99F: AD 3A CC     ctlbs   lda     sysdef+3        ;get normal
  1340 00:C9A2: 20 32 CA             jsr     chkbs           ;bs if printing
  1341 00:C9A5: AD 3B CC             lda     sysdef+4        ;same for invert
  1342 00:C9A8: 20 32 CA             jsr     chkbs           ;then delete char itself
  1343 00:C9AB: 20 36 CA     nrmbs   jsr     dobs            ;do a backspace
  1344 00:C9AE: 80 96                bra     nxtinp          ;and loop
  1345 00:C9B0: C9 10        ntdelt  cmp     #ctlp           ;if not ctl-p
  1346 00:C9B2: D0 0A                bne     ntctlp          ;then jump
  1347 00:C9B4: AD 0E CB             lda     lstflg          ;else get printer flag
  1348 00:C9B7: 49 FF                eor     #$FF            ;complement
  1349 00:C9B9: 8D 0E CB             sta     lstflg          ;save
  1350 00:C9BC: 80 88                bra     nxtinp          ;and loop
  1351 00:C9BE: C9 18        ntctlp  cmp     #ctlx           ;if not ctl-x
  1352 00:C9C0: D0 0C                bne     ntctlx          ;then jump
  1353 00:C9C2: 20 1D C9             jsr     spcovr          ;restart
  1354 00:C9C5: AD 38 CC             lda     sysdef+1        ;get clear to eol
  1355 00:C9C8: 20 E9 C8             jsr     nolist          ;send it
  1356 00:C9CB: 4C 37 C9             jmp     bufinp          ;and start over
  1357 00:C9CE: C9 12        ntctlx  cmp     #ctlr           ;if not ctl-r
  1358 00:C9D0: D0 09                bne     ntctlr          ;then jump
  1359 00:C9D2: 20 1D C9             jsr     spcovr          ;restart
  1360 00:C9D5: 20 18 CA             jsr     rptlne          ;retype line
  1361 00:C9D8: 4C 46 C9             jmp     nxtinp          ;and start over
  1362 00:C9DB: C8           ntctlr  iny                     ;next position
  Mon Apr  3 2023 10:57                                                                                                    Page 43


  1363 00:C9DC: 91 98                sta     (addinp),y      ;store char
  1364 00:C9DE: 48                   pha                     ;and save
  1365 00:C9DF: 8C 12 CB             sty     bufpsn          ;index
  1366 00:C9E2: A0 01                ldy     #1              ;point to count
  1367 00:C9E4: 98                   tya                     ;set a to 1
  1368 00:C9E5: 18                   clc                     ;then
  1369 00:C9E6: 71 98                adc     (addinp),y      ;add count
  1370 00:C9E8: 91 98                sta     (addinp),y      ;and save
  1371 00:C9EA: 68                   pla                     ;restore char
  1372 00:C9EB: 20 B4 C8     dontsv  jsr     output          ;send char
  1373 00:C9EE: AC 12 CB             ldy     bufpsn          ;get index
  1374 00:C9F1: B1 98                lda     (addinp),y      ;get char
  1375 00:C9F3: C9 03                cmp     #ctlc           ;if not ctl-c
  1376 00:C9F5: D0 0B                bne     ignrcc          ;ignore
  1377 00:C9F7: A0 01                ldy     #1              ;get count
  1378 00:C9F9: B1 98                lda     (addinp),y      ;from buffer
  1379 00:C9FB: C9 01                cmp     #1              ;if not at start
  1380 00:C9FD: D0 03                bne     ignrcc          ;ignore
  1381 00:C9FF: 4C A8 C1             jmp     xwboot          ;else do warm boot
  1382 00:CA02: A0 01        ignrcc  ldy     #1              ;get
  1383 00:CA04: B1 98                lda     (addinp),y      ;count
  1384 00:CA06: 88                   dey                     ;point to max
  1385 00:CA07: D1 98                cmp     (addinp),y      ;if length
  1386 00:CA09: B0 08                bcs     lineen          ;at max jump
  1387 00:CA0B: 4C 46 C9             jmp     nxtinp          ;else loop
  1388                        ;
  1389                        ;lf and cr
  1390 00:CA0E: A9 0A        pcrlf   lda     #lf             ;then a
  1391 00:CA10: 20 E1 C8             jsr     pchrot          ;lf
  1392 00:CA13: A9 0D        lineen  lda     #cr             ;and a
  1393 00:CA15: 4C E1 C8     endlin  jmp     pchrot          ;cr
  1394                        ;
  1395                        ;retype line
  1396 00:CA18: AD 12 CB     rptlne  lda     bufpsn          ;get pointer
  1397 00:CA1B: 8D 2B CB             sta     numcnt          ;save as count
  1398 00:CA1E: A9 01                lda     #1              ;set start position
  1399 00:CA20: 48                   pha                     ;save to stack
  1400 00:CA21: 68           mrerpt  pla                     ;get position (from stack)
  1401 00:CA22: CE 2B CB             dec     numcnt          ;count down
  1402 00:CA25: D0 01                bne     retym           ;continue if more
  1403 00:CA27: 60                   rts                     ;else done
  1404 00:CA28: A8           retym   tay                     ;else make index
  1405 00:CA29: C8                   iny                     ;and bump
  1406 00:CA2A: 5A                   phy                     ;save on stack
  1407 00:CA2B: B1 98                lda     (addinp),y      ;get char
  1408 00:CA2D: 20 B4 C8             jsr     output          ;send
  1409 00:CA30: 80 EF                bra     mrerpt          ;and loop
  1410                        ;check for printing and backspace if needed
  1411 00:CA32: C9 20        chkbs   cmp     #' '            ;compare to space
  1412 00:CA34: 90 19                bcc     extdec          ;not printing so done
  1413                        ;do a backspace
  1414 00:CA36: AD 37 CC     dobs    lda     sysdef+0        ;get backspace
  1415 00:CA39: 48                   pha                     ;save it
  1416 00:CA3A: 20 E9 C8             jsr     nolist          ;send
  1417 00:CA3D: A9 20                lda     #' '            ;get space
  1418 00:CA3F: 20 E9 C8             jsr     nolist          ;send
  1419 00:CA42: 68                   pla                     ;get backspace
  1420 00:CA43: 4C E9 C8             jmp     nolist          ;send it
  1421                        ;
  1422                        ;test for decimal digit
  1423                        ;if decimal then c=0 else c=1
  1424 00:CA46: C9 30        tstdec  cmp     #'0'            ;if under 0
  1425 00:CA48: 90 04                bcc     notdec          ;then not decimal
  Mon Apr  3 2023 10:57                                                                                                    Page 44


  1426 00:CA4A: C9 3A                cmp     #'9'+1          ;if 9 or under is ok
  1427 00:CA4C: 90 01                bcc     extdec
  1428 00:CA4E: 38           notdec  sec                     ;else not a match
  1429 00:CA4F: 60           extdec  rts
  1430                        ;
  1431                        ;test for hexadecimal digit
  1432                        ;if hex then c=0 else c=1
  1433                        tsthex
  1434 00:CA50: C9 30                cmp     #'0'            ;if under 0
  1435 00:CA52: 90 FA                bcc     notdec          ;then not hexidecimal
  1436 00:CA54: C9 41                cmp     #'A'            ;if undr A
  1437 00:CA56: 90 F6                bcc     notdec          ;then not hex
  1438 00:CA58: C9 47                cmp     #'F'+1          ;if F or under is ok
  1439 00:CA5A: 60                   rts                     ;return
  1440                        ;
  1441                        ;bump load address by 128 and return in ay
  1442 00:CA5B: AD DD C0     adjdb   lda     dskbuf          ;get old
  1443 00:CA5E: AC DE C0             ldy     dskbuf+1        ;address
  1444 00:CA61: 18                   clc                     ;and bump
  1445 00:CA62: 69 80                adc     #128            ;by 128
  1446 00:CA64: 8D DD C0             sta     dskbuf          ;save low
  1447 00:CA67: 90 04                bcc     adjend          ;then bump
  1448 00:CA69: C8                   iny                     ;and save
  1449 00:CA6A: 8C DE C0             sty     dskbuf+1        ;high as needed
  1450 00:CA6D: 60           adjend  rts
  1451                        ;
  1452                        ;move record from disk buffer to default buffer
  1453 00:CA6E: AD DD C0     mv128   lda     dskbuf          ;get address
  1454 00:CA71: AC DE C0             ldy     dskbuf+1
  1455 00:CA74: 8D 7D CA             sta     mvfrom+1        ;and set pointer
  1456 00:CA77: 8C 7E CA             sty     mvfrom+2
  1457 00:CA7A: A2 00                ldx     #0              ;clear index
  1458 00:CA7C: BD FF FF     mvfrom  lda     $FFFF,x         ;get byte
  1459 00:CA7F: 9D 28 01             sta     dflbuf,x        ;move it
  1460 00:CA82: E8                   inx
  1461 00:CA83: 10 F7                bpl     mvfrom          ;loop until done
  1462 00:CA85: 60                   rts
  1463                        ;
  1464                        ;messages
  1465 00:CA86: 3A 2C 20 52  romsg   .DB     ":, READ-ONLY$"
       00:CA8A: 45 41 44 2D 
       00:CA8E: 4F 4E 4C 59 
       00:CA92: 24 
  1466 00:CA93: 3A 2C 20 42  bdsmsg  .DB     ":, BAD BLOCK, <Ret> IGNORE, <Other> ABORT$"
       00:CA97: 41 44 20 42 
       00:CA9B: 4C 4F 43 4B 
       00:CA9F: 2C 20 3C 52 
       00:CAA3: 65 74 3E 20 
       00:CAA7: 49 47 4E 4F 
       00:CAAB: 52 45 2C 20 
       00:CAAF: 3C 4F 74 68 
       00:CAB3: 65 72 3E 20 
       00:CAB7: 41 42 4F 52 
       00:CABB: 54 24 
  1467 00:CABD: 0D 0A 50 45  pemmsg  .DB     cr,lf,"PEM ERROR on $"
       00:CAC1: 4D 20 45 52 
       00:CAC5: 52 4F 52 20 
       00:CAC9: 6F 6E 20 24 
  1468 00:CACD: 3A 2C 20 49  sltmsg  .DB      ":, INVALID DRIVE$"
       00:CAD1: 4E 56 41 4C 
       00:CAD5: 49 44 20 44 
       00:CAD9: 52 49 56 45 
       00:CADD: 24 
  Mon Apr  3 2023 10:57                                                                                                    Page 45


  1469 00:CADE: 0D 0A 55 4E  rngmsg  .DB     cr,lf,"UNKNOWN DRIVE$"
       00:CAE2: 4B 4E 4F 57 
       00:CAE6: 4E 20 44 52 
       00:CAEA: 49 56 45 24 
  1470                        ;
  1471                        ;dummy fcb
  1472 00:CAEE: E5           empty   .DB     $E5
  1473                        ;
  1474                        ;bit mask table
  1475 00:CAEF: 80 40 20 10  bitmsk  .DB     128,64,32,16,8,4,2,1
       00:CAF3: 08 04 02 01 
  1476                        ;
  1477                        ;bit map table
  1478 00:CAF7: 01 02 04 08  bitmap  .DB    1,2,4,8,16,32,64,128
       00:CAFB: 10 20 40 80 
  1479                        ;
  1480                        ;extent mask table (also uses 3 bytes in sabtbl)
  1481 00:CAFF: 00 01 03     exmtbl  .DB     0,1,3
  1482                        ;
  1483                        ;sab table
  1484 00:CB02: 07 0F 1F 3F  sabtbl  .DB     7,15,31,63,127
       00:CB06: 7F 
  1485                        ;
  1486                        ;variable storage
  1487 00:CB07: 00           drvcmd  .DB     0               ;new commanded drive
  1488 00:CB08: 00           usrcde  .DB     0               ;user code
  1489 00:CB09: 00           skpdir  .DB     0               ;positive if no change
  1490 00:CB0A: 00           fcbind  .DB     0               ;index to block number
  1491 00:CB0B: 00           savext  .DB     0               ;save extent
  1492 00:CB0C: 00           frscol  .DB     0               ;first col
  1493 00:CB0D: 00           pndkey  .DB     0               ;pending input
  1494 00:CB0E: 00           lstflg  .DB     0               ;printer flag
  1495 00:CB0F: 00           positn  .DB     0               ;print position
  1496 00:CB10: 00 00        addout  .DW     0               ;output address
  1497             0000CB10   bytout  .EQU    addout          ;output value
  1498 00:CB12: 00           bufpsn  .DB     0               ;input buffer position
  1499 00:CB13: 00           tmpdrv  .DB     0               ;temporary drive flag & number
  1500 00:CB14: 00 00        simrec  .DW     0               ;record number sent to SIM
  1501 00:CB16: 00 00        lkdown  .DW     0               ;down pnt. for block search
  1502 00:CB18: 00 00        lookup  .DW     0               ;up pnt. for block search
  1503 00:CB1A: 00           olddrv  .DB     0               ;old drive number
  1504 00:CB1B: 00           curdrv  .DB     0               ;current drive
  1505 00:CB1C: 00           lginvc  .DB     0               ;log in status
  1506 00:CB1D: 00           ronlst  .DB     0               ;read write status
  1507 00:CB1E: 00 00        dirnum  .DW     0               ;directory number
  1508 00:CB20: 00           subrec  .DB     0               ;directory offset
  1509 00:CB21: 00 00        recnum  .DW     0               ;record number
  1510             0000CB21   blknum  .EQU    recnum          ;block number
  1511 00:CB23: 00                   .DB     0               ;overflow
  1512 00:CB24: 00           chrcnt  .DB     0               ;character count
  1513 00:CB25: 00           cmppnt  .DB     0               ;comparison pointer
  1514 00:CB26: 00           nxtrec  .DB     0               ;next record
  1515 00:CB27: 00           numrec  .DB     0               ;number records
  1516 00:CB28: 00 00        dirrec  .DW     0               ;directory record
  1517 00:CB2A: 00           dirmod  .DB     0               ;directory mod 4
  1518 00:CB2B: 00           numcnt  .DB     0               ;counter
  1519 00:CB2C: 00           lstcol  .DB     0               ;last column
  1520 00:CB2D: 00           mpdrsy  .DB     0               ;save for y in mapdir
  1521 00:CB2E: 00           mpdrtm  .DB     0               ;temp in mapdir
  1522 00:CB2F: 00 00        maxdrc  .DW     0               ;max directory record
  1523 00:CB31: 00           sab     .DB     0               ;mask for block
  1524 00:CB32: 00           sxb     .DB     0               ;shift for block
  1525 00:CB33: 00 00 00     rtclk   .DB     0,0,0           ;real time clock
  Mon Apr  3 2023 10:57                                                                                                    Page 46


  1526 00:CB36: 00 00        gpcnt   .DW     0               ;gp counter
  1527                        ;
  1528                        ;following region is used to capture DCB
  1529                        ; Note: The Disk Control Block has been changed!
  1530                        ; As diskette and other track/sector devices are no longer
  1531                        ; used/supported, there's no need to use checksums. This
  1532                        ; saves 3 bytes per DCB and execution time.
  1533                        ;
  1534                        dcb
  1535 00:CB38: 00 00        maxblk  .DW     0               ;maximum block number
  1536 00:CB3A: 00 00        recblk  .DW     0               ;records per block
  1537 00:CB3C: 00 00        resrec  .DW     0               ;reserved records
  1538 00:CB3E: 00           blkscd  .DB     0               ;block size code
  1539 00:CB3F: 00 00        maxdir  .DW     0               ;maximum directory number
  1540 00:CB41: 00 00        alcmap  .DW     0               ;address of allocation map
  1541                        ;
  1542 00:CB43: 00           exm     .DB     0               ;extent mask
  1543 00:CB44: 00           cexm1f  .DB     0               ;exm complemented and 1f
  1544                        ;
  1545                        ;zero page save block
  1546                        ; Note: Per above, no checksum support is required, so we
  1547                        ; save two bytes of Page Zero space from the byte swap
  1548                        ; routine.
  1549                        ;
  1550                        varblk
  1551 00:CB45: 00 00        lowin   .DW     0               ;save addinp
  1552 00:CB47: 00 00                .DW     0               ;save bufadd
  1553 00:CB49: 00 00                .DW     0               ;save alcpnt
  1554                        ;
  1555                                end
   190                        ;
   191                                        .ORG    $/256*256+256           ;Align to Page address
   192                        ;
   193                                include         DOS65-SIM-V320.ASM      ;Include SIM Module
     1                        ;
     2                        ;DOS/65 system interface module (SIM)
     3                        ;Version 3.20 - RAM based
     4                        ;
     5                        ;This version is designed to work with the:
     6                        ;C02 Pocket SBC with RTC/CF-Card adapter:
     7                        ; - modified for 3.3V for MicroDrive, SC28L92 DUART and DS1511Y RTC
     8                        ;
     9                        ;Microdrive Disk configuration:
    10                        ; a 8MB
    11                        ; b 8MB
    12                        ; c 8MB
    13                        ; d 8MB
    14                        ; e 8MB
    15                        ; f 8MB
    16                        ; g 8MB
    17                        ; h 8MB
    18                        ;
    19                        ;This SIM version no longer uses Track/Sector parameters to access the Microdrive!
    20                        ; - All calls and paraneters from PEM are now based on Record numbers.
    21                        ; - Records are still set as 128-bytes per record.
    22                        ; - Record number is a 16-bit value (0-65,535), so an 8MB limit still exists.
    23                        ;
    24                        ;The Disk Control Block parameter table has been modified.
    25                        ; This is done to accomodate the change from Track/Sector parameters to records, and
    26                        ; eliminate the checksum table, as IDE and other nonremovable block devices don't require it.
    27                        ; The new DCB table entry is configured as:
    28                        ;
    29                        ; Note: example shows an 8MB drive setup.
  Mon Apr  3 2023 10:57                                                                                                    Page 47


    30                        ; - A total of 4096 blocks, where each block is 2048 bytes
    31                        ; - the number of records per physical block is 4 (4*128=512)
    32                        ; - the total number of reserved records is 256 (256*128=32,768 bytes)
    33                        ; - Note: Reserved Records must be a multiple of 4!
    34                        ;
    35                        ;     .DW     4079            ;max block number
    36                        ;     .DW     4               ;records per physical block (LBA)
    37                        ;     .DW     256             ;number of reserved records (OS Boot area)
    38                        ;     .DB     1               ;block size = 2048
    39                        ;     .DW     1023            ;max directory
    40                        ;     .DW     almpa           ;address of allocation map
    41                        ;
    42                        ;A modified PEM module is required to use this new SIM version.
    43                        ; PEM 3.20 also contains the changes for using Record numbers only!
    44                        ;
    45                        ;Note: This SIM version makes calls to the C02BIOS directly!
    46                        ; This results in a smaller code size and one less module to write and maintain.
    47                        ;
    48                        ;As this SIM supports a prototype C02 Pocket, the following devices exist:
    49                        ; - Microdrive - supports 8 drives at 8MB each
    50                        ; - Dual port UART - provides console and reader/punch functions
    51                        ; - Realtime Clock - not currently supported/used
    52                        ;
    53                        ;Note that this SIM version uses an additional 4-byte offset for LBA accesses!
    54                        ; - This is required due to being a bootable system. The Microdrive uses a Partition Record
    55                        ; - which will load the Boot Block from the active partition. The Boot Block and Boot Image are
    56                        ; - part of the allocated disk space that becomes the drive.
    57                        ;
    58                        ; - The Boot Block code will use the Load Header at the start of drive image to provide the offset
    59                        ; - to allocated space and update the Partition Offset variable in this SIM module (part_offset).
    60                        ; - This design allows the Boot Image to be easily moved to a new location on the drive and not
    61                        ; - have to worry about the disk access. Only the Boot Block needs to be updated.
    62                        ;
    63                        ;**************************************************************************************************
    64                        ;Include required constants/equates/tables for SIM to assemble
    65                        ;
    69                                LIST
    70                        ;
    71                        ;**************************************************************************************************
    72                        ;Fixed parameters
    73                        ;
    74             00000001   CLREOL          .EQU     1              ;clear to eol (ctrl-a)
    75             00000002   CLREOS          .EQU     2              ;clear to eos (ctrl-b)
    76             00000008   BS              .EQU     8              ;backspace (ctrl-h)
    77             0000001B   ESC             .EQU     $1B            ;escape character
    78                        ;
    79                        ;**************************************************************************************************
    80                        ;
    81                        ;Main program, Start of SIM
    82                        ; this is the cold start for DOS/65. The boot block code jumps to here.
    83                        ;
    84                        ; Note: The following calls are no longer needed or supported, but are still listed in SIM to
    85                        ;       maintain the SIM functions at the correct address offsets.
    86                        ;       Also, the Console Definition Table has a hard-coded section within SIM.
    87                        ;
    88                        ;       SIMRAM+24: Set Home Drive
    89                        ;       SIMRAM+30: Set Reserved Tracks
    90                        ;       SIMRAM+51: Translate Sector
    91                        ;
    92                        ; Set Home Drive is specific to diskette based media.
    93                        ; - As multiple drive letters now exist on a single block device, there's no need to
    94                        ;   tell the drive to go to home (which would be cylinder zero).
    95                        ; 
  Mon Apr  3 2023 10:57                                                                                                    Page 48


    96                        ; Reserved Records are defined in the updated Disk Control Block.
    97                        ; - SIM doesn't require any action based on reserved records. PEM uses this parameter
    98                        ;   from the DCB to calculate the correct Record to read or write.
    99                        ;
   100                        ; Translate Sectors is obsolete.
   101                        ; - There are no diskette drives supported in this version of DOS/65.
   102                        ;
   103                        ; Note: Printer Output is not supported, but could be using additional hardware if required.
   104                        ;
   105 00:CC00: 4C 80 CC     simram          jmp     sim_boot        ;cold start SIM-DOS/65  simram+0 (3)
   106 00:CC03: 4C E9 CC     sim_wboote      jmp     sim_wboot       ;warm boot DOS/65       simram+3 (3)
   107 00:CC06: 4C 29 CD                     jmp     mon_consts      ;check for input        simram+6 (3)
   108 00:CC09: 4C 2C CD                     jmp     mon_conrde      ;get input              simram+9 (3)
   109 00:CC0C: 4C 38 CD                     jmp     mon_conwrt      ;send to terminal       simram+12 (3)
   110 00:CC0F: 4C 41 CC                     jmp     dummy           ;printer output         simram+15 (3)
   111 00:CC12: 4C 3D CD                     jmp     mon_punch       ;punch output           simram+18 (3)
   112 00:CC15: 4C 40 CD                     jmp     mon_reader      ;reader input           simram+21 (3)
   113 00:CC18: 4C 41 CC                     jmp     dummy           ;set home drive         simram+24 (3)
   114 00:CC1B: 4C 43 CD                     jmp     sim_seldsk      ;select active disk     simram+27 (3)
   115 00:CC1E: 4C 41 CC                     jmp     dummy           ;set reserved tracks    simram+30 (2)
   116 00:CC21: 4C 66 CD                     jmp     sim_setrec      ;set record number      simram+33 (3)
   117 00:CC24: 4C 5F CD                     jmp     sim_setdma      ;set buffer address     simram+36 (3)
   118 00:CC27: 4C 6D CD                     jmp     sim_read        ;read PEM record        simram+39 (3)
   119 00:CC2A: 4C A0 CD                     jmp     sim_write       ;write PEM record       simram+42 (3)
   120 00:CC2D: A9 01                        lda     #1              ;printer always ready   simram+45 (2)
   121 00:CC2F: 60                           rts                     ; (6)
   122 00:CC30: A2 80                        ldx     #128            ;clock entry (disabled) simram+48 (2)
   123 00:CC32: 60                           rts                     ; (6)
   124 00:CC33: 4C 41 CC                     jmp     dummy           ;translate (obsolete)   simram+51 (2)
   125                        ;
   126                        ;console definition block
   127 00:CC36: 00                           .DB     0               ;scratch
   128 00:CC37: 08           sysdef          .DB     8               ;backspace
   129 00:CC38: 01                           .DB     1               ;clear to end of line
   130 00:CC39: 0C                           .DB     $0C             ;forward space
   131 00:CC3A: 00                           .DB     0               ;normal video
   132 00:CC3B: 5E                           .DB     '^'             ;invert video
   133 00:CC3C: 18                           .DB     24              ;lines per screen
   134 00:CC3D: 50                           .DB     80              ;char per line
   135 00:CC3E: 0C                           .DB     $0C             ;form feed
   136 00:CC3F: 1E                           .DB     $1E             ;home
   137 00:CC40: 02                           .DB     2               ;clear to end of screen
   138                        ;
   139 00:CC41: 60           dummy           rts                     ;dummy rts for unused SIM calls (6)
   140                        ;
   141                        ;SIM Messages
   142 00:CC42: 0D 0A 44 4F  sim_opnmsg      .DB     CR,LF,"DOS/65 Version 3.20"
       00:CC46: 53 2F 36 35 
       00:CC4A: 20 56 65 72 
       00:CC4E: 73 69 6F 6E 
       00:CC52: 20 33 2E 32 
       00:CC56: 30 
   143 00:CC57: 0D 0A 53 49                  .DB     CR,LF,"SIM Version 3.20",0
       00:CC5B: 4D 20 56 65 
       00:CC5F: 72 73 69 6F 
       00:CC63: 6E 20 33 2E 
       00:CC67: 32 30 00 
   144                        ;
   145 00:CC6A: 0D 0A 44 69  io_err_msg      .DB     CR,LF,"Disk I/O Error!",0
       00:CC6E: 73 6B 20 49 
       00:CC72: 2F 4F 20 45 
       00:CC76: 72 72 6F 72 
       00:CC7A: 21 00 
  Mon Apr  3 2023 10:57                                                                                                    Page 49


   146                        ;
   147 00:CC7C: 0D 0A 2A 00  warm_msg        .DB     CR,LF,"*",0
   148                        ;
   149                        ;Start of SIM cold boot
   150 00:CC80: 20 00 FF     sim_boot        jsr     b_ide_reset     ;Reset Microdrive (just in case) (6)
   151                        ;
   152 00:CC83: A9 42                        lda     #<sim_opnmsg    ;Point to message (2)
   153 00:CC85: A0 CC                        ldy     #>sim_opnmsg    ; (2)
   154 00:CC87: 20 5A E0                     jsr     m_promptr       ;Send it via C02 Monitor routine (6)
   155                        ;
   156 00:CC8A: A2 FF                        ldx     #$FF            ;Set stack pointer (2)
   157 00:CC8C: 9A                           txs                     ; to top of stack space (2)
   158                        ;
   159                        ; To improve Disk I/O performance, the partition offset will be added
   160                        ; to the drive offsets. This has to be a one-time calculation when
   161                        ; SIM is started, otherwise the disk offset will be added each time
   162                        ; SIM is reset, which doesn't work! This will take some additional
   163                        ; memory space, but saves execution time in the get_lba routine.
   164                        ; Once added in, the partition offset values below are zeroed out.
   165                        ;
   166 00:CC8D: A2 00                        ldx     #0              ;Zero index for drive offset (2)
   167 00:CC8F: A0 08                        ldy     #maxdrv         ;Load index for Max drive count (2)
   168                        drv_update_lp
   169 00:CC91: 18                           clc                     ;Clear carry for add (2)
   170 00:CC92: BD 84 CE                     lda     drv_offset+0,x  ;Get the drive offset (4)
   171 00:CC95: 6D A4 CE                     adc     part_offset+0   ;Add the partition offset (4)
   172 00:CC98: 9D 84 CE                     sta     drv_offset+0,x  ;Save it back (5)
   173                        ;
   174 00:CC9B: BD 85 CE                     lda     drv_offset+1,x  ;Get the drive offset (4)
   175 00:CC9E: 6D A5 CE                     adc     part_offset+1   ;Add the partition offset (4)
   176 00:CCA1: 9D 85 CE                     sta     drv_offset+1,x  ;Save it back (5)
   177                        ;
   178 00:CCA4: BD 86 CE                     lda     drv_offset+2,x  ;Get the drive offset (4)
   179 00:CCA7: 6D A6 CE                     adc     part_offset+2   ;Add the partition offset (4)
   180 00:CCAA: 9D 86 CE                     sta     drv_offset+2,x  ;Save it back (5)
   181                        ;
   182 00:CCAD: E8                           inx                     ;Increment drive offset (2)
   183 00:CCAE: E8                           inx                     ; by 4 bytes per drive (2)
   184 00:CCAF: E8                           inx                     ; (2)
   185 00:CCB0: E8                           inx                     ; (2)
   186                        ;
   187 00:CCB1: 88                           dey                     ;Decrement drive count (2)
   188 00:CCB2: D0 DD                        bne     drv_update_lp   ;Loop back for all drives (2/3)
   189                        ;
   190                        ; Now that all drive offsets have been updated with the partition offset,
   191                        ; we will zero out the partition offset data (which is in RAM) so that it
   192                        ; can't be added in again ;-) Ah... RAM based routines!
   193                        ;
   194 00:CCB4: 9C A4 CE                     stz     part_offset+0   ;Zero out Partition Offset (4)
   195 00:CCB7: 9C A5 CE                     stz     part_offset+1   ; (4)
   196 00:CCBA: 9C A6 CE                     stz     part_offset+2   ; (4)
   197 00:CCBD: 9C A7 CE                     stz     part_offset+3   ; (4)
   198                        ;
   199                        ;Initialize iostat - resets to user 0 and drive 0
   200                        ; Note: this can be changed to a specific drive/user if needed.
   201 00:CCC0: 9C 06 01                     stz     iostat          ;Clear I/O status (4)
   202                        ;
   203                        ;SIM Setup
   204                        ;First clear disk access flags
   205 00:CCC3: 64 9F                        stz     sim_recflg      ;Clear SIM record flag byte (3)
   206                        ;
   207                        ;Setup PEM entry in Page 1
   208                        ; note that a warm boot also branches here to finish up
  Mon Apr  3 2023 10:57                                                                                                    Page 50


   209                        sim_wsetup
   210 00:CCC5: A0 06                        ldy     #6              ;Set index to 6 (2)
   211 00:CCC7: B9 E2 CC     simset_lp       lda     sim_inttbl-1,y  ;Get SIM table data (4)
   212 00:CCCA: 99 FF 00                     sta     $0100-1,y       ;Store into page $01 PEM area (5)
   213 00:CCCD: 88                           dey                     ;Decrement index (2)
   214 00:CCCE: D0 F7                        bne     simset_lp       ;Loop until done (2/3)
   215                        ;
   216                        ;Setup default buffer for PEM (128 bytes)
   217                        sim_finish
   218 00:CCD0: A9 28                        lda     #<dflbuf        ;Get default buffer (2)
   219 00:CCD2: A0 01                        ldy     #>dflbuf        ; address (2)
   220 00:CCD4: 20 5F CD                     jsr     sim_setdma      ;then set DMA for DOS/65 (6)
   221                        ;
   222                        ;Setup the BIOS for the default host buffer and block count.
   223                        ; The BIOS reads or writes a single 512-byte block into it's own
   224                        ; Host Buffer. The SIM code calls the C02 Pocket BIOS for all hardware
   225                        ; access.
   226 00:CCD7: A9 00                        lda     #<hstbuf        ;Get host buffer address (2)
   227 00:CCD9: A0 06                        ldy     #>hstbuf        ; high byte (2)
   228 00:CCDB: A2 01                        ldx     #1              ;Block count =1 (2)
   229 00:CCDD: 20 15 FF                     jsr     b_ide_set_addr  ;Call BIOS (6)
   230                        ;
   231 00:CCE0: 4C 10 B8                     jmp     ccmram          ;Then jump to CCM to complete startup (3)
   232                        ;
   233                        ;Initialization table
   234 00:CCE3: 4C           sim_inttbl      .DB     $4C             ;JMP opcode
   235 00:CCE4: 03 CC                        .DW     sim_wboote      ;Warm Boot location
   236 00:CCE6: 4C                           .DB     $4C             ;JMP opcode
   237 00:CCE7: 00 C1                        .DW     pemram          ;PEM RAM location
   238                        ;
   239                        ;SIM Warm Boot - When any application exits, it should make a call to Warm Boot
   240                        ; the system. That call will be handled here. As CCM can be over-written by any
   241                        ; application to access additional memory if/when needed, the warm boot routine
   242                        ; is responsible for reloading CCM. With DOS/65, both CCM and PEM are reloaded by
   243                        ; default. As certain PEM routines are self-modifying and the PEM data is usually
   244                        ; heavily altered during all operations, perhaps that's why Richard is specifying
   245                        ; to reload it during a warm boot. SIM however, is NOT reloaded!
   246                        ;
   247                        ;NOTE: IOSTAT and hence the default drive/user are not altered by Warm Boot.
   248                        ; After CCM/PEM are reloaded, the current user/drive will be restored to the
   249                        ; same as before a warm boot was initiated.
   250                        ;
   251                        ;Clear out the user space in Page Zero, this can cause intermittant crashes on
   252                        ; warm start if leftover data from the last app is present.
   253                        ; Apps like the Basic Compiler and Runtime are good examples.
   254                        ; Granted, this is likely something specific in CCM, but clearing out page zero
   255                        ; is just a good idea and can be an aid in any application debugging.
   256                        ;
   257                        sim_wboot
   258 00:CCE9: A2 00                        ldx     #$00            ;zero index (2)
   259                        clr_pg0
   260 00:CCEB: 74 00                        stz     $00,x           ;clear page zero user space (4)
   261 00:CCED: E8                           inx                     ;increment index (2)
   262 00:CCEE: E0 98                        cpx     #pzstrt         ;check for end (2)
   263 00:CCF0: D0 F9                        bne     clr_pg0         ;loop back till done (2/3)
   264                        ;
   265 00:CCF2: A2 FF                        ldx     #$FF            ;set stack pointer (2)
   266 00:CCF4: 9A                           txs                     ;to top of stack - safety (2)
   267                        ;
   268                        ;Show a simple asterisk when a warm boot is executed
   269 00:CCF5: A9 7C                        lda     #<warm_msg      ;Point to message (2)
   270 00:CCF7: A0 CC                        ldy     #>warm_msg      ; (2)
   271 00:CCF9: 20 5A E0                     jsr     m_promptr       ;Send it (6)
  Mon Apr  3 2023 10:57                                                                                                    Page 51


   272                        ;
   273                        ;As this is a bootable version of DOS/65, we need to reload CCM and PEM from disk.
   274                        ; CCM, PEM and SIM are stored in the Reserved Records area of the bootable drive partition.
   275                        ; Note that this also includes the drive allocations maps, which are zeroed. This eliminates
   276                        ; the need to clear the allocation maps when the system is initially booted.
   277                        ;
   278                        ;The actual Cold Boot is handled by the Boot Record, which is loaded from the Drive.
   279                        ; This is the result of the Partition Loader loading and executing the active Boot Record.
   280                        ; All of this is setup outside of DOS/65 and SIM. A separate disk utility is used to setup
   281                        ; the drive and load the DOS/65 code to the drive in the reserved area of the disk.
   282                        ;
   283                        ;As the default boot drive is A:, we only need to load the first set of drive offsets and
   284                        ; set these up in the BIOS. Note that these values will contain the actual starting LBA
   285                        ; for the first drive, as the partition offset value has been added to all drive offsets.
   286                        ;
   287                        ;As Blocking/De-blocking is handled in SIM, we need to test the Dirty Block flag to see
   288                        ; if there is a pending block write. If there is, we'll flush the buffer to disk.
   289                        ;
   290 00:CCFC: 6F 9F 0A                     bbr6    sim_recflg,no_flush     ;Check dirty block flag, branch if clear (5/6)
   291                        ;
   292                        ;SIM Flush Drive
   293                        ; - When PEM calls SIM to read or write a Record, blocking and de-blocking is done
   294                        ;   here in the routines below. To enhance performance for block writes, SIM will
   295                        ;   delay a block write as there are four records per block. If a different record
   296                        ;   is required by PEM, the current disk buffer will be checked via a dirty block
   297                        ;   flag and flushed to disk before loading the new calculated block. It's also
   298                        ;   important to check the dirty block flag via a warm boot, as applications don't
   299                        ;   know about this SIM feature.
   300                        ;
   301                        ; Write the current LBA in the bufer to the disk.
   302                        ;
   303 00:CCFF: 20 0C FF                     jsr     b_ide_write_lba ;Call BIOS to Write LBA (6)
   304 00:CD02: A5 FC                        lda     ide_status_ram  ;Get Status from BIOS call (3)
   305 00:CD04: 4A                           lsr     a               ;Shift error bit to carry (2)
   306 00:CD05: B0 1F                        bcs     ide_rw_err      ;Branch if error (2/3)
   307                        ;
   308 00:CD07: 67 9F                        rmb6    sim_recflg      ;reset dirty block flag (5)
   309                        ;
   310                        no_flush
   311 00:CD09: AD 84 CE                     lda     drv_offset+0    ;get LBA parameters (4)
   312 00:CD0C: AC 85 CE                     ldy     drv_offset+1    ; (4)
   313 00:CD0F: AE 86 CE                     ldx     drv_offset+2    ; (4)
   314 00:CD12: 20 12 FF                     jsr     b_ide_set_lba   ;call BIOS to set parameters (6)
   315                        ;
   316                        ; Next, set the load address for BIOS to load the CCM and PEM modules.
   317                        ; The X reg contains the number of blocks to load. CCM starts at "ramstrt", which
   318                        ; is defined in the main source file.
   319                        ; CCM uses 9 pages (256 bytes per page) and PEM uses 11 pages for a total of 20 pages.
   320                        ; This equates to a total of 5120 bytes, or 10- blocks from the Microdrive.
   321                        ;
   322 00:CD15: A9 00                        lda     #<ramstrt       ;get load address lo (2)
   323 00:CD17: A0 B8                        ldy     #>ramstrt       ;get load address hi (2)
   324 00:CD19: A2 0A                        ldx     #10             ;get block count (5KB for CCM and PEM) (2)
   325 00:CD1B: 20 15 FF                     jsr     b_ide_set_addr  ;call BIOS to set address and size (6)
   326 00:CD1E: 20 09 FF                     jsr     b_ide_read_lba  ;call BIOS to load CCM/PEM to memory (6)
   327 00:CD21: A5 FC                        lda     ide_status_ram  ;get Status from BIOS call (3)
   328 00:CD23: 4A                           lsr     a               ;shift error bit to carry (2)
   329 00:CD24: 90 9F                        bcc     sim_wsetup      ;if no error, reset PEM and start CCM (2/3)
   330                        ide_rw_err
   331 00:CD26: 4C 6D CE                     jmp     get_lba_err     ;else, use common error routine (3)
   332                        ;
   333                        ;**************************************************************************************************
   334                        ;
  Mon Apr  3 2023 10:57                                                                                                    Page 52


   335                        ;Console Input and Output Routines
   336                        ; There are three routines for Console I/O
   337                        ; 1- CONSTS - Console Status: tests to see if there is a character available
   338                        ; 2- CONRDE - Console Read: waits for a character to be available, then returns with it
   339                        ; 3- CONWRT - Console Write: sends a character to the console
   340                        ;
   341                        ;The console status routine does NOT read any data from the console itself.
   342                        ; It just checks to see if data has been entered. If no data is waiting, the A Reg has to be
   343                        ; zero. If data is waiting, the A Reg has to be a non-zero value, hence any or all bits set
   344                        ; active will work. The BIOS uses the page zero variable icnt_a to track the data count in
   345                        ; the input buffer. By simply loading the A Reg from icnt_a, the A reg will be either zero
   346                        ; or have a non-zero value. Note that the Z flag is also set if icnt_a is zero.
   347                        ;
   348                        mon_consts
   349 00:CD29: A5 D7                        lda     icnt_a          ;Load Input Buffer count (3)
   350 00:CD2B: 60                           rts                     ;Return to Caller (6)
   351                        ;
   352                        ;The console read routine calls the C02BIOS routine to get a character from the console.
   353                        ; As the C02BIOS can transfer 8-bit binary data, the upper bit is masked off to ensure ASCII
   354                        ; only. Also, the standard Delete key code from the console is a Backspace ($08). The PEM
   355                        ; routine checks for the Delete key, so this routine will check for Backspace and replace it
   356                        ; with a Delete code.
   357                        ;
   358                        mon_conrde
   359 00:CD2C: 20 39 FF                     jsr     b_chrin         ;Call BIOS for character in (waits) (6)
   360 00:CD2F: 29 7F                        and     #$7F            ;Strip off high bit (ASCII only) (2)
   361 00:CD31: C9 08                        cmp     #bs             ;Check for Backspace character (2)
   362 00:CD33: D0 02                        bne     conrdx          ;If not, branch (2/3)
   363 00:CD35: A9 7F                        lda     #delete         ;Else, replace with Delete code (2)
   364 00:CD37: 60           conrdx          rts                     ;Return to Caller (6)
   365                        ;
   366                        ;The console write routine is straightforward. As per the System Interface Guide, the SIM
   367                        ; routine does not need to preserve the character being written to the console. We only take the
   368                        ; approach of stripping off the high bit to ensure ASCII only.
   369                        ;
   370                        mon_conwrt
   371 00:CD38: 29 7F                        and     #$7F            ;strip off high bit for ASCII (2)
   372 00:CD3A: 4C 3C FF                     jmp     b_chrout        ;send to BIOS and return (3)
   373                        ;
   374                        ;**************************************************************************************************
   375                        ;
   376                        ;Additional routines for using the second serial port via C02BIOS routines
   377                        ; these are simple binary passthru routines, no data input or output is modified.
   378                        ;
   379                        mon_punch
   380 00:CD3D: 4C 2A FF                     jmp     b_chrout2       ;send data to serial port 2 (3)
   381                        ;
   382                        mon_reader
   383 00:CD40: 4C 27 FF                     jmp     b_chrin2        ;get data from serial port 2 (3)
   384                        ;
   385                        ;**************************************************************************************************
   386                        ;
   387                        ;Start of Disk I/O Routines:
   388                        ; Note that these routines rely on the C02BIOS calls for physical access of the Microdrive!
   389                        ; 
   390                        ; Blocking/De-blocking is always used for IDE devices (default LBA size = 512 bytes)
   391                        ; All drives are configured with the same defaults as:
   392                        ;
   393                        ; - 4096 total blocks
   394                        ; - 4 records per LBA (drive physical block size)
   395                        ; - 16 records per block (DOS/65 Allocation size per extent)
   396                        ;
   397                        ; This section contains all new routines that are designed to work with Record Numbers!
  Mon Apr  3 2023 10:57                                                                                                    Page 53


   398                        ;
   399                        ; Records is a 16-bit field and record lengths are 128-bytes. The new routines provide a simple
   400                        ; translation layer that will read and write blocks from the Microdrive. Each 512-byte block
   401                        ; contains 4- 128-byte records. This calculates to a total of 8MB of disk space allocated via
   402                        ; the 64K of records per drive letter.
   403                        ;
   404                        ; There are several routines which are required to support the SIM functions
   405                        ;
   406                        ;Record Move routines
   407                        ; there are two sets of Record Move routines;
   408                        ; - set one moves a Record from the LBA buffer to the DMA address specified by PEM
   409                        ; - set two moves a Record from the DMA address specified by PEM to the LBA buffer
   410                        ; In short, Set one is for reading a Record from disk and moving to memory, while
   411                        ; set two is for writing a Record from memory and moving to disk.
   412                        ;
   413                        ;Select disk
   414                        ; drive range is now validated by PEM before making this SIM call.
   415                        ;
   416 00:CD43: 8D 79 CE     sim_seldsk      sta     sim_seldrv      ;save as current drive (4)
   417 00:CD46: 0A                           asl     a               ;multiply by two (2)
   418 00:CD47: AA                           tax                     ;make an index (2)
   419 00:CD48: BD 4F CD                     lda     sim_dcbtbl,x    ;get DCB address (4)
   420 00:CD4B: BC 50 CD                     ldy     sim_dcbtbl+1,x  ; in A/Y (4)
   421 00:CD4E: 60                           rts                     ;and return (6)
   422                        ;
   423                        ;Table of dcb addresses.
   424                        ; All 8 drives are accounted for, if not present, use a word value of "0000".
   425                        ;
   426 00:CD4F: A8 CE        sim_dcbtbl      .DW     dcb_a
   427 00:CD51: B3 CE                        .DW     dcb_b
   428 00:CD53: BE CE                        .DW     dcb_c
   429 00:CD55: C9 CE                        .DW     dcb_d
   430 00:CD57: D4 CE                        .DW     dcb_e
   431 00:CD59: DF CE                        .DW     dcb_f
   432 00:CD5B: EA CE                        .DW     dcb_g
   433 00:CD5D: F5 CE                        .DW     dcb_h
   434                        ;
   435                        ;Set DOS/65 memory buffer address
   436                        ;
   437 00:CD5F: 8D 7A CE     sim_setdma      sta     sim_dmaadr      ;save address low (4)
   438 00:CD62: 8C 7B CE                     sty     sim_dmaadr+1    ;save address high (4)
   439 00:CD65: 60                           rts                     ;return (6)
   440                        ;
   441                        ;Set Requested Record
   442                        ; Note that PEM calculates the Record number to include any Reserved Records.
   443                        ;
   444 00:CD66: 8D 7C CE     sim_setrec      sta     sim_pemrec      ;save record low (4)
   445 00:CD69: 8C 7D CE                     sty     sim_pemrec+1    ;save record high (4)
   446 00:CD6C: 60                           rts                     ;return (6)
   447                        ;
   448                        ;*************************************************************************************************
   449                        ;
   450                        ;Read the selected DOS/65 record.
   451                        ;
   452                        sim_read
   453 00:CD6D: D7 9F                        smb5    sim_recflg      ;set read op flag (5)
   454 00:CD6F: 20 DD CD                     jsr     get_lba         ;calculate/get LBA to read (6)
   455                        ;
   456                        ;Transfer the record from buffer to DMA
   457                        ;
   458 00:CD72: A5 9F                        lda     sim_recflg      ;get recflg (4)
   459 00:CD74: 29 03                        and     #%00000011      ;mask for lower 2-bits (2)
   460 00:CD76: 0A                           asl     a               ;multiply by 2 for index (2)
  Mon Apr  3 2023 10:57                                                                                                    Page 54


   461 00:CD77: AA                           tax                     ;xfer to X reg as index (2)
   462                        ;
   463 00:CD78: BD D5 CD                     lda     buff_offset,x   ;get buffer offset address (4)
   464 00:CD7B: BC D6 CD                     ldy     buff_offset+1,x ; (4)
   465 00:CD7E: 8D 93 CD                     sta     mover+1         ;save to routine lo (4)
   466 00:CD81: 8C 94 CD                     sty     mover+2         ;save to routine hi (4)
   467                        ;
   468 00:CD84: AD 7A CE                     lda     sim_dmaadr+0    ;get dma address lo (4)
   469 00:CD87: AC 7B CE                     ldy     sim_dmaadr+1    ;get dma address hi (4)
   470 00:CD8A: 8D 96 CD                     sta     mover+4         ;save to routine lo (4)
   471 00:CD8D: 8C 97 CD                     sty     mover+5         ;save to routine hi (4)
   472 00:CD90: A0 00                        ldy     #0              ;zero index (2)
   473                        ;
   474                        mover
   475 00:CD92: B9 FF FF                     lda     $FFFF,y         ;get from source address (4)
   476 00:CD95: 99 FF FF                     sta     $FFFF,y         ;move to destination address (5)
   477 00:CD98: C8                           iny                     ;increment offset (2)
   478 00:CD99: 10 F7                        bpl     mover           ;loop back until done (2/3)
   479                        ;
   480 00:CD9B: 57 9F                        rmb5    sim_recflg      ;reset read op flag (5)
   481 00:CD9D: A9 00                        lda     #0              ;zero for no error (2)
   482 00:CD9F: 60                           rts                     ;return (6)
   483                        ;
   484                        ;Write the selected DOS/65 record.
   485                        ;
   486                        sim_write
   487 00:CDA0: C7 9F                        smb4    sim_recflg      ;set write op flag (5)
   488 00:CDA2: 20 DD CD                     jsr     get_lba         ;calculate/get LBA to write (6)
   489                        ;
   490                        ;Transfer the record from DMA to buffer
   491                        ;
   492 00:CDA5: A5 9F                        lda     sim_recflg      ;get recflg (4)
   493 00:CDA7: 29 03                        and     #%00000011      ;mask for lower 2-bits (2)
   494 00:CDA9: 0A                           asl     a               ;multiply by 2 for index (2)
   495 00:CDAA: AA                           tax                     ;xfer to X reg as index (2)
   496                        ;
   497 00:CDAB: BD D5 CD                     lda     buff_offset,x   ;get buffer offset address (4)
   498 00:CDAE: BC D6 CD                     ldy     buff_offset+1,x ; (4)
   499 00:CDB1: 8D C9 CD                     sta     movew+4         ;save to routine lo (4)
   500 00:CDB4: 8C CA CD                     sty     movew+5         ;save to routine hi (4)
   501                        ;
   502 00:CDB7: AD 7A CE                     lda     sim_dmaadr+0    ;get dma address lo (4)
   503 00:CDBA: AC 7B CE                     ldy     sim_dmaadr+1    ;get dma address hi (4)
   504 00:CDBD: 8D C6 CD                     sta     movew+1         ;save to routine lo (4)
   505 00:CDC0: 8C C7 CD                     sty     movew+2         ;save to routine hi (4)
   506 00:CDC3: A0 00                        ldy     #0              ;zero index (2)
   507                        ;
   508                        movew
   509 00:CDC5: B9 FF FF                     lda     $FFFF,y         ;get from source address (4)
   510 00:CDC8: 99 FF FF                     sta     $FFFF,y         ;move to destination address (5)
   511 00:CDCB: C8                           iny                     ;increment offset (2)
   512 00:CDCC: 10 F7                        bpl     movew           ;loop back until done (2/3)
   513                        ;
   514 00:CDCE: E7 9F                        smb6    sim_recflg      ;set dirty block flag (5)
   515                        ;
   516 00:CDD0: 47 9F                        rmb4    sim_recflg      ;reset write op flag (5)
   517 00:CDD2: A9 00                        lda     #0              ;zero for no error (2)
   518 00:CDD4: 60                           rts                     ;return to caller (6)
   519                        ;
   520                        ;Buffer Offsets.
   521                        ; The offsets here point to the 4- 128-byte Records in the main Disk Buffer.
   522                        ;
   523                        buff_offset
  Mon Apr  3 2023 10:57                                                                                                    Page 55


   524 00:CDD5: 00 06                        .DW     LBA_BUFFER+0    ;buffer offset 00
   525 00:CDD7: 80 06                        .DW     LBA_BUFFER+128  ;buffer offset 01
   526 00:CDD9: 00 07                        .DW     LBA_BUFFER+256  ;buffer offset 10
   527 00:CDDB: 80 07                        .DW     LBA_BUFFER+384  ;buffer offset 11
   528                        ;
   529                        ;**************************************************************************************************
   530                        ;
   531                        ;Get LBA routine
   532                        ; This is a core routine for SIM and all disk level activity. Now that PEM
   533                        ; and SIM have been moved to a Record level access, the conversion between
   534                        ; 128-byte records and 512-byte LBA block sizes can be streamlined.
   535                        ;
   536                        ;This routine is common for both Reading and Writing of Records. As there
   537                        ; is still a requirement to perform blocking/de-blocking from PEM Records
   538                        ; to disk block sizes, this routine will perform the following tasks:
   539                        ;
   540                        ; 1- Calculate the Block Number from the Record number.
   541                        ; 2- Save the Record offset within the calculated block number.
   542                        ; 3- Check to see if a valid disk block is loaded in the buffer.
   543                        ; 4- Perform a block read if there is no valid block loaded.
   544                        ; 5- Test the valid block loaded against the required block number.
   545                        ; 6- Test for a pending write for the valid block number.
   546                        ; 7- Write a pending block and clear the dirty block flag if required.
   547                        ; 8- Only load a block if needed, else return without disk I/O access.
   548                        ; 9- Add the Drive offset to the required Block.
   549                        ;
   550                        ;This is a fair amount of work, but this core routine ensures we have the
   551                        ; correct block in the default disk buffer on which to read or write
   552                        ; records to or from. This routine also simplifies the Record Read and Write
   553                        ; routines to focus only on handling the required 128-byte record.
   554                        ;
   555                        ; Another advantage is that this routine will only load a new block when
   556                        ; it needs to, i.e., if the calculated block is already loaded, it will
   557                        ; not reload it, but simply return and allow the Record Read and Write
   558                        ; routines to carry out their record level function.
   559                        ; This improves the overall disk I/O performance.
   560                        ;
   561                        ;Calculate the block number (LBA) based on the Record number.
   562                        ; The Record number is a 16-bit value (0-65,535) and is 128-bytes in size.
   563                        ; To calculate the LBA, we simply divide it by 4, as there are 4 records
   564                        ; per 512-byte block (LBA). We also save the lower 2-bits as this becomes
   565                        ; the offset of the requested record into the block (as binary, 00,01,10,11).
   566                        ;
   567                        ;First, we need to take the Record Number and do the following:
   568                        ; 1- Save the Record offset (the lower 2-bits of the Record number).
   569                        ; 2- Perform a 16-bit Logical Right Shift by 2-bits (divide by 4).
   570                        ; 3- Add the Drive number offset to the required LBA.
   571                        ; 4- Save the calculated LBA, then check the flag byte for an LBA loaded.
   572                        ;
   573                        ;Second, we need to test for the following conditions:
   574                        ; 1- If a LBA is loaded, check to see if it is the same LBA that we need.
   575                        ; 2- If it is, just exit back to the calling routine, saving a disk read.
   576                        ; 3- If it it NOT, check the dirty block flag in case it's been altered.
   577                        ; 4- If the dirty block is set, write the current block and clear the flag,
   578                        ;    then update the parameters and load the new LBA.
   579                        ; 5- If the dirty block is not set, update the parameters and load the new LBA.
   580                        ;
   581                        ;The C02BIOS used here is Version 4.02.
   582                        ; This BIOS supports 24-bit LBA addressing.
   583                        ; Note: IDE uses 28-bit addressing, but the BIOS zeros the upper 4-bits,
   584                        ; resulting in a limit of 8GB for the attached IDE device.
   585                        ;
   586                        ;The SIM configuration is set for 8 drives (A thru H), each at 8MB.
  Mon Apr  3 2023 10:57                                                                                                    Page 56


   587                        ; Any of the defined drives can have Reserved Records, but in practical
   588                        ; use, only one drive should have Reserved Records to be use for holding
   589                        ; the bootable image for the OS (CCM, PEM, SIM, Allocation Tables).
   590                        ; The first drive will normally have the Reserved Records to hold the
   591                        ; bootable OS image, where a total of 256 Records will equate to 32KB.
   592                        ;
   593                        ; NOTE: The PEM routine that calls SIM for the requested record also
   594                        ; adds in the reserved record count, so we don't need to do that here!
   595                        ;
   596                        ;Once the Block number has been calculated from the Record number,
   597                        ; an offset must be added which is based on the Drive number (0-7).
   598                        ; Partition sizes are limited to 8MB
   599                        ; Number of drives is limited to 8 (A - H)
   600                        ; Maximum available Data is limited to 64MB
   601                        ;
   602                        ;The Offset table is 4 bytes per entry and adds an LBA count to
   603                        ; shift the absolute LBA numbers to the appropriate drive number
   604                        ; being acessed (16384 blocks per 8MB drive area).
   605                        ;
   606                        ;First, calculate the record number to LBA number and
   607                        ; store the LBA number to sim_pemrec (3 bytes).
   608                        ;
   609                        get_lba
   610 00:CDDD: A9 03                        lda     #%00000011      ;Get mask for record offset bits (2)
   611 00:CDDF: 14 9F                        trb     sim_recflg      ;Reset record offset bits in flag (5)
   612                        ;
   613 00:CDE1: 9C 80 CE                     stz     sim_rectemp+2   ;Clear extended temp byte (4)
   614 00:CDE4: AD 7D CE                     lda     sim_pemrec+1    ;Get PEM Record number high byte )4)
   615 00:CDE7: 8D 7F CE                     sta     sim_rectemp+1   ;Save to temp (4)
   616 00:CDEA: AD 7C CE                     lda     sim_pemrec+0    ;Get PEM Record number low byte (4)
   617 00:CDED: 8D 7E CE                     sta     sim_rectemp+0   ;Save to temp (4)
   618                        ;
   619 00:CDF0: 29 03                        and     #%00000011      ;Mask off upper 6 bits (2)
   620 00:CDF2: 05 9F                        ora     sim_recflg      ;OR in other record flag bits (3)
   621 00:CDF4: 85 9F                        sta     sim_recflg      ;Update the record flag for new offset (3)
   622                        ;
   623                        ; now do the 16-bit shift to the right to divide by 4 and get the LBA number
   624                        ;
   625 00:CDF6: 4E 7F CE                     lsr     sim_rectemp+1   ;Shift high to right, LSB to carry (6)
   626 00:CDF9: 6E 7E CE                     ror     sim_rectemp     ;Rotate low to right, MSB from carry (6)
   627 00:CDFC: 4E 7F CE                     lsr     sim_rectemp+1   ;Shift high to the right, LSB to carry (6)
   628 00:CDFF: 6E 7E CE                     ror     sim_rectemp     ;Rotate low to right, MSB from carry (6)
   629                        ;
   630                        ; the sim_rectemp pointer now has the logical LBA number requested by PEM.
   631                        ; the sim_recflg also contains the record offset in the lower 2 bits,
   632                        ; plus the other flags have been preserved (very important).
   633                        ;
   634                        ; Note that the partition offset (common for all drives) has been added as
   635                        ; a one-time calculation during the first startup of SIM. As all drive
   636                        ; offsets have been updated with the parition offset, we only need to
   637                        ; apply the drive offset based on the current drive A-H (0-7).
   638                        ;
   639 00:CE02: AD 79 CE                     lda     sim_seldrv      ;Get active drive number (4)
   640 00:CE05: 0A                           asl     a               ;Multiply by two (2)
   641 00:CE06: 0A                           asl     a               ;Multiply by two (now = 4) (2)
   642 00:CE07: AA                           tax                     ;Xfer offset to X reg (2)
   643                        ;
   644 00:CE08: 18                           clc                     ;Clear Carry for Add (2)
   645 00:CE09: AD 7E CE                     lda     sim_rectemp+0   ;Get Low order LBA (4)
   646 00:CE0C: 7D 84 CE                     adc     drv_offset+0,x  ;Add in Low order offset (4)
   647 00:CE0F: 8D 7E CE                     sta     sim_rectemp+0   ;Save to Low order LBA (4)
   648                        ;
   649 00:CE12: AD 7F CE                     lda     sim_rectemp+1   ;Get Middle order LBA (4)
  Mon Apr  3 2023 10:57                                                                                                    Page 57


   650 00:CE15: 7D 85 CE                     adc     drv_offset+1,x  ;Add in Middle order offset (4)
   651 00:CE18: 8D 7F CE                     sta     sim_rectemp+1   ;Save to Middle order LBA (4)
   652                        ;
   653 00:CE1B: AD 80 CE                     lda     sim_rectemp+2   ;Get High order LBA (4)
   654 00:CE1E: 7D 86 CE                     adc     drv_offset+2,x  ;Add in High order offset (4)
   655 00:CE21: 8D 80 CE                     sta     sim_rectemp+2   ;Save to High order LBA (4)
   656                        ;
   657                        ; now, the actual required LBA has been calculated and is stored as a 24-bit value.
   658                        ; this is stored in variable "sim_rectemp" (3 consecutive bytes).
   659                        ; We now need to compare the actual LBA needed to the currently loaded LBA, if there
   660                        ; is one. We first test for a valid LBA loaded by checking bit7 of the sim_recflg.
   661                        ;
   662 00:CE24: 7F 9F 26                     bbr7    sim_recflg,need_lba     ;Test sim_recflg for valid LBA (5/6)
   663                        ;
   664                        ; we have determined that a valid LBA is loaded, so we need to compare the LBA
   665                        ; that's been requested against the currently loaded LBA. If they are the same, we're
   666                        ; done and can return. If they are not, then we need to check the dirty block flag to
   667                        ; ensure the active block is written before we over-write it with the new one.
   668                        ;
   669 00:CE27: AD 7E CE                      lda    sim_rectemp+0   ;Get low order requested LBA (4)
   670 00:CE2A: CD 81 CE                      cmp    sim_curlba+0    ;Compare to current LBA (4)
   671 00:CE2D: D0 11                         bne    test_dirty      ;Bad compare, test for dirty block (2/3)
   672 00:CE2F: AD 7F CE                      lda    sim_rectemp+1   ;Get middle order requested LBA (4)
   673 00:CE32: CD 82 CE                      cmp    sim_curlba+1    ;Compare to current LBA (4)
   674 00:CE35: D0 09                         bne    test_dirty      ;Bad compare, test for dirty block (2/3)
   675 00:CE37: AD 80 CE                      lda    sim_rectemp+2   ;Get high order requested LBA (4)
   676 00:CE3A: CD 83 CE                      cmp    sim_curlba+2    ;Compare to current LBA (4)
   677 00:CE3D: D0 01                         bne    test_dirty      ;Bad compare, test for dirty block (2/3)
   678 00:CE3F: 60                            rts                    ;Good compare, requested LBA is loaded (6)
   679                        ;
   680                        ; test the dirty block flag.
   681                        ; the currently loaded LBA is not the one we need loaded.
   682                        ; before we overwrite it, we'll test the dirty block flag.
   683                        ; if it's set, we'll write that block to disk to update it, then transfer
   684                        ; the parameters for the new LBA and load it.
   685                        ;
   686                        test_dirty
   687 00:CE40: 6F 9F 0A                     bbr6    sim_recflg,need_lba     ;Test sim_recflg for dirty block flag (5/6)
   688                        ;
   689                        ; we have a dirty block in the buffer... so we need to write the current LBA back
   690                        ; to the drive to ensure we don't get corrupted data on the drive!
   691                        ; note that the existing BIOS parameters still point to the currently loaded LBA.
   692                        ;
   693 00:CE43: 20 0C FF                     jsr     b_ide_write_lba ;Call BIOS to Write LBA (6)
   694 00:CE46: A5 FC                        lda     ide_status_ram  ;Get Status from BIOS call (3)
   695 00:CE48: 4A                           lsr     a               ;Shift error bit to carry (2)
   696 00:CE49: B0 22                        bcs     get_lba_err     ;Branch if error (2/3)
   697 00:CE4B: 67 9F                        rmb6    sim_recflg      ;reset dirty block flag (5)
   698                        ;
   699                        ; now that the dirty block has been cleared, we can load the required LBA
   700                        ; into the disk buffer, update the flags and return.
   701                        ;
   702                        ; if we branched here from above, no valid LBA is loaded, so we just transfer the
   703                        ; LBA parameters to the BIOS and read the block into the default LBA buffer.
   704                        ;
   705                        need_lba
   706 00:CE4D: AD 7E CE                     lda     sim_rectemp+0   ;Get required LBA parameters (Low byte) (4)
   707 00:CE50: AC 7F CE                     ldy     sim_rectemp+1   ; Middle byte (4)
   708 00:CE53: AE 80 CE                     ldx     sim_rectemp+2   ; High byte (4)
   709                        ;
   710 00:CE56: 8D 81 CE                     sta     sim_curlba+0    ;Save as Current LBA (4)
   711 00:CE59: 8C 82 CE                     sty     sim_curlba+1    ; for check the next (4)
   712 00:CE5C: 8E 83 CE                     stx     sim_curlba+2    ; time get_lba is called (4)
  Mon Apr  3 2023 10:57                                                                                                    Page 58


   713                        ;
   714 00:CE5F: 20 12 FF                     jsr     b_ide_set_lba   ;Call BIOS to set LBA parameters (6)
   715                        ;
   716 00:CE62: 20 09 FF                     jsr     b_ide_read_lba  ;Call BIOS to Read LBA (6)
   717 00:CE65: A5 FC                        lda     ide_status_ram  ;Get Status from BIOS call (3)
   718 00:CE67: 4A                           lsr     a               ;Shift error bit to carry (2)
   719 00:CE68: B0 03                        bcs     get_lba_err     ;Branch if error (2/3)
   720 00:CE6A: F7 9F                        smb7    sim_recflg      ;set valid LBA flag bit (5)
   721 00:CE6C: 60                           rts                     ;return to caller, we're done (6)
   722                        get_lba_err
   723 00:CE6D: 77 9F                        rmb7    sim_recflg      ;reset valid LBA flag bit (5)
   724 00:CE6F: A9 6A                        lda     #<io_err_msg    ;Point to error message (2)
   725 00:CE71: A0 CC                        ldy     #>io_err_msg    ; (2)
   726 00:CE73: 20 5A E0                     jsr     m_promptr       ;Send it (6)
   727 00:CE76: 4C 80 CC                     jmp     sim_boot        ;Restart SIM (3)
   728                        ;
   729                        ;**************************************************************************************************
   730                        ; SIM Data area
   731                        ;
   732                        ;Record level data area required by SIM
   733 00:CE79:              sim_seldrv      DEFS    1               ;Current selected drive number (0-7)
   734 00:CE7A:              sim_dmaadr      DEFS    2               ;DMA address to Record transfer
   735 00:CE7C:              sim_pemrec      DEFS    2               ;Record number requested by PEM
   736 00:CE7E:              sim_rectemp     DEFS    3               ;Calculated LBA required by PEM (with Partition/Drive offsets)
   737 00:CE81:              sim_curlba      DEFS    3               ;LBA number currently loaded in Buffer (plus warm boot LBA)
   738                        ;
   739                        ;**************************************************************************************************
   740                        ;
   741                        ;Table of LBA offsets for all drives A thru H (8MB each, 16KB Blocks per drive)
   742                        ;
   743                        ;NOTE: These offsets are based on a non-partitioned drive!!! Relative to each other only!
   744                        ; The partition offset below as "part_offset" is added to the "drv_offset" values the first time
   745                        ; SIM is started. To ensure this only happens once, the "part_offset" data is zeroed out after it
   746                        ; is added to the "drv_offset". Once the new values are loaded, the active drive being accessed
   747                        ; is used as a base offset and the block offset calculated by the requested Record from PEM is
   748                        ; added to get the actual 512-byte block address on the drive.
   749                        ;
   750                        drv_offset
   751 00:CE84: 00 00 00 00                  .LONG   0               ;Drive A default (w/OS boot image)
   752 00:CE88: 00 40 00 00                  .LONG   16384           ;Drive B
   753 00:CE8C: 00 80 00 00                  .LONG   32768           ;Drive C
   754 00:CE90: 00 C0 00 00                  .LONG   49152           ;Drive D
   755 00:CE94: 00 00 01 00                  .LONG   65536           ;Drive E
   756 00:CE98: 00 40 01 00                  .LONG   81920           ;Drive F
   757 00:CE9C: 00 80 01 00                  .LONG   98304           ;Drive G
   758 00:CEA0: 00 C0 01 00                  .LONG   114688          ;Drive H
   759                        ;
   760                        ;Partition Offset
   761                        ; this offset is patched in during boot time from the boot loader.
   762                        ; this compensates for the drive partition being located anywhere on the drive.
   763                        ;
   764                        part_offset
   765 00:CEA4: 00 00 02 00                  .LONG   131072          ;Partition offset for drive letters
   766                        ;
   767                        ;**************************************************************************************************
   768                        ;
   769                        ;Disk Control Blocks (DCBs)
   770                        ; Updated to support 8 drives by default - KM
   771                        ;
   772                        ; Note: The Disk Control Block format has been changed with Version 3.20!
   773                        ;       The second parameter is now defined as the number of records per block.
   774                        ;       - this is the physical block size of the storage device. For any standard IDE device,
   775                        ;         the default block size is 512 bytes. This calculates to 4 records per block.
  Mon Apr  3 2023 10:57                                                                                                    Page 59


   776                        ;       The third parameter is now defined as the number of reserved records (128 bytes/record).
   777                        ;       The last two parameters have been deleted! These last two parameters are not needed
   778                        ;       for a standard block device, as the device itself can not be removed or ejected.
   779                        ;
   780                        ; The changes here frees up 3 bytes per DCB. Also note that the code that supports the checksum
   781                        ; functions in PEM have also been eliminated. This frees up space in PEM and also provides
   782                        ; a very slight performance improvement.
   783                        ;
   784                        ;drive a (Microdrive 8MB)
   785 00:CEA8: EF 0F        dcb_a           .DW     4079            ;max block number-1
   786 00:CEAA: 04 00                        .DW     4               ;records per physical block
   787 00:CEAC: 00 01                        .DW     256             ;number of reserved records (32KB OS-boot)
   788 00:CEAE: 01                           .DB     1               ;block size = 2048
   789 00:CEAF: FF 03                        .DW     1023            ;max directory-1
   790 00:CEB1: 00 D0                        .DW     almpa           ;address of allocation map
   791                        ;
   792                        ;drive b (Microdrive 8MB)
   793 00:CEB3: FF 0F        dcb_b           .DW     4095            ;max block number-1
   794 00:CEB5: 04 00                        .DW     4               ;records per physical block
   795 00:CEB7: 00 00                        .DW     0               ;number of reserved records
   796 00:CEB9: 01                           .DB     1               ;block size = 2048
   797 00:CEBA: FF 03                        .DW     1023            ;max directory-1
   798 00:CEBC: 00 D2                        .DW     almpb           ;address of allocation map
   799                        
   800                        ;
   801                        ;drive c (Microdrive 8MB)
   802 00:CEBE: FF 0F        dcb_c           .DW     4095            ;max block number-1
   803 00:CEC0: 04 00                        .DW     4               ;records per physical block
   804 00:CEC2: 00 00                        .DW     0               ;number of reserved records
   805 00:CEC4: 01                           .DB     1               ;block size = 2048
   806 00:CEC5: FF 03                        .DW     1023            ;max directory-1
   807 00:CEC7: 00 D4                        .DW     almpc           ;address of allocation map
   808                        ;
   809                        ;drive d (Microdrive 8MB)
   810 00:CEC9: FF 0F        dcb_d           .DW     4095            ;max block number-1
   811 00:CECB: 04 00                        .DW     4               ;records per physical block
   812 00:CECD: 00 00                        .DW     0               ;number of reserved records
   813 00:CECF: 01                           .DB     1               ;block size = 2048
   814 00:CED0: FF 03                        .DW     1023            ;max directory-1
   815 00:CED2: 00 D6                        .DW     almpd           ;address of allocation map
   816                        ;
   817                        ;drive e (Microdrive 8MB)
   818 00:CED4: FF 0F        dcb_e           .DW     4095            ;max block number-1
   819 00:CED6: 04 00                        .DW     4               ;records per physical block
   820 00:CED8: 00 00                        .DW     0               ;number of reserved records
   821 00:CEDA: 01                           .DB     1               ;block size = 2048
   822 00:CEDB: FF 03                        .DW     1023            ;max directory-1
   823 00:CEDD: 00 D8                        .DW     almpe           ;address of allocation map
   824                        ;
   825                        ;drive f (Microdrive 8MB)
   826 00:CEDF: FF 0F        dcb_f           .DW     4095            ;max block number-1
   827 00:CEE1: 04 00                        .DW     4               ;records per physical block
   828 00:CEE3: 00 00                        .DW     0               ;number of reserved records
   829 00:CEE5: 01                           .DB     1               ;block size = 2048
   830 00:CEE6: FF 03                        .DW     1023            ;max directory-1
   831 00:CEE8: 00 DA                        .DW     almpf           ;address of allocation map
   832                        ;
   833                        ;drive g (Microdrive 8MB)
   834 00:CEEA: FF 0F        dcb_g           .DW     4095            ;max block number-1
   835 00:CEEC: 04 00                        .DW     4               ;records per physical block
   836 00:CEEE: 00 00                        .DW     0               ;number of reserved records
   837 00:CEF0: 01                           .DB     1               ;block size = 2048
   838 00:CEF1: FF 03                        .DW     1023            ;max directory-1
  Mon Apr  3 2023 10:57                                                                                                    Page 60


   839 00:CEF3: 00 DC                        .DW     almpg           ;address of allocation map
   840                        ;
   841                        ;drive h (Microdrive 8MB)
   842 00:CEF5: FF 0F        dcb_h           .DW     4095            ;max block number-1
   843 00:CEF7: 04 00                        .DW     4               ;records per physical block
   844 00:CEF9: 00 00                        .DW     0               ;number of reserved records
   845 00:CEFB: 01                           .DB     1               ;block size = 2048
   846 00:CEFC: FF 03                        .DW     1023            ;max directory-1
   847 00:CEFE: 00 DE                        .DW     almph           ;address of allocation map
   848                        ;
   849                        ;**************************************************************************************************
   850                        ;
   851                                        END
   194                        ;
   195                        ;**************************************************************************************************
   196                        ;
   197                                        .ORG    $/256*256+256           ;Align to Page address
   198                        ;
   199                        alloc_maps
   200                        ;allocation and checksum maps
   201                        ;
   202                        ;drive a
   203             0000D000   almpa           .EQU    alloc_maps
   204 00:D000: 00 00                        .BLKW   256
   205                        ;drive b
   206             0000D200   almpb           .EQU    almpa+512
   207 00:D200: 00 00                        .BLKW   256
   208                        ;drive c
   209             0000D400   almpc           .EQU    almpb+512
   210 00:D400: 00 00                        .BLKW   256
   211                        ;drive d
   212             0000D600   almpd           .EQU    almpc+512
   213 00:D600: 00 00                        .BLKW   256
   214                        ;drive e
   215             0000D800   almpe           .EQU    almpd+512
   216 00:D800: 00 00                        .BLKW   256
   217                        ;drive f
   218             0000DA00   almpf           .EQU    almpe+512
   219 00:DA00: 00 00                        .BLKW   256
   220                        ;drive g
   221             0000DC00   almpg           .EQU    almpf+512
   222 00:DC00: 00 00                        .BLKW   256
   223                        ;drive h
   224             0000DE00   almph           .EQU    almpg+512
   225 00:DE00: 00 00                        .BLKW   256
   226                        ;
   227                                END


      Lines assembled: 4208
      Errors: 0
